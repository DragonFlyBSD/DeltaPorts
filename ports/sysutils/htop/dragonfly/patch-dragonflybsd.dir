--- /dev/null
+++ dragonflybsd/Battery.c
@@ -0,0 +1,26 @@
+/*
+htop - dragonflybsd/Battery.c
+(C) 2015 Hisham H. Muhammad
+(C) 2017 Diederik de Groot
+Released under the GNU GPL, see the COPYING file
+in the source distribution for its full text.
+*/
+
+#include "BatteryMeter.h"
+#include <sys/sysctl.h>
+
+void Battery_getData(double* level, ACPresence* isOnAC) {
+   int life;
+   size_t life_len = sizeof(life);
+   if (sysctlbyname("hw.acpi.battery.life", &life, &life_len, NULL, 0) == -1)
+      *level = -1;
+   else
+      *level = life;
+
+   int acline;
+   size_t acline_len = sizeof(acline);
+   if (sysctlbyname("hw.acpi.acline", &acline, &acline_len, NULL, 0) == -1)
+      *isOnAC = AC_ERROR;
+   else
+      *isOnAC = acline == 0 ? AC_ABSENT : AC_PRESENT;
+}
--- /dev/null
+++ dragonflybsd/Battery.h
@@ -0,0 +1,15 @@
+/* Do not edit this file. It was automatically generated. */
+
+#ifndef HEADER_Battery
+#define HEADER_Battery
+/*
+htop - dragonflybsd/Battery.h
+(C) 2015 Hisham H. Muhammad
+(C) 2017 Diederik de Groot
+Released under the GNU GPL, see the COPYING file
+in the source distribution for its full text.
+*/
+
+void Battery_getData(double* level, ACPresence* isOnAC);
+
+#endif
--- /dev/null
+++ dragonflybsd/DragonFlyBSDCRT.c
@@ -0,0 +1,35 @@
+/*
+htop - dragonflybsd/DragonFlyBSDCRT.c
+(C) 2014 Hisham H. Muhammad
+(C) 2017 Diederik de Groot
+Released under the GNU GPL, see the COPYING file
+in the source distribution for its full text.
+*/
+
+#include "config.h"
+#include "CRT.h"
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef HAVE_EXECINFO_H
+#include <execinfo.h>
+#endif
+
+void CRT_handleSIGSEGV(int sgn) {
+   (void) sgn;
+   CRT_done();
+   fprintf(stderr, "\n\nhtop " VERSION " aborting. Please report bug at http://hisham.hm/htop\n");
+   #ifdef HAVE_EXECINFO_H
+   size_t size = backtrace(backtraceArray, sizeof(backtraceArray) / sizeof(void *));
+   fprintf(stderr, "\n Please include in your report the following backtrace: \n");
+   backtrace_symbols_fd(backtraceArray, size, 2);
+   fprintf(stderr, "\nAdditionally, in order to make the above backtrace useful,");
+   fprintf(stderr, "\nplease also run the following command to generate a disassembly of your binary:");
+   fprintf(stderr, "\n\n   objdump -d `which htop` > ~/htop.objdump");
+   fprintf(stderr, "\n\nand then attach the file ~/htop.objdump to your bug report.");
+   fprintf(stderr, "\n\nThank you for helping to improve htop!\n\n");
+   #else
+   fprintf(stderr, "\nPlease contact your DragonFlyBSD package maintainer!\n\n");
+   #endif
+   abort();
+}
+
--- /dev/null
+++ dragonflybsd/DragonFlyBSDCRT.h
@@ -0,0 +1,19 @@
+/* Do not edit this file. It was automatically generated. */
+
+#ifndef HEADER_DragonFlyBSDCRT
+#define HEADER_DragonFlyBSDCRT
+/*
+htop - dragonflybsd/DragonFlyBSDCRT.h
+(C) 2014 Hisham H. Muhammad
+(C) 2017 Diederik de Groot
+Released under the GNU GPL, see the COPYING file
+in the source distribution for its full text.
+*/
+
+#ifdef HAVE_EXECINFO_H
+#endif
+
+void CRT_handleSIGSEGV(int sgn);
+
+
+#endif
--- /dev/null
+++ dragonflybsd/DragonFlyBSDProcess.c
@@ -0,0 +1,166 @@
+/*
+htop - dragonflybsd/DragonFlyBSDProcess.c
+(C) 2015 Hisham H. Muhammad
+(C) 2017 Diederik de Groot
+Released under the GNU GPL, see the COPYING file
+in the source distribution for its full text.
+*/
+
+#include "Process.h"
+#include "ProcessList.h"
+#include "DragonFlyBSDProcess.h"
+#include "Platform.h"
+#include "CRT.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+/*{
+
+typedef enum DragonFlyBSDProcessFields {
+   // Add platform-specific fields here, with ids >= 100
+   JID   = 100,
+   JAIL  = 101,
+   LAST_PROCESSFIELD = 102,
+} DragonFlyBSDProcessField;
+
+
+typedef struct DragonFlyBSDProcess_ {
+   Process super;
+   int   kernel;
+   int   jid;
+   char* jname;
+} DragonFlyBSDProcess;
+
+
+#ifndef Process_isKernelThread
+#define Process_isKernelThread(_process) (_process->kernel == 1)
+#endif
+
+#ifndef Process_isUserlandThread
+//#define Process_isUserlandThread(_process) (_process->pid != _process->tgid)
+#define Process_isUserlandThread(_process) (_process->nlwp > 1)
+#endif
+
+}*/
+
+ProcessClass DragonFlyBSDProcess_class = {
+   .super = {
+      .extends = Class(Process),
+      .display = Process_display,
+      .delete = Process_delete,
+      .compare = DragonFlyBSDProcess_compare
+   },
+   .writeField = (Process_WriteField) DragonFlyBSDProcess_writeField,
+};
+
+ProcessFieldData Process_fields[] = {
+   [0] = { .name = "", .title = NULL, .description = NULL, .flags = 0, },
+   [PID] = { .name = "PID", .title = "    PID ", .description = "Process/thread ID", .flags = 0, },
+   [COMM] = { .name = "Command", .title = "Command ", .description = "Command line", .flags = 0, },
+   [STATE] = { .name = "STATE", .title = "S ", .description = "Process state (S sleeping (<20s), I Idle, Q Queued for Run, R running, D disk, Z zombie, T traced, W paging, B Blocked, A AskedPage, C Core, J Jailed)", .flags = 0, },
+   [PPID] = { .name = "PPID", .title = "   PPID ", .description = "Parent process ID", .flags = 0, },
+   [PGRP] = { .name = "PGRP", .title = "   PGRP ", .description = "Process group ID", .flags = 0, },
+   [SESSION] = { .name = "SESSION", .title = "    SID ", .description = "Process's session ID", .flags = 0, },
+   [TTY_NR] = { .name = "TTY_NR", .title = "    TTY ", .description = "Controlling terminal", .flags = 0, },
+   [TPGID] = { .name = "TPGID", .title = "  TPGID ", .description = "Process ID of the fg process group of the controlling terminal", .flags = 0, },
+   [MINFLT] = { .name = "MINFLT", .title = "     MINFLT ", .description = "Number of minor faults which have not required loading a memory page from disk", .flags = 0, },
+   [MAJFLT] = { .name = "MAJFLT", .title = "     MAJFLT ", .description = "Number of major faults which have required loading a memory page from disk", .flags = 0, },
+   [PRIORITY] = { .name = "PRIORITY", .title = "PRI ", .description = "Kernel's internal priority for the process", .flags = 0, },
+   [NICE] = { .name = "NICE", .title = " NI ", .description = "Nice value (the higher the value, the more it lets other processes take priority)", .flags = 0, },
+   [STARTTIME] = { .name = "STARTTIME", .title = "START ", .description = "Time the process was started", .flags = 0, },
+   [PROCESSOR] = { .name = "PROCESSOR", .title = "CPU ", .description = "Id of the CPU the process last executed on", .flags = 0, },
+   [M_SIZE] = { .name = "M_SIZE", .title = " VIRT ", .description = "Total program size in virtual memory", .flags = 0, },
+   [M_RESIDENT] = { .name = "M_RESIDENT", .title = "  RES ", .description = "Resident set size, size of the text and data sections, plus stack usage", .flags = 0, },
+   [ST_UID] = { .name = "ST_UID", .title = " UID ", .description = "User ID of the process owner", .flags = 0, },
+   [PERCENT_CPU] = { .name = "PERCENT_CPU", .title = "CPU% ", .description = "Percentage of the CPU time the process used in the last sampling", .flags = 0, },
+   [PERCENT_MEM] = { .name = "PERCENT_MEM", .title = "MEM% ", .description = "Percentage of the memory the process is using, based on resident memory size", .flags = 0, },
+   [USER] = { .name = "USER", .title = "USER      ", .description = "Username of the process owner (or user ID if name cannot be determined)", .flags = 0, },
+   [TIME] = { .name = "TIME", .title = "  TIME+  ", .description = "Total time the process has spent in user and system time", .flags = 0, },
+   [NLWP] = { .name = "NLWP", .title = "NLWP ", .description = "Number of threads in the process", .flags = 0, },
+   [TGID] = { .name = "TGID", .title = "   TGID ", .description = "Thread group ID (i.e. process ID)", .flags = 0, },
+   [JID] = { .name = "JID", .title = "    JID ", .description = "Jail prison ID", .flags = 0, },
+   [JAIL] = { .name = "JAIL", .title = "JAIL        ", .description = "Jail prison name", .flags = 0, },
+   [LAST_PROCESSFIELD] = { .name = "*** report bug! ***", .title = NULL, .description = NULL, .flags = 0, },
+};
+
+ProcessPidColumn Process_pidColumns[] = {
+   { .id = JID, .label = "JID" },
+   { .id = PID, .label = "PID" },
+   { .id = PPID, .label = "PPID" },
+   { .id = TPGID, .label = "TPGID" },
+   { .id = TGID, .label = "TGID" },
+   { .id = PGRP, .label = "PGRP" },
+   { .id = SESSION, .label = "SID" },
+   { .id = 0, .label = NULL },
+};
+
+DragonFlyBSDProcess* DragonFlyBSDProcess_new(Settings* settings) {
+   DragonFlyBSDProcess* this = xCalloc(1, sizeof(DragonFlyBSDProcess));
+   Object_setClass(this, Class(DragonFlyBSDProcess));
+   Process_init(&this->super, settings);
+   return this;
+}
+
+void Process_delete(Object* cast) {
+   DragonFlyBSDProcess* this = (DragonFlyBSDProcess*) cast;
+   Process_done((Process*)cast);
+   free(this->jname);
+   free(this);
+}
+
+void DragonFlyBSDProcess_writeField(Process* this, RichString* str, ProcessField field) {
+   DragonFlyBSDProcess* fp = (DragonFlyBSDProcess*) this;
+   char buffer[256]; buffer[255] = '\0';
+   int attr = CRT_colors[DEFAULT_COLOR];
+   int n = sizeof(buffer) - 1;
+   switch ((int) field) {
+   // add Platform-specific fields here
+   case PID: snprintf(buffer, n, Process_pidFormat, (fp->kernel ? -1 : this->pid)); break;
+   case JID: snprintf(buffer, n, Process_pidFormat, fp->jid); break;
+   case JAIL:{
+      snprintf(buffer, n, "%-11s ", fp->jname); break;
+      if (buffer[11] != '\0') {
+         buffer[11] = ' ';
+         buffer[12] = '\0';
+      }
+      break;
+   }
+   default:
+      Process_writeField(this, str, field);
+      return;
+   }
+   RichString_append(str, attr, buffer);
+}
+
+long DragonFlyBSDProcess_compare(const void* v1, const void* v2) {
+   DragonFlyBSDProcess *p1, *p2;
+   Settings *settings = ((Process*)v1)->settings;
+   if (settings->direction == 1) {
+      p1 = (DragonFlyBSDProcess*)v1;
+      p2 = (DragonFlyBSDProcess*)v2;
+   } else {
+      p2 = (DragonFlyBSDProcess*)v1;
+      p1 = (DragonFlyBSDProcess*)v2;
+   }
+   switch ((int) settings->sortKey) {
+   // add Platform-specific fields here
+   case JID:
+      return (p1->jid - p2->jid);
+   case JAIL:
+      return strcmp(p1->jname ? p1->jname : "", p2->jname ? p2->jname : "");
+   default:
+      return Process_compare(v1, v2);
+   }
+}
+
+bool Process_isThread(Process* this) {
+   DragonFlyBSDProcess* fp = (DragonFlyBSDProcess*) this;
+
+   if (fp->kernel == 1 )
+      return 1;
+   else
+      return (Process_isUserlandThread(this));
+}
--- /dev/null
+++ dragonflybsd/DragonFlyBSDProcess.h
@@ -0,0 +1,56 @@
+/* Do not edit this file. It was automatically generated. */
+
+#ifndef HEADER_DragonFlyBSDProcess
+#define HEADER_DragonFlyBSDProcess
+/*
+htop - dragonflybsd/DragonFlyBSDProcess.h
+(C) 2015 Hisham H. Muhammad
+(C) 2017 Diederik de Groot
+Released under the GNU GPL, see the COPYING file
+in the source distribution for its full text.
+*/
+
+
+typedef enum DragonFlyBSDProcessFields {
+   // Add platform-specific fields here, with ids >= 100
+   JID   = 100,
+   JAIL  = 101,
+   LAST_PROCESSFIELD = 102,
+} DragonFlyBSDProcessField;
+
+
+typedef struct DragonFlyBSDProcess_ {
+   Process super;
+   int   kernel;
+   int   jid;
+   char* jname;
+} DragonFlyBSDProcess;
+
+
+#ifndef Process_isKernelThread
+#define Process_isKernelThread(_process) (_process->kernel == 1)
+#endif
+
+#ifndef Process_isUserlandThread
+//#define Process_isUserlandThread(_process) (_process->pid != _process->tgid)
+#define Process_isUserlandThread(_process) (_process->nlwp > 1)
+#endif
+
+
+extern ProcessClass DragonFlyBSDProcess_class;
+
+extern ProcessFieldData Process_fields[];
+
+extern ProcessPidColumn Process_pidColumns[];
+
+DragonFlyBSDProcess* DragonFlyBSDProcess_new(Settings* settings);
+
+void Process_delete(Object* cast);
+
+void DragonFlyBSDProcess_writeField(Process* this, RichString* str, ProcessField field);
+
+long DragonFlyBSDProcess_compare(const void* v1, const void* v2);
+
+bool Process_isThread(Process* this);
+
+#endif
--- /dev/null
+++ dragonflybsd/DragonFlyBSDProcessList.c
@@ -0,0 +1,578 @@
+/*
+htop - DragonFlyBSDProcessList.c
+(C) 2014 Hisham H. Muhammad
+(C) 2017 Diederik de Groot
+Released under the GNU GPL, see the COPYING file
+in the source distribution for its full text.
+*/
+
+#include "ProcessList.h"
+#include "DragonFlyBSDProcessList.h"
+#include "DragonFlyBSDProcess.h"
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include <err.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <string.h>
+#include <sys/param.h>
+
+/*{
+
+#include <kvm.h>
+#include <sys/param.h>
+#include <osreldate.h>
+#include <sys/kinfo.h>
+#include <kinfo.h>
+#include <sys/jail.h>
+#include <sys/uio.h>
+#include <sys/resource.h>
+#include "Hashtable.h"
+#include "DragonFlyBSDProcess.h"
+
+#define JAIL_ERRMSGLEN	1024
+char jail_errmsg[JAIL_ERRMSGLEN];
+
+typedef struct CPUData_ {
+
+   double userPercent;
+   double nicePercent;
+   double systemPercent;
+   double irqPercent;
+   double idlePercent;
+   double systemAllPercent;
+
+} CPUData;
+
+typedef struct DragonFlyBSDProcessList_ {
+   ProcessList super;
+   kvm_t* kd;
+
+   unsigned long long int memWire;
+   unsigned long long int memActive;
+   unsigned long long int memInactive;
+   unsigned long long int memFree;
+
+   CPUData* cpus;
+
+   unsigned long   *cp_time_o;
+   unsigned long   *cp_time_n;
+
+   unsigned long  *cp_times_o;
+   unsigned long  *cp_times_n;
+
+   Hashtable *jails;
+} DragonFlyBSDProcessList;
+
+}*/
+
+#define _UNUSED_ __attribute__((unused))
+
+static int MIB_hw_physmem[2];
+static int MIB_vm_stats_vm_v_page_count[4];
+static int pageSize;
+static int pageSizeKb;
+
+static int MIB_vm_stats_vm_v_wire_count[4];
+static int MIB_vm_stats_vm_v_active_count[4];
+static int MIB_vm_stats_vm_v_cache_count[4];
+static int MIB_vm_stats_vm_v_inactive_count[4];
+static int MIB_vm_stats_vm_v_free_count[4];
+
+static int MIB_vfs_bufspace[2];
+
+static int MIB_kern_cp_time[2];
+static int MIB_kern_cp_times[2];
+static int kernelFScale;
+
+ProcessList* ProcessList_new(UsersTable* usersTable, Hashtable* pidWhiteList, uid_t userId) {
+   size_t len;
+   char errbuf[_POSIX2_LINE_MAX];
+   DragonFlyBSDProcessList* dfpl = xCalloc(1, sizeof(DragonFlyBSDProcessList));
+   ProcessList* pl = (ProcessList*) dfpl;
+   ProcessList_init(pl, Class(DragonFlyBSDProcess), usersTable, pidWhiteList, userId);
+
+   // physical memory in system: hw.physmem
+   // physical page size: hw.pagesize
+   // usable pagesize : vm.stats.vm.v_page_size
+   len = 2; sysctlnametomib("hw.physmem", MIB_hw_physmem, &len);
+
+   len = sizeof(pageSize);
+   if (sysctlbyname("vm.stats.vm.v_page_size", &pageSize, &len, NULL, 0) == -1) {
+      pageSize = PAGE_SIZE;
+      pageSizeKb = PAGE_SIZE_KB;
+   } else {
+      pageSizeKb = pageSize / ONE_K;
+   }
+
+   // usable page count vm.stats.vm.v_page_count
+   // actually usable memory : vm.stats.vm.v_page_count * vm.stats.vm.v_page_size
+   len = 4; sysctlnametomib("vm.stats.vm.v_page_count", MIB_vm_stats_vm_v_page_count, &len);
+
+   len = 4; sysctlnametomib("vm.stats.vm.v_wire_count", MIB_vm_stats_vm_v_wire_count, &len);
+   len = 4; sysctlnametomib("vm.stats.vm.v_active_count", MIB_vm_stats_vm_v_active_count, &len);
+   len = 4; sysctlnametomib("vm.stats.vm.v_cache_count", MIB_vm_stats_vm_v_cache_count, &len);
+   len = 4; sysctlnametomib("vm.stats.vm.v_inactive_count", MIB_vm_stats_vm_v_inactive_count, &len);
+   len = 4; sysctlnametomib("vm.stats.vm.v_free_count", MIB_vm_stats_vm_v_free_count, &len);
+
+   len = 2; sysctlnametomib("vfs.bufspace", MIB_vfs_bufspace, &len);
+
+   int cpus = 1;
+   len = sizeof(cpus);
+   if (sysctlbyname("hw.ncpu", &cpus, &len, NULL, 0) != 0) {
+      cpus = 1;
+   }
+
+   size_t sizeof_cp_time_array = sizeof(unsigned long) * CPUSTATES;
+   len = 2; sysctlnametomib("kern.cp_time", MIB_kern_cp_time, &len);
+   dfpl->cp_time_o = xCalloc(cpus, sizeof_cp_time_array);
+   dfpl->cp_time_n = xCalloc(cpus, sizeof_cp_time_array);
+   len = sizeof_cp_time_array;
+
+   // fetch initial single (or average) CPU clicks from kernel
+   sysctl(MIB_kern_cp_time, 2, dfpl->cp_time_o, &len, NULL, 0);
+
+   // on smp box, fetch rest of initial CPU's clicks
+   if (cpus > 1) {
+      len = 2; sysctlnametomib("kern.cp_times", MIB_kern_cp_times, &len);
+      dfpl->cp_times_o = xCalloc(cpus, sizeof_cp_time_array);
+      dfpl->cp_times_n = xCalloc(cpus, sizeof_cp_time_array);
+      len = cpus * sizeof_cp_time_array;
+      sysctl(MIB_kern_cp_times, 2, dfpl->cp_times_o, &len, NULL, 0);
+   }
+
+   pl->cpuCount = MAX(cpus, 1);
+
+   if (cpus == 1 ) {
+     dfpl->cpus = xRealloc(dfpl->cpus, sizeof(CPUData));
+   } else {
+     // on smp we need CPUs + 1 to store averages too (as kernel kindly provides that as well)
+     dfpl->cpus = xRealloc(dfpl->cpus, (pl->cpuCount + 1) * sizeof(CPUData));
+   }
+
+   len = sizeof(kernelFScale);
+   if (sysctlbyname("kern.fscale", &kernelFScale, &len, NULL, 0) == -1) {
+      //sane default for kernel provided CPU percentage scaling, at least on x86 machines, in case this sysctl call failed
+      kernelFScale = 2048;
+   }
+
+   dfpl->kd = kvm_openfiles(NULL, "/dev/null", NULL, 0, errbuf);
+   if (dfpl->kd == NULL) {
+      errx(1, "kvm_open: %s", errbuf);
+   }
+
+   return pl;
+}
+
+void ProcessList_delete(ProcessList* this) {
+   const DragonFlyBSDProcessList* dfpl = (DragonFlyBSDProcessList*) this;
+   if (dfpl->kd) kvm_close(dfpl->kd);
+
+   if (dfpl->jails) {
+      Hashtable_delete(dfpl->jails);
+   }
+   free(dfpl->cp_time_o);
+   free(dfpl->cp_time_n);
+   free(dfpl->cp_times_o);
+   free(dfpl->cp_times_n);
+   free(dfpl->cpus);
+
+   ProcessList_done(this);
+   free(this);
+}
+
+static inline void DragonFlyBSDProcessList_scanCPUTime(ProcessList* pl) {
+   const DragonFlyBSDProcessList* dfpl = (DragonFlyBSDProcessList*) pl;
+
+   int cpus   = pl->cpuCount;   // actual CPU count
+   int maxcpu = cpus;           // max iteration (in case we have average + smp)
+   int cp_times_offset;
+
+   assert(cpus > 0);
+
+   size_t sizeof_cp_time_array;
+
+   unsigned long     *cp_time_n; // old clicks state
+   unsigned long     *cp_time_o; // current clicks state
+
+   unsigned long cp_time_d[CPUSTATES];
+   double        cp_time_p[CPUSTATES];
+
+   // get averages or single CPU clicks
+   sizeof_cp_time_array = sizeof(unsigned long) * CPUSTATES;
+   sysctl(MIB_kern_cp_time, 2, dfpl->cp_time_n, &sizeof_cp_time_array, NULL, 0);
+
+   // get rest of CPUs
+   if (cpus > 1) {
+       // on smp systems DragonFlyBSD kernel concats all CPU states into one long array in
+       // kern.cp_times sysctl OID
+       // we store averages in dfpl->cpus[0], and actual cores after that
+       maxcpu = cpus + 1;
+       sizeof_cp_time_array = cpus * sizeof(unsigned long) * CPUSTATES;
+       sysctl(MIB_kern_cp_times, 2, dfpl->cp_times_n, &sizeof_cp_time_array, NULL, 0);
+   }
+
+   for (int i = 0; i < maxcpu; i++) {
+      if (cpus == 1) {
+         // single CPU box
+         cp_time_n = dfpl->cp_time_n;
+         cp_time_o = dfpl->cp_time_o;
+      } else {
+         if (i == 0 ) {
+           // average
+           cp_time_n = dfpl->cp_time_n;
+           cp_time_o = dfpl->cp_time_o;
+         } else {
+           // specific smp cores
+           cp_times_offset = i - 1;
+           cp_time_n = dfpl->cp_times_n + (cp_times_offset * CPUSTATES);
+           cp_time_o = dfpl->cp_times_o + (cp_times_offset * CPUSTATES);
+         }
+      }
+
+      // diff old vs new
+      unsigned long long total_o = 0;
+      unsigned long long total_n = 0;
+      unsigned long long total_d = 0;
+      for (int s = 0; s < CPUSTATES; s++) {
+        cp_time_d[s] = cp_time_n[s] - cp_time_o[s];
+        total_o += cp_time_o[s];
+        total_n += cp_time_n[s];
+      }
+
+      // totals
+      total_d = total_n - total_o;
+      if (total_d < 1 ) total_d = 1;
+
+      // save current state as old and calc percentages
+      for (int s = 0; s < CPUSTATES; ++s) {
+        cp_time_o[s] = cp_time_n[s];
+        cp_time_p[s] = ((double)cp_time_d[s]) / ((double)total_d) * 100;
+      }
+
+      CPUData* cpuData = &(dfpl->cpus[i]);
+      cpuData->userPercent      = cp_time_p[CP_USER];
+      cpuData->nicePercent      = cp_time_p[CP_NICE];
+      cpuData->systemPercent    = cp_time_p[CP_SYS];
+      cpuData->irqPercent       = cp_time_p[CP_INTR];
+      cpuData->systemAllPercent = cp_time_p[CP_SYS] + cp_time_p[CP_INTR];
+      // this one is not really used, but we store it anyway
+      cpuData->idlePercent      = cp_time_p[CP_IDLE];
+   }
+}
+
+static inline void DragonFlyBSDProcessList_scanMemoryInfo(ProcessList* pl) {
+   DragonFlyBSDProcessList* dfpl = (DragonFlyBSDProcessList*) pl;
+
+   // @etosan:
+   // memory counter relationships seem to be these:
+   //  total = active + wired + inactive + cache + free
+   //  htop_used (unavail to anybody) = active + wired
+   //  htop_cache (for cache meter)   = buffers + cache
+   //  user_free (avail to procs)     = buffers + inactive + cache + free
+   size_t len = sizeof(pl->totalMem);
+
+   //disabled for now, as it is always smaller than phycal amount of memory...
+   //...to avoid "where is my memory?" questions
+   //sysctl(MIB_vm_stats_vm_v_page_count, 4, &(pl->totalMem), &len, NULL, 0);
+   //pl->totalMem *= pageSizeKb;
+   sysctl(MIB_hw_physmem, 2, &(pl->totalMem), &len, NULL, 0);
+   pl->totalMem /= 1024;
+
+   sysctl(MIB_vm_stats_vm_v_active_count, 4, &(dfpl->memActive), &len, NULL, 0);
+   dfpl->memActive *= pageSizeKb;
+
+   sysctl(MIB_vm_stats_vm_v_wire_count, 4, &(dfpl->memWire), &len, NULL, 0);
+   dfpl->memWire *= pageSizeKb;
+
+   sysctl(MIB_vfs_bufspace, 2, &(pl->buffersMem), &len, NULL, 0);
+   pl->buffersMem /= 1024;
+
+   sysctl(MIB_vm_stats_vm_v_cache_count, 4, &(pl->cachedMem), &len, NULL, 0);
+   pl->cachedMem *= pageSizeKb;
+   pl->usedMem = dfpl->memActive + dfpl->memWire;
+
+   //currently unused, same as with arc, custom meter perhaps
+   //sysctl(MIB_vm_stats_vm_v_inactive_count, 4, &(dfpl->memInactive), &len, NULL, 0);
+   //sysctl(MIB_vm_stats_vm_v_free_count, 4, &(dfpl->memFree), &len, NULL, 0);
+   //pl->freeMem  = dfpl->memInactive + dfpl->memFree;
+   //pl->freeMem *= pageSizeKb;
+
+   struct kvm_swap swap[16];
+   int nswap = kvm_getswapinfo(dfpl->kd, swap, sizeof(swap)/sizeof(swap[0]), 0);
+   pl->totalSwap = 0;
+   pl->usedSwap = 0;
+   for (int i = 0; i < nswap; i++) {
+      pl->totalSwap += swap[i].ksw_total;
+      pl->usedSwap += swap[i].ksw_used;
+   }
+   pl->totalSwap *= pageSizeKb;
+   pl->usedSwap *= pageSizeKb;
+
+   pl->sharedMem = 0;  // currently unused
+}
+
+char* DragonFlyBSDProcessList_readProcessName(kvm_t* kd, struct kinfo_proc* kproc, int* basenameEnd) {
+   char** argv = kvm_getargv(kd, kproc, 0);
+   if (!argv) {
+      return xStrdup(kproc->kp_comm);
+   }
+   int len = 0;
+   for (int i = 0; argv[i]; i++) {
+      len += strlen(argv[i]) + 1;
+   }
+   char* comm = xMalloc(len);
+   char* at = comm;
+   *basenameEnd = 0;
+   for (int i = 0; argv[i]; i++) {
+      at = stpcpy(at, argv[i]);
+      if (!*basenameEnd) {
+         *basenameEnd = at - comm;
+      }
+      *at = ' ';
+      at++;
+   }
+   at--;
+   *at = '\0';
+   return comm;
+}
+
+static inline void DragonFlyBSDProcessList_scanJails(DragonFlyBSDProcessList* dfpl) {
+   size_t len;
+   char *jls; /* Jail list */
+   char *curpos;
+   char *nextpos;
+
+   if (sysctlbyname("jail.list", NULL, &len, NULL, 0) == -1) {
+      fprintf(stderr, "initial sysctlbyname / jail.list failed\n");
+      exit(3);
+   }
+retry:
+   if (len == 0)
+      return;
+
+   jls = xMalloc(len);
+   if (jls == NULL) {
+      fprintf(stderr, "xMalloc failed\n");
+      exit(4);
+   }
+   if (sysctlbyname("jail.list", jls, &len, NULL, 0) == -1) {
+      if (errno == ENOMEM) {
+         free(jls);
+         goto retry;
+      }
+      fprintf(stderr, "sysctlbyname / jail.list failed\n");
+      exit(5);
+   }
+
+   if (dfpl->jails) {
+      Hashtable_delete(dfpl->jails);
+   }
+   dfpl->jails = Hashtable_new(20, true);
+   curpos = jls;
+   while (curpos) {
+      int jailid;
+      char *str_hostname;
+      nextpos = strchr(curpos, '\n');
+      if (nextpos)
+         *nextpos++ = 0;
+
+      jailid = atoi(strtok(curpos, " "));
+      str_hostname = strtok(NULL, " ");
+
+      char *jname = (char *) (Hashtable_get(dfpl->jails, jailid));
+      if (jname == NULL) {
+         jname = xStrdup(str_hostname);
+         Hashtable_put(dfpl->jails, jailid, jname);
+      }
+
+      curpos = nextpos;
+  }
+  free(jls);
+}
+
+char* DragonFlyBSDProcessList_readJailName(DragonFlyBSDProcessList* dfpl, int jailid) {
+   char*  hostname;
+   char*  jname;
+
+   if (jailid != 0 && dfpl->jails && (hostname = (char *)Hashtable_get(dfpl->jails, jailid))) {
+      jname = xStrdup(hostname);
+   } else {
+      jname = xStrdup("-");
+   }
+   return jname;
+}
+
+void ProcessList_goThroughEntries(ProcessList* this) {
+   DragonFlyBSDProcessList* dfpl = (DragonFlyBSDProcessList*) this;
+   Settings* settings = this->settings;
+   bool hideKernelThreads = settings->hideKernelThreads;
+   bool hideUserlandThreads = settings->hideUserlandThreads;
+
+   DragonFlyBSDProcessList_scanMemoryInfo(this);
+   DragonFlyBSDProcessList_scanCPUTime(this);
+   DragonFlyBSDProcessList_scanJails(dfpl);
+
+   int count = 0;
+
+   // TODO Kernel Threads seem to be skipped, need to figure out the correct flag
+   struct kinfo_proc* kprocs = kvm_getprocs(dfpl->kd, KERN_PROC_ALL | (!hideUserlandThreads ? KERN_PROC_FLAG_LWP : 0), 0, &count);
+
+   for (int i = 0; i < count; i++) {
+      struct kinfo_proc* kproc = &kprocs[i];
+      bool preExisting = false;
+      bool _UNUSED_ isIdleProcess = false;
+
+      // note: dragonflybsd kernel processes all have the same pid, so we misuse the kernel thread address to give them a unique identifier
+      Process* proc = ProcessList_getProcess(this, kproc->kp_ktaddr ? (pid_t)kproc->kp_ktaddr : kproc->kp_pid, &preExisting, (Process_New) DragonFlyBSDProcess_new);
+      DragonFlyBSDProcess* dfp = (DragonFlyBSDProcess*) proc;
+
+      proc->show = ! ((hideKernelThreads && Process_isKernelThread(dfp)) || (hideUserlandThreads && Process_isUserlandThread(proc)));
+
+      if (!preExisting) {
+         dfp->jid = kproc->kp_jailid;
+         if (kproc->kp_ktaddr && kproc->kp_flags & P_SYSTEM) {
+            // dfb kernel threads all have the same pid, so we misuse the kernel thread address to give them a unique identifier
+            proc->pid = (pid_t)kproc->kp_ktaddr;
+            dfp->kernel = 1;
+         } else {
+            proc->pid = kproc->kp_pid;		// process ID
+            dfp->kernel = 0;
+         }
+         proc->ppid = kproc->kp_ppid;		// parent process id
+         proc->tpgid = kproc->kp_tpgid;		// tty process group id
+         //proc->tgid = kproc->kp_lwp.kl_tid;	// thread group id
+         proc->tgid = kproc->kp_pid;		// thread group id
+         proc->pgrp = kproc->kp_pgid;		// process group id
+         proc->session = kproc->kp_sid;
+         proc->tty_nr = kproc->kp_tdev;		// control terminal device number
+         proc->st_uid = kproc->kp_uid;		// user ID
+         proc->processor = kproc->kp_lwp.kl_origcpu;
+         proc->starttime_ctime = kproc->kp_start.tv_sec;
+         proc->user = UsersTable_getRef(this->usersTable, proc->st_uid);
+
+         ProcessList_add((ProcessList*)this, proc);
+         proc->comm = DragonFlyBSDProcessList_readProcessName(dfpl->kd, kproc, &proc->basenameOffset);
+         dfp->jname = DragonFlyBSDProcessList_readJailName(dfpl, kproc->kp_jailid);
+      } else {
+         proc->processor = kproc->kp_lwp.kl_cpuid;
+         if(dfp->jid != kproc->kp_jailid) {	// process can enter jail anytime
+            dfp->jid = kproc->kp_jailid;
+            free(dfp->jname);
+            dfp->jname = DragonFlyBSDProcessList_readJailName(dfpl, kproc->kp_jailid);
+         }
+         if (proc->ppid != kproc->kp_ppid) {	// if there are reapers in the system, process can get reparented anytime
+            proc->ppid = kproc->kp_ppid;
+         }
+         if(proc->st_uid != kproc->kp_uid) {	// some processes change users (eg. to lower privs)
+            proc->st_uid = kproc->kp_uid;
+            proc->user = UsersTable_getRef(this->usersTable, proc->st_uid);
+         }
+         if (settings->updateProcessNames) {
+            free(proc->comm);
+            proc->comm = DragonFlyBSDProcessList_readProcessName(dfpl->kd, kproc, &proc->basenameOffset);
+         }
+      }
+
+      proc->m_size = kproc->kp_vm_map_size / 1024 / pageSizeKb;
+      proc->m_resident = kproc->kp_vm_rssize;
+      proc->percent_mem = (proc->m_resident * PAGE_SIZE_KB) / (double)(this->totalMem) * 100.0;
+      proc->nlwp = kproc->kp_nthreads;		// number of lwp thread
+      proc->time = (kproc->kp_swtime + 5000) / 10000;
+
+      proc->percent_cpu = 100.0 * ((double)kproc->kp_lwp.kl_pctcpu / (double)kernelFScale);
+      proc->percent_mem = 100.0 * (proc->m_resident * PAGE_SIZE_KB) / (double)(this->totalMem);
+
+      if (proc->percent_cpu > 0.1) {
+         // system idle process should own all CPU time left regardless of CPU count
+         if ( strcmp("idle", kproc->kp_comm) == 0 ) {
+            isIdleProcess = true;
+         }
+      }
+
+      if (kproc->kp_lwp.kl_pid != -1)
+         proc->priority = kproc->kp_lwp.kl_prio;
+      else
+         proc->priority = -kproc->kp_lwp.kl_tdprio;
+
+      switch(kproc->kp_lwp.kl_rtprio.type) {
+        case RTP_PRIO_REALTIME:
+                proc->nice = PRIO_MIN - 1 - RTP_PRIO_MAX + kproc->kp_lwp.kl_rtprio.prio;
+                break;
+        case RTP_PRIO_IDLE:
+                proc->nice = PRIO_MAX + 1 + kproc->kp_lwp.kl_rtprio.prio;
+                break;
+        case RTP_PRIO_THREAD:
+                proc->nice = PRIO_MIN - 1 - RTP_PRIO_MAX - kproc->kp_lwp.kl_rtprio.prio;
+                break;
+        default:
+                proc->nice = kproc->kp_nice;
+                break;
+      }
+
+      // would be nice if we could store multiple states in proc->state (as enum) and have writeField render them
+      switch (kproc->kp_stat) {
+      case SIDL:   proc->state = 'I'; isIdleProcess = true; break;
+      case SACTIVE:
+         switch (kproc->kp_lwp.kl_stat) {
+            case LSSLEEP:
+               if (kproc->kp_lwp.kl_flags & LWP_SINTR)					// interruptable wait short/long
+                  if (kproc->kp_lwp.kl_slptime >= MAXSLP) {
+                     proc->state = 'I';
+                     isIdleProcess = true;
+                  } else {
+                     proc->state = 'S';
+                  }
+               else if (kproc->kp_lwp.kl_tdflags & TDF_SINTR)				// interruptable lwkt wait
+                  proc->state = 'S';
+               else if (kproc->kp_paddr)						// uninterruptable wait
+                  proc->state = 'D';
+               else									// uninterruptable lwkt wait
+                  proc->state = 'B';
+               break;
+            case LSRUN:
+               if (kproc->kp_lwp.kl_stat == LSRUN) {
+                  if (!(kproc->kp_lwp.kl_tdflags & (TDF_RUNNING | TDF_RUNQ)))
+                     proc->state = 'Q';
+                  else
+                     proc->state = 'R';
+               }
+               break;
+            case LSSTOP:
+               proc->state = 'T';
+               break;
+            default:
+               proc->state = 'A';
+               break;
+         }
+         break;
+      case SSTOP:  proc->state = 'T'; break;
+      case SZOMB:  proc->state = 'Z'; break;
+      case SCORE:  proc->state = 'C'; break;
+      default:     proc->state = '?';
+      }
+
+      if (kproc->kp_flags & P_SWAPPEDOUT) {
+         proc->state = 'W';
+      }
+      if (kproc->kp_flags & P_TRACED) {
+         proc->state = 'T';
+      }
+      if (kproc->kp_flags & P_JAILED) {
+         proc->state = 'J';
+      }
+      
+      if (Process_isKernelThread(dfp)) {
+         this->kernelThreads++;
+      }
+
+      this->totalTasks++;
+      if (proc->state == 'R')
+         this->runningTasks++;
+      proc->updated = true;
+   }
+}
--- /dev/null
+++ dragonflybsd/DragonFlyBSDProcessList.h
@@ -0,0 +1,73 @@
+/* Do not edit this file. It was automatically generated. */
+
+#ifndef HEADER_DragonFlyBSDProcessList
+#define HEADER_DragonFlyBSDProcessList
+/*
+htop - DragonFlyBSDProcessList.h
+(C) 2014 Hisham H. Muhammad
+(C) 2017 Diederik de Groot
+Released under the GNU GPL, see the COPYING file
+in the source distribution for its full text.
+*/
+
+
+#include <kvm.h>
+#include <sys/param.h>
+#include <osreldate.h>
+#include <sys/kinfo.h>
+#include <kinfo.h>
+#include <sys/jail.h>
+#include <sys/uio.h>
+#include <sys/resource.h>
+#include "Hashtable.h"
+#include "DragonFlyBSDProcess.h"
+
+#define JAIL_ERRMSGLEN	1024
+char jail_errmsg[JAIL_ERRMSGLEN];
+
+typedef struct CPUData_ {
+
+   double userPercent;
+   double nicePercent;
+   double systemPercent;
+   double irqPercent;
+   double idlePercent;
+   double systemAllPercent;
+
+} CPUData;
+
+typedef struct DragonFlyBSDProcessList_ {
+   ProcessList super;
+   kvm_t* kd;
+
+   unsigned long long int memWire;
+   unsigned long long int memActive;
+   unsigned long long int memInactive;
+   unsigned long long int memFree;
+
+   CPUData* cpus;
+
+   unsigned long   *cp_time_o;
+   unsigned long   *cp_time_n;
+
+   unsigned long  *cp_times_o;
+   unsigned long  *cp_times_n;
+
+   Hashtable *jails;
+} DragonFlyBSDProcessList;
+
+
+#define _UNUSED_ __attribute__((unused))
+
+
+ProcessList* ProcessList_new(UsersTable* usersTable, Hashtable* pidWhiteList, uid_t userId);
+
+void ProcessList_delete(ProcessList* this);
+
+char* DragonFlyBSDProcessList_readProcessName(kvm_t* kd, struct kinfo_proc* kproc, int* basenameEnd);
+
+char* DragonFlyBSDProcessList_readJailName(DragonFlyBSDProcessList* dfpl, int jailid);
+
+void ProcessList_goThroughEntries(ProcessList* this);
+
+#endif
--- /dev/null
+++ dragonflybsd/Platform.c
@@ -0,0 +1,210 @@
+/*
+htop - dragonflybsd/Platform.c
+(C) 2014 Hisham H. Muhammad
+(C) 2017 Diederik de Groot
+Released under the GNU GPL, see the COPYING file
+in the source distribution for its full text.
+*/
+
+#include "Platform.h"
+#include "Meter.h"
+#include "CPUMeter.h"
+#include "MemoryMeter.h"
+#include "SwapMeter.h"
+#include "TasksMeter.h"
+#include "LoadAverageMeter.h"
+#include "UptimeMeter.h"
+#include "ClockMeter.h"
+#include "HostnameMeter.h"
+#include "DragonFlyBSDProcess.h"
+#include "DragonFlyBSDProcessList.h"
+
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <vm/vm_param.h>
+#include <time.h>
+#include <math.h>
+
+/*{
+#include "Action.h"
+#include "BatteryMeter.h"
+#include "SignalsPanel.h"
+
+extern ProcessFieldData Process_fields[];
+
+}*/
+
+#ifndef CLAMP
+#define CLAMP(x,low,high) (((x)>(high))?(high):(((x)<(low))?(low):(x)))
+#endif
+
+ProcessField Platform_defaultFields[] = { PID, USER, PRIORITY, NICE, M_SIZE, M_RESIDENT, STATE, PERCENT_CPU, PERCENT_MEM, TIME, COMM, 0 };
+
+int Platform_numberOfFields = LAST_PROCESSFIELD;
+
+const SignalItem Platform_signals[] = {
+   { .name = " 0 Cancel",    .number =  0 },
+   { .name = " 1 SIGHUP",    .number =  1 },
+   { .name = " 2 SIGINT",    .number =  2 },
+   { .name = " 3 SIGQUIT",   .number =  3 },
+   { .name = " 4 SIGILL",    .number =  4 },
+   { .name = " 5 SIGTRAP",   .number =  5 },
+   { .name = " 6 SIGABRT",   .number =  6 },
+   { .name = " 7 SIGEMT",    .number =  7 },
+   { .name = " 8 SIGFPE",    .number =  8 },
+   { .name = " 9 SIGKILL",   .number =  9 },
+   { .name = "10 SIGBUS",    .number = 10 },
+   { .name = "11 SIGSEGV",   .number = 11 },
+   { .name = "12 SIGSYS",    .number = 12 },
+   { .name = "13 SIGPIPE",   .number = 13 },
+   { .name = "14 SIGALRM",   .number = 14 },
+   { .name = "15 SIGTERM",   .number = 15 },
+   { .name = "16 SIGURG",    .number = 16 },
+   { .name = "17 SIGSTOP",   .number = 17 },
+   { .name = "18 SIGTSTP",   .number = 18 },
+   { .name = "19 SIGCONT",   .number = 19 },
+   { .name = "20 SIGCHLD",   .number = 20 },
+   { .name = "21 SIGTTIN",   .number = 21 },
+   { .name = "22 SIGTTOU",   .number = 22 },
+   { .name = "23 SIGIO",     .number = 23 },
+   { .name = "24 SIGXCPU",   .number = 24 },
+   { .name = "25 SIGXFSZ",   .number = 25 },
+   { .name = "26 SIGVTALRM", .number = 26 },
+   { .name = "27 SIGPROF",   .number = 27 },
+   { .name = "28 SIGWINCH",  .number = 28 },
+   { .name = "29 SIGINFO",   .number = 29 },
+   { .name = "30 SIGUSR1",   .number = 30 },
+   { .name = "31 SIGUSR2",   .number = 31 },
+   { .name = "32 SIGTHR",    .number = 32 },
+   { .name = "33 SIGLIBRT",  .number = 33 },
+};
+
+const unsigned int Platform_numberOfSignals = sizeof(Platform_signals)/sizeof(SignalItem);
+
+void Platform_setBindings(Htop_Action* keys) {
+   (void) keys;
+}
+
+MeterClass* Platform_meterTypes[] = {
+   &CPUMeter_class,
+   &ClockMeter_class,
+   &LoadAverageMeter_class,
+   &LoadMeter_class,
+   &MemoryMeter_class,
+   &SwapMeter_class,
+   &TasksMeter_class,
+   &UptimeMeter_class,
+   &BatteryMeter_class,
+   &HostnameMeter_class,
+   &AllCPUsMeter_class,
+   &AllCPUs2Meter_class,
+   &LeftCPUsMeter_class,
+   &RightCPUsMeter_class,
+   &LeftCPUs2Meter_class,
+   &RightCPUs2Meter_class,
+   &BlankMeter_class,
+   NULL
+};
+
+int Platform_getUptime() {
+   struct timeval bootTime, currTime;
+   int mib[2] = { CTL_KERN, KERN_BOOTTIME };
+   size_t size = sizeof(bootTime);
+
+   int err = sysctl(mib, 2, &bootTime, &size, NULL, 0);
+   if (err) {
+      return -1;
+   }
+   gettimeofday(&currTime, NULL);
+
+   return (int) difftime(currTime.tv_sec, bootTime.tv_sec);
+}
+
+void Platform_getLoadAverage(double* one, double* five, double* fifteen) {
+   struct loadavg loadAverage;
+   int mib[2] = { CTL_VM, VM_LOADAVG };
+   size_t size = sizeof(loadAverage);
+
+   int err = sysctl(mib, 2, &loadAverage, &size, NULL, 0);
+   if (err) {
+      *one = 0;
+      *five = 0;
+      *fifteen = 0;
+      return;
+   }
+   *one     = (double) loadAverage.ldavg[0] / loadAverage.fscale;
+   *five    = (double) loadAverage.ldavg[1] / loadAverage.fscale;
+   *fifteen = (double) loadAverage.ldavg[2] / loadAverage.fscale;
+}
+
+int Platform_getMaxPid() {
+   int maxPid;
+   size_t size = sizeof(maxPid);
+   int err = sysctlbyname("kern.pid_max", &maxPid, &size, NULL, 0);
+   if (err) {
+      return 99999;
+   }
+   return maxPid;
+}
+
+double Platform_setCPUValues(Meter* this, int cpu) {
+   DragonFlyBSDProcessList* fpl = (DragonFlyBSDProcessList*) this->pl;
+   int cpus = this->pl->cpuCount;
+   CPUData* cpuData;
+
+   if (cpus == 1) {
+     // single CPU box has everything in fpl->cpus[0]
+     cpuData = &(fpl->cpus[0]);
+   } else {
+     cpuData = &(fpl->cpus[cpu]);
+   }
+
+   double  percent;
+   double* v = this->values;
+
+   v[CPU_METER_NICE]   = cpuData->nicePercent;
+   v[CPU_METER_NORMAL] = cpuData->userPercent;
+   if (this->pl->settings->detailedCPUTime) {
+      v[CPU_METER_KERNEL]  = cpuData->systemPercent;
+      v[CPU_METER_IRQ]     = cpuData->irqPercent;
+      Meter_setItems(this, 4);
+      percent = v[0]+v[1]+v[2]+v[3];
+   } else {
+      v[2] = cpuData->systemAllPercent;
+      Meter_setItems(this, 3);
+      percent = v[0]+v[1]+v[2];
+   }
+
+   percent = CLAMP(percent, 0.0, 100.0);
+   if (isnan(percent)) percent = 0.0;
+   return percent;
+}
+
+void Platform_setMemoryValues(Meter* this) {
+   // TODO
+   ProcessList* pl = (ProcessList*) this->pl;
+
+   this->total = pl->totalMem;
+   this->values[0] = pl->usedMem;
+   this->values[1] = pl->buffersMem;
+   this->values[2] = pl->cachedMem;
+}
+
+void Platform_setSwapValues(Meter* this) {
+   ProcessList* pl = (ProcessList*) this->pl;
+   this->total = pl->totalSwap;
+   this->values[0] = pl->usedSwap;
+}
+
+void Platform_setTasksValues(Meter* this) {
+   // TODO
+   (void)this;	// prevent unused warning
+}
+
+char* Platform_getProcessEnv(pid_t pid) {
+   // TODO
+   (void)pid;	// prevent unused warning
+   return NULL;
+}
--- /dev/null
+++ dragonflybsd/Platform.h
@@ -0,0 +1,52 @@
+/* Do not edit this file. It was automatically generated. */
+
+#ifndef HEADER_Platform
+#define HEADER_Platform
+/*
+htop - dragonflybsd/Platform.h
+(C) 2014 Hisham H. Muhammad
+(C) 2017 Diederik de Groot
+Released under the GNU GPL, see the COPYING file
+in the source distribution for its full text.
+*/
+
+#include "Action.h"
+#include "BatteryMeter.h"
+#include "SignalsPanel.h"
+
+extern ProcessFieldData Process_fields[];
+
+
+#ifndef CLAMP
+#define CLAMP(x,low,high) (((x)>(high))?(high):(((x)<(low))?(low):(x)))
+#endif
+
+extern ProcessField Platform_defaultFields[];
+
+extern int Platform_numberOfFields;
+
+extern const SignalItem Platform_signals[];
+
+extern const unsigned int Platform_numberOfSignals;
+
+void Platform_setBindings(Htop_Action* keys);
+
+extern MeterClass* Platform_meterTypes[];
+
+int Platform_getUptime();
+
+void Platform_getLoadAverage(double* one, double* five, double* fifteen);
+
+int Platform_getMaxPid();
+
+double Platform_setCPUValues(Meter* this, int cpu);
+
+void Platform_setMemoryValues(Meter* this);
+
+void Platform_setSwapValues(Meter* this);
+
+void Platform_setTasksValues(Meter* this);
+
+char* Platform_getProcessEnv(pid_t pid);
+
+#endif
