diff --git BUILD.gn BUILD.gn
index 378aa8822b..3a286b61af 100644
--- BUILD.gn
+++ BUILD.gn
@@ -370,7 +370,7 @@ group("gn_all") {
         [ "//third_party/android_crazy_linker:android_crazy_linker_zip_fuzzer" ]
   }
 
-  if (is_linux || is_android) {
+  if ((is_linux && !is_bsd) || is_android) {
     deps += [
       "//third_party/breakpad:breakpad_unittests",
       "//third_party/breakpad:core-2-minidump",
@@ -411,8 +411,6 @@ group("gn_all") {
       "//net:disk_cache_memory_test",
       "//net:quic_client",
       "//net:quic_server",
-      "//sandbox/linux:chrome_sandbox",
-      "//sandbox/linux:sandbox_linux_unittests",
       "//testing:empty_main",
     ]
 
@@ -469,10 +467,6 @@ group("gn_all") {
         "//chrome/test/chromedriver:chromedriver",
         "//chrome/test/chromedriver:chromedriver_tests",
         "//components/sync:run_sync_testserver",
-        "//courgette:courgette",
-        "//courgette:courgette_fuzz",
-        "//courgette:courgette_minimal_tool",
-        "//courgette:courgette_unittests",
         "//media/cast:generate_barcode_video",
         "//media/cast:generate_timecode_audio",
         "//net:crash_cache",
@@ -528,10 +522,6 @@ group("gn_all") {
       "//mojo:mojo_perftests",
       "//services/service_manager/public/cpp",
       "//testing/gmock:gmock_main",
-      "//third_party/breakpad:dump_syms($host_toolchain)",
-      "//third_party/breakpad:microdump_stackwalk($host_toolchain)",
-      "//third_party/breakpad:minidump_dump($host_toolchain)",
-      "//third_party/breakpad:minidump_stackwalk($host_toolchain)",
     ]
 
     if (!is_android) {
@@ -609,7 +599,7 @@ group("gn_all") {
         host_os == "win") {
       deps += [ "//chrome/test/mini_installer:mini_installer_tests" ]
     }
-  } else if (!is_android && !is_ios && !is_fuchsia) {
+  } else if (!is_android && !is_ios && !is_fuchsia && !is_bsd) {
     deps += [ "//third_party/breakpad:symupload($host_toolchain)" ]
   }
 
@@ -829,7 +819,6 @@ if (is_chromeos) {
       "//ppapi/examples/video_decode",
       "//sandbox/linux:chrome_sandbox",
       "//sandbox/linux:sandbox_linux_unittests",
-      "//third_party/breakpad:minidump_stackwalk($host_toolchain)",
 
       # Blocked on https://github.com/catapult-project/catapult/issues/2297
       #"//third_party/catapult/telemetry:bitmaptools",
@@ -934,7 +923,7 @@ if (!is_ios) {
       ]
     }
 
-    if (!is_win && !is_android) {
+    if (!is_win && !is_android && !is_bsd) {
       data_deps +=
           [ "//third_party/breakpad:minidump_stackwalk($host_toolchain)" ]
     }
@@ -943,7 +932,7 @@ if (!is_ios) {
       data_deps += [ "//third_party/breakpad:dump_syms($host_toolchain)" ]
     }
 
-    if (is_linux) {
+    if (is_linux && !is_bsd) {
       data_deps += [ "//third_party/breakpad:dump_syms($host_toolchain)" ]
     }
 
@@ -1069,9 +1058,6 @@ group("chromium_builder_perf") {
 
     if (is_win) {
       data_deps += [ "//chrome/installer/mini_installer:mini_installer" ]
-    } else {
-      data_deps +=
-          [ "//third_party/breakpad:minidump_stackwalk($host_toolchain)" ]
     }
     if (is_win || is_android) {
       data_deps += [
diff --git apps/ui/views/app_window_frame_view.cc apps/ui/views/app_window_frame_view.cc
index e24781c25e..ca42fdf7e6 100644
--- apps/ui/views/app_window_frame_view.cc
+++ apps/ui/views/app_window_frame_view.cc
@@ -132,7 +132,7 @@ gfx::Rect AppWindowFrameView::GetBoundsForClientView() const {
 gfx::Rect AppWindowFrameView::GetWindowBoundsForClientBounds(
     const gfx::Rect& client_bounds) const {
   gfx::Rect window_bounds = client_bounds;
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   // Get the difference between the widget's client area bounds and window
   // bounds, and grow |window_bounds| by that amount.
   gfx::Insets native_frame_insets =
diff --git ash/display/mirror_window_controller.cc ash/display/mirror_window_controller.cc
index 73446af096..ed5b7a0ecb 100644
--- ash/display/mirror_window_controller.cc
+++ ash/display/mirror_window_controller.cc
@@ -258,7 +258,11 @@ void MirrorWindowController::UpdateWindow(
                          return info.id() == iter->first;
                        }) == display_info_list.end()) {
         CloseAndDeleteHost(iter->second, true);
+#if defined(__llvm__)
+        mirroring_host_info_map_.erase(iter++);
+#else
         iter = mirroring_host_info_map_.erase(iter);
+#endif
       } else {
         ++iter;
       }
diff --git base/BUILD.gn base/BUILD.gn
index 943412faef..ecc8d7fb91 100644
--- base/BUILD.gn
+++ base/BUILD.gn
@@ -1217,7 +1217,7 @@ jumbo_component("base") {
   # Needed for <atomic> if using newer C++ library than sysroot, except if
   # building inside the cros_sdk environment - use host_toolchain as a
   # more robust check for this.
-  if (!use_sysroot && (is_android || (is_linux && !is_chromecast)) &&
+  if (!use_sysroot && (is_android || (is_linux && !is_chromecast) && !is_clang) &&
       host_toolchain != "//build/toolchain/cros:host") {
     libs = [ "atomic" ]
   }
@@ -1243,7 +1243,7 @@ jumbo_component("base") {
         "allocator/allocator_shim_override_glibc_weak_symbols.h",
       ]
       deps += [ "//base/allocator:tcmalloc" ]
-    } else if (is_linux && use_allocator == "none") {
+    } else if ((is_linux && !is_bsd) && use_allocator == "none") {
       sources += [ "allocator/allocator_shim_default_dispatch_to_glibc.cc" ]
     } else if (is_android && use_allocator == "none") {
       sources += [
@@ -1655,7 +1655,7 @@ jumbo_component("base") {
       "//base/third_party/xdg_user_dirs",
     ]
   } else {
-    # Non-Linux.
+    # Non-Linux/BSD.
     sources -= [
       "nix/mime_util_xdg.cc",
       "nix/mime_util_xdg.h",
@@ -1671,6 +1671,33 @@ jumbo_component("base") {
     }
   }
 
+  if (is_bsd) {
+    sources -= [
+      "files/file_path_watcher_linux.cc",
+      "files/file_util_linux.cc",
+      "process/memory_linux.cc",
+      "process/process_linux.cc",
+      "process/process_handle_linux.cc",
+      "process/process_iterator_linux.cc",
+      "process/process_metrics_linux.cc",
+      "sys_info_linux.cc"
+    ]
+    sources += [
+      "files/file_path_watcher_kqueue.cc",
+      "files/file_path_watcher_kqueue.h",
+      "files/file_path_watcher_stub.cc",
+      "process/memory_stubs.cc",
+      "process/process_handle_freebsd.cc",
+      "process/process_iterator_freebsd.cc",
+      "process/process_metrics_freebsd.cc",
+      "sys_info_freebsd.cc",
+    ]
+    libs = [
+      "execinfo", # logging.cc
+      "kvm"       # process_metrics_freebsd
+    ]
+  }
+
   # iOS
   if (is_ios) {
     set_sources_assignment_filter([])
@@ -2646,6 +2673,12 @@ test("base_unittests") {
     set_sources_assignment_filter(sources_assignment_filter)
   }
 
+  if (is_bsd) {
+    sources -= [
+      "debug/proc_maps_linux_unittest.cc",
+    ]
+  } 
+
   if (is_win) {
     deps += [ "//base:scoped_handle_test_dll" ]
     if (current_cpu == "x64") {
diff --git base/allocator/allocator_shim.cc base/allocator/allocator_shim.cc
index e919f094c3..c6c0d43437 100644
--- base/allocator/allocator_shim.cc
+++ base/allocator/allocator_shim.cc
@@ -69,7 +69,7 @@ inline const allocator::AllocatorDispatch* GetChainHead() {
   // Unfortunately due to that bug NoBarrier_Load() is mistakenly fully
   // barriered on Linux+Clang, and that causes visible perf regressons.
   return reinterpret_cast<const allocator::AllocatorDispatch*>(
-#if defined(OS_LINUX) && defined(__clang__)
+#if (defined(OS_BSD) || defined(OS_LINUX)) && defined(__clang__)
       *static_cast<const volatile subtle::AtomicWord*>(&g_chain_head)
 #else
       subtle::NoBarrier_Load(&g_chain_head)
diff --git base/allocator/allocator_shim_default_dispatch_to_glibc.cc base/allocator/allocator_shim_default_dispatch_to_glibc.cc
index 8574da3eb3..2c321afc80 100644
--- base/allocator/allocator_shim_default_dispatch_to_glibc.cc
+++ base/allocator/allocator_shim_default_dispatch_to_glibc.cc
@@ -3,19 +3,28 @@
 // found in the LICENSE file.
 
 #include "base/allocator/allocator_shim.h"
-
-#include <malloc.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <malloc_np.h>
 
 // This translation unit defines a default dispatch for the allocator shim which
 // routes allocations to libc functions.
-// The code here is strongly inspired from tcmalloc's libc_override_glibc.h.
+// The code here is strongly inspired from tcmalloc's override_glibc.h.
 
 extern "C" {
-void* __libc_malloc(size_t size);
-void* __libc_calloc(size_t n, size_t size);
-void* __libc_realloc(void* address, size_t size);
-void* __libc_memalign(size_t alignment, size_t size);
-void __libc_free(void* ptr);
+void* __malloc(size_t size);
+void* __calloc(size_t n, size_t size);
+void* __realloc(void* address, size_t size);
+void* __memalign(size_t alignment, size_t size) {
+  void *ret;
+  if (__posix_memalign(&ret, alignment, size) != 0) {
+      return nullptr;
+  } else {
+      return ret;
+  }
+}
+int __posix_memalign(void **ptr, size_t alignment, size_t size);
+void __free(void* ptr);
 }  // extern "C"
 
 namespace {
@@ -23,32 +32,32 @@ namespace {
 using base::allocator::AllocatorDispatch;
 
 void* GlibcMalloc(const AllocatorDispatch*, size_t size, void* context) {
-  return __libc_malloc(size);
+  return __malloc(size);
 }
 
 void* GlibcCalloc(const AllocatorDispatch*,
                   size_t n,
                   size_t size,
                   void* context) {
-  return __libc_calloc(n, size);
+  return __calloc(n, size);
 }
 
 void* GlibcRealloc(const AllocatorDispatch*,
                    void* address,
                    size_t size,
                    void* context) {
-  return __libc_realloc(address, size);
+  return __realloc(address, size);
 }
 
 void* GlibcMemalign(const AllocatorDispatch*,
                     size_t alignment,
                     size_t size,
                     void* context) {
-  return __libc_memalign(alignment, size);
+  return __memalign(alignment, size);
 }
 
 void GlibcFree(const AllocatorDispatch*, void* address, void* context) {
-  __libc_free(address);
+  __free(address);
 }
 
 size_t GlibcGetSizeEstimate(const AllocatorDispatch*,
diff --git base/allocator/allocator_shim_override_libc_symbols.h base/allocator/allocator_shim_override_libc_symbols.h
index b77cbb1fe9..fe112abbe4 100644
--- base/allocator/allocator_shim_override_libc_symbols.h
+++ base/allocator/allocator_shim_override_libc_symbols.h
@@ -10,7 +10,7 @@
 #endif
 #define BASE_ALLOCATOR_ALLOCATOR_SHIM_OVERRIDE_LIBC_SYMBOLS_H_
 
-#include <malloc.h>
+#include <stdlib.h>
 
 #include "base/allocator/allocator_shim_internals.h"
 
diff --git base/allocator/allocator_shim_unittest.cc base/allocator/allocator_shim_unittest.cc
index 3be8f2cabd..a1b8ed4f1a 100644
--- base/allocator/allocator_shim_unittest.cc
+++ base/allocator/allocator_shim_unittest.cc
@@ -294,7 +294,7 @@ TEST_F(AllocatorShimTest, InterceptLibcSymbols) {
   ASSERT_GE(aligned_allocs_intercepted_by_size[61], 1u);
 #endif  // !OS_WIN
 
-#if !defined(OS_WIN) && !defined(OS_MACOSX)
+#if !defined(OS_WIN) && !defined(OS_MACOSX) && !defined(OS_BSD)
   void* memalign_ptr = memalign(128, 53);
   ASSERT_NE(nullptr, memalign_ptr);
   ASSERT_EQ(0u, reinterpret_cast<uintptr_t>(memalign_ptr) % 128);
@@ -307,7 +307,7 @@ TEST_F(AllocatorShimTest, InterceptLibcSymbols) {
   ASSERT_GE(aligned_allocs_intercepted_by_alignment[kPageSize], 1u);
   // pvalloc rounds the size up to the next page.
   ASSERT_GE(aligned_allocs_intercepted_by_size[kPageSize], 1u);
-#endif  // !OS_WIN && !OS_MACOSX
+#endif  // !OS_WIN && !OS_MACOSX && !OS_BSD
 
   char* realloc_ptr = static_cast<char*>(malloc(10));
   strcpy(realloc_ptr, "foobar");
@@ -323,13 +323,13 @@ TEST_F(AllocatorShimTest, InterceptLibcSymbols) {
   free(zero_alloc_ptr);
   ASSERT_GE(frees_intercepted_by_addr[Hash(zero_alloc_ptr)], 1u);
 
-#if !defined(OS_WIN) && !defined(OS_MACOSX)
+#if !defined(OS_WIN) && !defined(OS_MACOSX) && !defined(OS_BSD)
   free(memalign_ptr);
   ASSERT_GE(frees_intercepted_by_addr[Hash(memalign_ptr)], 1u);
 
   free(pvalloc_ptr);
   ASSERT_GE(frees_intercepted_by_addr[Hash(pvalloc_ptr)], 1u);
-#endif  // !OS_WIN && !OS_MACOSX
+#endif  // !OS_WIN && !OS_MACOSX && !OS_BSD
 
 #if !defined(OS_WIN)
   free(posix_memalign_ptr);
diff --git base/allocator/partition_allocator/partition_alloc_unittest.cc base/allocator/partition_allocator/partition_alloc_unittest.cc
index 4bf6b26d7c..db6429a619 100644
--- base/allocator/partition_allocator/partition_alloc_unittest.cc
+++ base/allocator/partition_allocator/partition_alloc_unittest.cc
@@ -1297,7 +1297,7 @@ TEST_F(PartitionAllocTest, LostFreePagesBug) {
 // not provide a working setrlimit().
 #if !defined(ARCH_CPU_64_BITS) || \
     (defined(OS_POSIX) &&         \
-     !(defined(OS_FUCHSIA) || defined(OS_MACOSX) || defined(OS_ANDROID)))
+     !(defined(OS_FUCHSIA) || defined(OS_MACOSX) || defined(OS_ANDROID) || defined(OS_BSD)))
 
 // This is defined as a separate test class because RepeatedReturnNull
 // test exhausts the process memory, and breaks any test in the same
diff --git base/base_paths_posix.cc base/base_paths_posix.cc
index 00a15696ca..a16ceb7ee2 100644
--- base/base_paths_posix.cc
+++ base/base_paths_posix.cc
@@ -24,7 +24,7 @@
 #include "base/process/process_metrics.h"
 #include "build/build_config.h"
 
-#if defined(OS_FREEBSD)
+#if defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
 #include <sys/param.h>
 #include <sys/sysctl.h>
 #elif defined(OS_SOLARIS) || defined(OS_AIX)
@@ -45,7 +45,7 @@ bool PathProviderPosix(int key, FilePath* result) {
       }
       *result = bin_dir;
       return true;
-#elif defined(OS_FREEBSD)
+#elif defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
       int name[] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };
       char bin_dir[PATH_MAX + 1];
       size_t length = sizeof(bin_dir);
diff --git base/debug/debugger_posix.cc base/debug/debugger_posix.cc
index b62bf013bd..3f0db33f0f 100644
--- base/debug/debugger_posix.cc
+++ base/debug/debugger_posix.cc
@@ -34,7 +34,7 @@
 #include <sys/sysctl.h>
 #endif
 
-#if defined(OS_FREEBSD)
+#if defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
 #include <sys/user.h>
 #endif
 
@@ -84,7 +84,7 @@ bool BeingDebugged() {
     KERN_PROC,
     KERN_PROC_PID,
     getpid()
-#if defined(OS_OPENBSD)
+#if defined(OS_BSD) 
     , sizeof(struct kinfo_proc),
     0
 #endif
@@ -92,33 +92,38 @@ bool BeingDebugged() {
 
   // Caution: struct kinfo_proc is marked __APPLE_API_UNSTABLE.  The source and
   // binary interfaces may change.
-  struct kinfo_proc info;
-  size_t info_size = sizeof(info);
+  struct kinfo_proc *info;
+  size_t info_size;
 
-#if defined(OS_OPENBSD)
   if (sysctl(mib, arraysize(mib), NULL, &info_size, NULL, 0) < 0)
     return -1;
 
+  info = (struct kinfo_proc *)malloc(info_size);
+
   mib[5] = (info_size / sizeof(struct kinfo_proc));
-#endif
 
-  int sysctl_result = sysctl(mib, arraysize(mib), &info, &info_size, NULL, 0);
+  int sysctl_result = sysctl(mib, arraysize(mib), info, &info_size, NULL, 0);
   DCHECK_EQ(sysctl_result, 0);
   if (sysctl_result != 0) {
     is_set = true;
     being_debugged = false;
-    return being_debugged;
+    goto out;
   }
 
   // This process is being debugged if the P_TRACED flag is set.
   is_set = true;
 #if defined(OS_FREEBSD)
-  being_debugged = (info.ki_flag & P_TRACED) != 0;
+  being_debugged = (info->ki_flag & P_TRACED) != 0;
+#elif defined(OS_DRAGONFLY)
+  being_debugged = (info->kp_flags & P_TRACED) != 0;
 #elif defined(OS_BSD)
-  being_debugged = (info.p_flag & P_TRACED) != 0;
+  being_debugged = (info->p_flag & P_TRACED) != 0;
 #else
-  being_debugged = (info.kp_proc.p_flag & P_TRACED) != 0;
+  being_debugged = (info->kp_proc.p_flag & P_TRACED) != 0;
 #endif
+
+out:
+  free(info);
   return being_debugged;
 }
 
diff --git base/debug/elf_reader_linux.cc base/debug/elf_reader_linux.cc
index cdf8193ff6..b5f21ed49b 100644
--- base/debug/elf_reader_linux.cc
+++ base/debug/elf_reader_linux.cc
@@ -41,8 +41,10 @@ Optional<std::string> ElfSegmentBuildIDNoteAsString(const ElfSegment& segment) {
   const void* section_end = segment.data() + segment.size_bytes();
   const Nhdr* note_header = reinterpret_cast<const Nhdr*>(segment.data());
   while (note_header < section_end) {
+#if !defined(OS_BSD)
     if (note_header->n_type == NT_GNU_BUILD_ID)
       break;
+#endif
     note_header = reinterpret_cast<const Nhdr*>(
         reinterpret_cast<const char*>(note_header) + sizeof(Nhdr) +
         bits::Align(note_header->n_namesz, 4) +
diff --git base/debug/proc_maps_linux.cc base/debug/proc_maps_linux.cc
index 0bb44b45ac..7d1be154ef 100644
--- base/debug/proc_maps_linux.cc
+++ base/debug/proc_maps_linux.cc
@@ -12,7 +12,7 @@
 #include "base/strings/string_split.h"
 #include "build/build_config.h"
 
-#if defined(OS_LINUX) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_BSD) || defined(OS_ANDROID)
 #include <inttypes.h>
 #endif
 
diff --git base/debug/stack_trace.h base/debug/stack_trace.h
index 81e6672e8a..29dff1d095 100644
--- base/debug/stack_trace.h
+++ base/debug/stack_trace.h
@@ -16,6 +16,7 @@
 #include "build/build_config.h"
 
 #if defined(OS_POSIX)
+#include <sys/stdint.h>
 #include <unistd.h>
 #endif
 
diff --git base/debug/stack_trace_posix.cc base/debug/stack_trace_posix.cc
index f3f05dad26..2e5da8b5a2 100644
--- base/debug/stack_trace_posix.cc
+++ base/debug/stack_trace_posix.cc
@@ -35,7 +35,7 @@
 #include <AvailabilityMacros.h>
 #endif
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include "base/debug/proc_maps_linux.h"
 #endif
 
@@ -646,6 +646,11 @@ class SandboxSymbolizeHelper {
   // for the modules that are loaded in the current process.
   // Returns true on success.
   bool CacheMemoryRegions() {
+#if defined(OS_BSD)
+    // TODO (rene) avoid link error, implement something?
+    NOTIMPLEMENTED();
+    return false;
+#else
     // Reads /proc/self/maps.
     std::string contents;
     if (!ReadProcMaps(&contents)) {
@@ -663,6 +668,7 @@ class SandboxSymbolizeHelper {
 
     is_initialized_ = true;
     return true;
+#endif
   }
 
   // Opens all object files and caches their file descriptors.
@@ -800,7 +806,7 @@ StackTrace::StackTrace(size_t count) {
 // NOTE: This code MUST be async-signal safe (it's used by in-process
 // stack dumping signal handler). NO malloc or stdio is allowed here.
 
-#if !defined(__UCLIBC__) && !defined(_AIX)
+#if !defined(__UCLIBC__) && !defined(_AIX) && !defined(OS_BSD)
   count = std::min(arraysize(trace_), count);
 
   // Though the backtrace API man page does not list any possible negative
diff --git base/debug/thread_heap_usage_tracker.cc base/debug/thread_heap_usage_tracker.cc
index 6d00b1ccbb..f78ee3e5b6 100644
--- base/debug/thread_heap_usage_tracker.cc
+++ base/debug/thread_heap_usage_tracker.cc
@@ -17,11 +17,13 @@
 #include "base/threading/thread_local_storage.h"
 #include "build/build_config.h"
 
+#if !defined(OS_BSD)
 #if defined(OS_MACOSX) || defined(OS_IOS)
 #include <malloc/malloc.h>
 #else
 #include <malloc.h>
 #endif
+#endif
 
 namespace base {
 namespace debug {
diff --git base/files/file_path_unittest.cc base/files/file_path_unittest.cc
index e722c68285..c20c75f9d5 100644
--- base/files/file_path_unittest.cc
+++ base/files/file_path_unittest.cc
@@ -1136,7 +1136,7 @@ TEST_F(FilePathTest, FromUTF8Unsafe_And_AsUTF8Unsafe) {
       "\xEF\xBC\xA1\xEF\xBC\xA2\xEF\xBC\xA3.txt" },
   };
 
-#if !defined(SYSTEM_NATIVE_UTF8) && defined(OS_LINUX)
+#if !defined(SYSTEM_NATIVE_UTF8) && (defined(OS_LINUX) || defined(OS_BSD))
   ScopedLocale locale("en_US.UTF-8");
 #endif
 
diff --git base/files/file_path_watcher_kqueue.h base/files/file_path_watcher_kqueue.h
index ef79be5596..0edee3f0f1 100644
--- base/files/file_path_watcher_kqueue.h
+++ base/files/file_path_watcher_kqueue.h
@@ -5,6 +5,10 @@
 #ifndef BASE_FILES_FILE_PATH_WATCHER_KQUEUE_H_
 #define BASE_FILES_FILE_PATH_WATCHER_KQUEUE_H_
 
+#ifdef __FreeBSD__
+#include <sys/stdint.h>
+#include <sys/types.h>
+#endif
 #include <sys/event.h>
 
 #include <memory>
diff --git base/files/file_path_watcher_stub.cc base/files/file_path_watcher_stub.cc
index 93a5babe9b..93931caf0c 100644
--- base/files/file_path_watcher_stub.cc
+++ base/files/file_path_watcher_stub.cc
@@ -1,14 +1,15 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Copyright 2014 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-// This file exists for Unix systems which don't have the inotify headers, and
-// thus cannot build file_watcher_inotify.cc
 
-#include "base/files/file_path_watcher.h"
+#include <memory>
 
+#include "base/files/file_path_watcher.h"
+#include "base/files/file_path_watcher_kqueue.h"
 #include "base/macros.h"
 #include "base/memory/ptr_util.h"
+#include "build/build_config.h"
 
 namespace base {
 
@@ -22,12 +23,26 @@ class FilePathWatcherImpl : public FilePathWatcher::PlatformDelegate {
   bool Watch(const FilePath& path,
              bool recursive,
              const FilePathWatcher::Callback& callback) override {
-    return false;
+    DCHECK(!impl_.get());
+    if (recursive) {
+      if (!FilePathWatcher::RecursiveWatchAvailable())
+        return false;
+    } else {
+     impl_ = std::make_unique<FilePathWatcherKQueue>();
+    }
+    DCHECK(impl_.get());
+    return impl_->Watch(path, recursive, callback);
   }
 
-  void Cancel() override {}
+  void Cancel() override {
+    if (impl_.get())
+      impl_->Cancel();
+    set_cancelled();
+  }
 
  private:
+  std::unique_ptr<PlatformDelegate> impl_;
+
   DISALLOW_COPY_AND_ASSIGN(FilePathWatcherImpl);
 };
 
diff --git base/files/file_path_watcher_unittest.cc base/files/file_path_watcher_unittest.cc
index 2cc2e5846e..eeadd2ead3 100644
--- base/files/file_path_watcher_unittest.cc
+++ base/files/file_path_watcher_unittest.cc
@@ -435,7 +435,7 @@ TEST_F(FilePathWatcherTest, WatchDirectory) {
   VLOG(1) << "Waiting for file1 creation";
   ASSERT_TRUE(WaitForEvents());
 
-#if !defined(OS_MACOSX)
+#if !defined(OS_MACOSX) && !defined(OS_BSD)
   // Mac implementation does not detect files modified in a directory.
   ASSERT_TRUE(WriteFile(file1, "content v2"));
   VLOG(1) << "Waiting for file1 modification";
diff --git base/files/file_util.h base/files/file_util.h
index 1ba9368172..64bb1366d2 100644
--- base/files/file_util.h
+++ base/files/file_util.h
@@ -436,7 +436,7 @@ BASE_EXPORT bool VerifyPathControlledByAdmin(const base::FilePath& path);
 // the directory |path|, in the number of FilePath::CharType, or -1 on failure.
 BASE_EXPORT int GetMaximumPathComponentLength(const base::FilePath& path);
 
-#if defined(OS_LINUX) || defined(OS_AIX)
+#if defined(OS_LINUX) || defined(OS_AIX) || defined(OS_BSD)
 // Broad categories of file systems as returned by statfs() on Linux.
 enum FileSystemType {
   FILE_SYSTEM_UNKNOWN,  // statfs failed.
diff --git base/files/memory_mapped_file_posix.cc base/files/memory_mapped_file_posix.cc
index 45a0aea6dd..5befccccd2 100644
--- base/files/memory_mapped_file_posix.cc
+++ base/files/memory_mapped_file_posix.cc
@@ -110,6 +110,8 @@ bool MemoryMappedFile::MapFileRegionToMemory(
       // Only Android API>=21 supports the fallocate call. Older versions need
       // to manually extend the file by writing zeros at block intervals.
       do_manual_extension = true;
+#elif defined(OS_BSD)
+      do_manual_extension = true;
 #elif defined(OS_MACOSX)
       // MacOS doesn't support fallocate even though their new APFS filesystem
       // does support sparse files. It does, however, have the functionality
diff --git base/i18n/icu_util.cc base/i18n/icu_util.cc
index bc08ecb1e3..8178126e02 100644
--- base/i18n/icu_util.cc
+++ base/i18n/icu_util.cc
@@ -20,7 +20,7 @@
 #include "build/build_config.h"
 #include "third_party/icu/source/common/unicode/putil.h"
 #include "third_party/icu/source/common/unicode/udata.h"
-#if (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_ANDROID)
+#if (defined(OS_LINUX) || defined(OS_BSD) && !defined(OS_CHROMEOS)) || defined(OS_ANDROID)
 #include "third_party/icu/source/i18n/unicode/timezone.h"
 #endif
 
@@ -257,7 +257,7 @@ bool InitializeICU() {
 // TODO(jungshik): Some callers do not care about tz at all. If necessary,
 // add a boolean argument to this function to init'd the default tz only
 // when requested.
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   if (result)
     std::unique_ptr<icu::TimeZone> zone(icu::TimeZone::createDefault());
 #endif
diff --git base/linux_util.cc base/linux_util.cc
index ddf848eeb7..91343c8a8d 100644
--- base/linux_util.cc
+++ base/linux_util.cc
@@ -111,12 +111,14 @@ char g_linux_distro[kDistroSize] =
     "CrOS";
 #elif defined(OS_ANDROID)
     "Android";
+#elif defined(OS_BSD)
+    "BSD";
 #else  // if defined(OS_LINUX)
     "Unknown";
 #endif
 
 std::string GetLinuxDistro() {
-#if defined(OS_CHROMEOS) || defined(OS_ANDROID)
+#if defined(OS_CHROMEOS) || defined(OS_ANDROID) || defined(OS_BSD)
   return g_linux_distro;
 #elif defined(OS_LINUX)
   LinuxDistroHelper* distro_state_singleton = LinuxDistroHelper::GetInstance();
diff --git base/logging_unittest.cc base/logging_unittest.cc
index 9025aaf4e5..3331f12ad9 100644
--- base/logging_unittest.cc
+++ base/logging_unittest.cc
@@ -292,7 +292,7 @@ void CheckCrashTestSighandler(int, siginfo_t* info, void* context_ptr) {
   // need the arch-specific boilerplate below, which is inspired by breakpad.
   // At the same time, on OSX, ucontext.h is deprecated but si_addr works fine.
   uintptr_t crash_addr = 0;
-#if defined(OS_MACOSX)
+#if defined(OS_MACOSX) || defined(OS_BSD)
   crash_addr = reinterpret_cast<uintptr_t>(info->si_addr);
 #else  // OS_POSIX && !OS_MACOSX
   ucontext_t* context = reinterpret_cast<ucontext_t*>(context_ptr);
diff --git base/native_library_posix.cc base/native_library_posix.cc
index 19ff7a4b0b..106d6bef2f 100644
--- base/native_library_posix.cc
+++ base/native_library_posix.cc
@@ -29,7 +29,7 @@ NativeLibrary LoadNativeLibraryWithOptions(const FilePath& library_path,
   // http://crbug.com/17943, http://crbug.com/17557, http://crbug.com/36892,
   // and http://crbug.com/40794.
   int flags = RTLD_LAZY;
-#if defined(OS_ANDROID) || !defined(RTLD_DEEPBIND)
+#if defined(OS_ANDROID) || !defined(RTLD_DEEPBIND) || defined(OS_BSD)
   // Certain platforms don't define RTLD_DEEPBIND. Android dlopen() requires
   // further investigation, as it might vary across versions. Crash here to
   // warn developers that they're trying to rely on uncertain behavior.
diff --git base/native_library_unittest.cc base/native_library_unittest.cc
index 2bfb9ec946..8853c059e2 100644
--- base/native_library_unittest.cc
+++ base/native_library_unittest.cc
@@ -120,7 +120,7 @@ TEST(NativeLibraryTest, LoadLibrary) {
 // Android dlopen() requires further investigation, as it might vary across
 // versions with respect to symbol resolution scope.
 // TSan and MSan error out on RTLD_DEEPBIND, https://crbug.com/705255
-#if !defined(OS_ANDROID) && !defined(THREAD_SANITIZER) && \
+#if !defined(OS_ANDROID) && !defined(OS_BSD) && !defined(THREAD_SANITIZER) && \
     !defined(MEMORY_SANITIZER)
 
 // Verifies that the |prefer_own_symbols| option satisfies its guarantee that
diff --git base/posix/unix_domain_socket.cc base/posix/unix_domain_socket.cc
index 7c087a53b5..24baf3ad30 100644
--- base/posix/unix_domain_socket.cc
+++ base/posix/unix_domain_socket.cc
@@ -5,7 +5,10 @@
 #include "base/posix/unix_domain_socket.h"
 
 #include <errno.h>
+#include <sys/param.h>
 #include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/ucred.h>
 #if !defined(OS_NACL_NONSFI)
 #include <sys/un.h>
 #endif
@@ -28,6 +31,14 @@ namespace base {
 
 const size_t UnixDomainSocket::kMaxFileDescriptors = 16;
 
+#ifndef SCM_CREDENTIALS
+#  define SCM_CREDENTIALS  0x9001
+#endif
+
+#ifndef SO_PASSCRED
+#  define SO_PASSCRED      0x9002
+#endif
+
 #if !defined(OS_NACL_NONSFI)
 bool CreateSocketPair(ScopedFD* one, ScopedFD* two) {
   int raw_socks[2];
@@ -150,7 +161,7 @@ ssize_t UnixDomainSocket::RecvMsgWithFlags(int fd,
 #if !defined(OS_NACL_NONSFI) && !defined(OS_MACOSX)
       // The PNaCl toolchain for Non-SFI binary build and macOS do not support
       // ucred. macOS supports xucred, but this structure is insufficient.
-      + CMSG_SPACE(sizeof(struct ucred))
+      + CMSG_SPACE(sizeof(struct cmsgcred))
 #endif  // OS_NACL_NONSFI or OS_MACOSX
       ;
   char control_buffer[kControlBufferSize];
@@ -180,9 +191,9 @@ ssize_t UnixDomainSocket::RecvMsgWithFlags(int fd,
       // SCM_CREDENTIALS.
       if (cmsg->cmsg_level == SOL_SOCKET &&
           cmsg->cmsg_type == SCM_CREDENTIALS) {
-        DCHECK_EQ(payload_len, sizeof(struct ucred));
+        DCHECK_EQ(payload_len, sizeof(struct cmsgcred));
         DCHECK_EQ(pid, -1);
-        pid = reinterpret_cast<struct ucred*>(CMSG_DATA(cmsg))->pid;
+        pid = getpid();
       }
 #endif  // !defined(OS_NACL_NONSFI) && !defined(OS_MACOSX)
     }
diff --git base/posix/unix_domain_socket_unittest.cc base/posix/unix_domain_socket_unittest.cc
index 453064f535..d5bcf0f73f 100644
--- base/posix/unix_domain_socket_unittest.cc
+++ base/posix/unix_domain_socket_unittest.cc
@@ -8,6 +8,9 @@
 #include <stdint.h>
 #include <sys/socket.h>
 #include <sys/types.h>
+#if defined(OS_BSD)
+#include <signal.h>
+#endif
 #include <unistd.h>
 
 #include "base/bind.h"
diff --git base/process/internal_linux.cc base/process/internal_linux.cc
index 7f38fff23a..dd08a93568 100644
--- base/process/internal_linux.cc
+++ base/process/internal_linux.cc
@@ -60,10 +60,13 @@ bool ReadProcFile(const FilePath& file, std::string* buffer) {
   // Synchronously reading files in /proc is safe.
   ThreadRestrictions::ScopedAllowIO allow_io;
 
+#if !defined(OS_BSD)
   if (!ReadFileToString(file, buffer)) {
     DLOG(WARNING) << "Failed to read " << file.MaybeAsASCII();
     return false;
   }
+#endif
+
   return !buffer->empty();
 }
 
diff --git base/process/internal_linux.h base/process/internal_linux.h
index d8904fd110..dda864fa0d 100644
--- base/process/internal_linux.h
+++ base/process/internal_linux.h
@@ -14,6 +14,8 @@
 
 #include "base/files/file_path.h"
 
+#include <unistd.h> /* pid_t */
+
 namespace base {
 
 class Time;
diff --git base/process/kill.h base/process/kill.h
index 005b72e2aa..8549fc8fdb 100644
--- base/process/kill.h
+++ base/process/kill.h
@@ -111,7 +111,7 @@ BASE_EXPORT TerminationStatus GetTerminationStatus(ProcessHandle handle,
 BASE_EXPORT TerminationStatus GetKnownDeadTerminationStatus(
     ProcessHandle handle, int* exit_code);
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 // Spawns a thread to wait asynchronously for the child |process| to exit
 // and then reaps it.
 BASE_EXPORT void EnsureProcessGetsReaped(Process process);
diff --git base/process/kill_posix.cc base/process/kill_posix.cc
index 4b52d8b0ef..1d566454cf 100644
--- base/process/kill_posix.cc
+++ base/process/kill_posix.cc
@@ -167,7 +167,7 @@ void EnsureProcessTerminated(Process process) {
       0, new BackgroundReaper(std::move(process), TimeDelta::FromSeconds(2)));
 }
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 void EnsureProcessGetsReaped(Process process) {
   DCHECK(!process.is_current());
 
diff --git base/process/launch.cc base/process/launch.cc
index c03e1a75db..89a0381df4 100644
--- base/process/launch.cc
+++ base/process/launch.cc
@@ -15,7 +15,7 @@ LaunchOptions::~LaunchOptions() = default;
 
 LaunchOptions LaunchOptionsForTest() {
   LaunchOptions options;
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // To prevent accidental privilege sharing to an untrusted child, processes
   // are started with PR_SET_NO_NEW_PRIVS. Do not set that here, since this
   // new child will be used for testing only.
diff --git base/process/launch.h base/process/launch.h
index b4530b755a..74fd989491 100644
--- base/process/launch.h
+++ base/process/launch.h
@@ -167,7 +167,7 @@ struct BASE_EXPORT LaunchOptions {
   FileHandleMappingVector fds_to_remap;
 #endif  // defined(OS_WIN)
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // If non-zero, start the process using clone(), using flags as provided.
   // Unlike in clone, clone_flags may not contain a custom termination signal
   // that is sent to the parent when the child dies. The termination signal will
@@ -180,7 +180,7 @@ struct BASE_EXPORT LaunchOptions {
 
   // Sets parent process death signal to SIGKILL.
   bool kill_on_parent_death = false;
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
 
 #if defined(OS_FUCHSIA)
   // If valid, launches the application in that job object.
diff --git base/process/launch_posix.cc base/process/launch_posix.cc
index ec584883b9..ffe30da1d5 100644
--- base/process/launch_posix.cc
+++ base/process/launch_posix.cc
@@ -53,7 +53,7 @@
 #include <sys/ioctl.h>
 #endif
 
-#if defined(OS_FREEBSD)
+#if defined(OS_BSD)
 #include <sys/event.h>
 #include <sys/ucontext.h>
 #endif
@@ -63,8 +63,12 @@
 #include <sys/event.h>
 
 #include "base/feature_list.h"
+#elif defined(OS_BSD)
+extern char** environ;
+#pragma weak environ
 #else
 extern char** environ;
+#pragma weak environ
 #endif
 
 namespace base {
@@ -225,6 +229,8 @@ static const char kFDDir[] = "/proc/self/fd";
 static const char kFDDir[] = "/dev/fd";
 #elif defined(OS_SOLARIS)
 static const char kFDDir[] = "/dev/fd";
+#elif defined(OS_DRAGONFLY)
+static const char kFDDir[] = "/dev/fd";
 #elif defined(OS_FREEBSD)
 static const char kFDDir[] = "/dev/fd";
 #elif defined(OS_OPENBSD)
diff --git base/process/memory.cc base/process/memory.cc
index 5b987339ba..67d7df923b 100644
--- base/process/memory.cc
+++ base/process/memory.cc
@@ -10,7 +10,7 @@
 namespace base {
 
 // Defined in memory_win.cc for Windows.
-#if !defined(OS_WIN)
+#if !defined(OS_WIN) && !defined(OS_BSD)
 
 namespace {
 
@@ -31,7 +31,7 @@ void TerminateBecauseOutOfMemory(size_t size) {
 #endif
 
 // Defined in memory_mac.mm for Mac.
-#if !defined(OS_MACOSX)
+#if !defined(OS_MACOSX) && !defined(OS_BSD)
 
 bool UncheckedCalloc(size_t num_items, size_t size, void** result) {
   const size_t alloc_size = num_items * size;
diff --git base/process/memory.h base/process/memory.h
index 7f16e12d8a..0132300015 100644
--- base/process/memory.h
+++ base/process/memory.h
@@ -32,7 +32,7 @@ BASE_EXPORT void EnableTerminationOnOutOfMemory();
 // Crash reporting classifies such crashes as OOM.
 BASE_EXPORT void TerminateBecauseOutOfMemory(size_t size);
 
-#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_AIX)
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_AIX) || defined(OS_BSD)
 BASE_EXPORT extern size_t g_oom_size;
 
 // The maximum allowed value for the OOM score.
diff --git base/process/memory_unittest.cc base/process/memory_unittest.cc
index 835cf7e485..0bbc8fffeb 100644
--- base/process/memory_unittest.cc
+++ base/process/memory_unittest.cc
@@ -104,7 +104,7 @@ TEST(MemoryTest, AllocatorShimWorking) {
 // OpenBSD does not support these tests. Don't test these on ASan/TSan/MSan
 // configurations: only test the real allocator.
 // Windows only supports these tests with the allocator shim in place.
-#if !defined(OS_OPENBSD) && BUILDFLAG(USE_ALLOCATOR_SHIM) && \
+#if !defined(OS_BSD) && BUILDFLAG(USE_ALLOCATOR_SHIM) && \
     !defined(MEMORY_TOOL_REPLACES_ALLOCATOR)
 
 namespace {
@@ -529,5 +529,5 @@ TEST_F(OutOfMemoryHandledTest, UncheckedCalloc) {
   EXPECT_FALSE(base::UncheckedCalloc(1, test_size_, &value_));
   EXPECT_TRUE(value_ == nullptr);
 }
-#endif  // !defined(OS_OPENBSD) && BUILDFLAG(ENABLE_WIN_ALLOCATOR_SHIM_TESTS) &&
+#endif  // !defined(OS_BSD) && BUILDFLAG(ENABLE_WIN_ALLOCATOR_SHIM_TESTS) &&
         // !defined(MEMORY_TOOL_REPLACES_ALLOCATOR)
diff --git base/process/process_handle.cc base/process/process_handle.cc
index 58ceb08469..3497ba3f67 100644
--- base/process/process_handle.cc
+++ base/process/process_handle.cc
@@ -39,7 +39,7 @@ uint32_t GetUniqueIdForProcess() {
   return g_unique_id;
 }
 
-#if defined(OS_LINUX) || defined(OS_AIX)
+#if defined(OS_LINUX) || defined(OS_AIX) || defined(OS_BSD)
 
 void InitUniqueIdForProcessInPidNamespace(ProcessId pid_outside_of_namespace) {
   g_unique_id = MangleProcessId(pid_outside_of_namespace);
diff --git base/process/process_handle.h base/process/process_handle.h
index f3f63439df..74e06311a1 100644
--- base/process/process_handle.h
+++ base/process/process_handle.h
@@ -64,7 +64,7 @@ BASE_EXPORT ProcessId GetCurrentProcId();
 // a process's PID.
 BASE_EXPORT uint32_t GetUniqueIdForProcess();
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 // When a process is started in a different PID namespace from the browser
 // process, this function must be called with the process's PID in the browser's
 // PID namespace in order to initialize its unique ID. Not thread safe.
diff --git base/process/process_handle_freebsd.cc base/process/process_handle_freebsd.cc
index 192d72bcc5..7abe1a9820 100644
--- base/process/process_handle_freebsd.cc
+++ base/process/process_handle_freebsd.cc
@@ -16,13 +16,20 @@ namespace base {
 
 ProcessId GetParentProcessId(ProcessHandle process) {
   struct kinfo_proc info;
-  size_t length;
+  size_t length = sizeof(struct kinfo_proc);
   int mib[] = { CTL_KERN, KERN_PROC, KERN_PROC_PID, process };
 
   if (sysctl(mib, arraysize(mib), &info, &length, NULL, 0) < 0)
     return -1;
 
+  if (length < sizeof(struct kinfo_proc))
+    return -1;
+
+#if defined(OS_DRAGONFLY)
+  return info.kp_ppid;
+#else
   return info.ki_ppid;
+#endif
 }
 
 FilePath GetProcessExecutablePath(ProcessHandle process) {
diff --git base/process/process_info_linux.cc base/process/process_info_linux.cc
index 2f227484f5..997977a6dc 100644
--- base/process/process_info_linux.cc
+++ base/process/process_info_linux.cc
@@ -11,10 +11,28 @@
 #include "base/process/process_handle.h"
 #include "base/time/time.h"
 
+#if defined(__FreeBSD__) || defined(__DragonFly__)
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#endif
+
 namespace base {
 
 // static
 const Time CurrentProcessInfo::CreationTime() {
+#if defined(__FreeBSD__) || defined(__DragonFly__)
+  int mib[] = { CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid() };
+  struct kinfo_proc proc;
+  size_t len = sizeof(struct kinfo_proc);
+  if (sysctl(mib, arraysize(mib), &proc, &len, NULL, 0) < 0)
+    return Time();
+#if defined(__DragonFly__)
+  return Time::FromTimeVal(proc.kp_start);
+#else
+  return Time::FromTimeVal(proc.ki_start);
+#endif
+#else
   int64_t start_ticks =
       internal::ReadProcSelfStatsAndGetFieldAsInt64(internal::VM_STARTTIME);
   if (!start_ticks)
@@ -24,6 +42,7 @@ const Time CurrentProcessInfo::CreationTime() {
   if (boot_time.is_null())
     return Time();
   return Time(boot_time + start_offset);
+#endif
 }
 
 }  // namespace base
diff --git base/process/process_iterator.h base/process/process_iterator.h
index b30ad41222..8d0dfe25d3 100644
--- base/process/process_iterator.h
+++ base/process/process_iterator.h
@@ -24,7 +24,7 @@
 #include <tlhelp32.h>
 #elif defined(OS_MACOSX) || defined(OS_OPENBSD)
 #include <sys/sysctl.h>
-#elif defined(OS_FREEBSD)
+#elif defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
 #include <sys/user.h>
 #elif defined(OS_POSIX) || defined(OS_FUCHSIA)
 #include <dirent.h>
diff --git base/process/process_iterator_freebsd.cc base/process/process_iterator_freebsd.cc
index 4df0d90ede..5437574ca1 100644
--- base/process/process_iterator_freebsd.cc
+++ base/process/process_iterator_freebsd.cc
@@ -10,6 +10,10 @@
 #include <sys/sysctl.h>
 #include <unistd.h>
 
+/* getuid() */
+#include <unistd.h>
+#include <sys/types.h>
+
 #include "base/logging.h"
 #include "base/macros.h"
 #include "base/strings/string_split.h"
@@ -26,6 +30,7 @@ ProcessIterator::ProcessIterator(const ProcessFilter* filter)
   bool done = false;
   int try_num = 1;
   const int max_tries = 10;
+  size_t num_of_kinfo_proc;
 
   do {
     size_t len = 0;
@@ -34,13 +39,13 @@ ProcessIterator::ProcessIterator(const ProcessFilter* filter)
       kinfo_procs_.resize(0);
       done = true;
     } else {
-      size_t num_of_kinfo_proc = len / sizeof(struct kinfo_proc);
+      num_of_kinfo_proc = len / sizeof(struct kinfo_proc);
       // Leave some spare room for process table growth (more could show up
       // between when we check and now)
       num_of_kinfo_proc += 16;
       kinfo_procs_.resize(num_of_kinfo_proc);
       len = num_of_kinfo_proc * sizeof(struct kinfo_proc);
-      if (sysctl(mib, arraysize(mib), &kinfo_procs_[0], &len, NULL, 0) <0) {
+      if (sysctl(mib, arraysize(mib), kinfo_procs_.data(), &len, NULL, 0) <0) {
         // If we get a mem error, it just means we need a bigger buffer, so
         // loop around again.  Anything else is a real error and give up.
         if (errno != ENOMEM) {
@@ -50,7 +55,7 @@ ProcessIterator::ProcessIterator(const ProcessFilter* filter)
         }
       } else {
         // Got the list, just make sure we're sized exactly right
-        size_t num_of_kinfo_proc = len / sizeof(struct kinfo_proc);
+        num_of_kinfo_proc = len / sizeof(struct kinfo_proc);
         kinfo_procs_.resize(num_of_kinfo_proc);
         done = true;
       }
@@ -72,19 +77,19 @@ bool ProcessIterator::CheckForNextProcess() {
   for (; index_of_kinfo_proc_ < kinfo_procs_.size(); ++index_of_kinfo_proc_) {
     size_t length;
     struct kinfo_proc kinfo = kinfo_procs_[index_of_kinfo_proc_];
-    int mib[] = { CTL_KERN, KERN_PROC_ARGS, kinfo.ki_pid };
+#if defined(OS_DRAGONFLY)
+    int mib[] = { CTL_KERN, KERN_PROC, KERN_PROC_ARGS, kinfo.kp_pid };
 
-    if ((kinfo.ki_pid > 0) && (kinfo.ki_stat == SZOMB))
+    if ((kinfo.kp_pid > 0) && (kinfo.kp_stat == SZOMB))
       continue;
+#else
+    int mib[] = { CTL_KERN, KERN_PROC, KERN_PROC_ARGS, kinfo.ki_pid };
 
-    length = 0;
-    if (sysctl(mib, arraysize(mib), NULL, &length, NULL, 0) < 0) {
-      LOG(ERROR) << "failed to figure out the buffer size for a command line";
+    if ((kinfo.ki_pid > 0) && (kinfo.ki_stat == SZOMB))
       continue;
-    }
-
-    data.resize(length);
-
+#endif
+    data.resize(ARG_MAX);
+    length = ARG_MAX;
     if (sysctl(mib, arraysize(mib), &data[0], &length, NULL, 0) < 0) {
       LOG(ERROR) << "failed to fetch a commandline";
       continue;
@@ -101,9 +106,15 @@ bool ProcessIterator::CheckForNextProcess() {
       continue;
     }
 
+#if defined(OS_DRAGONFLY)
+    entry_.pid_ = kinfo.kp_pid;
+    entry_.ppid_ = kinfo.kp_ppid;
+    entry_.gid_ = kinfo.kp_pgid;
+#else
     entry_.pid_ = kinfo.ki_pid;
     entry_.ppid_ = kinfo.ki_ppid;
     entry_.gid_ = kinfo.ki_pgid;
+#endif
 
     size_t last_slash = data.rfind('/', exec_name_end);
     if (last_slash == std::string::npos) {
diff --git base/process/process_metrics.cc base/process/process_metrics.cc
index c3a70633a3..65a70c7f59 100644
--- base/process/process_metrics.cc
+++ base/process/process_metrics.cc
@@ -10,7 +10,7 @@
 #include "base/values.h"
 #include "build/build_config.h"
 
-#if defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_AIX)
+#if defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_AIX) || defined(OS_BSD)
 namespace {
 int CalculateEventsPerSecond(uint64_t event_count,
                              uint64_t* last_event_count,
@@ -97,7 +97,7 @@ std::unique_ptr<ProcessMetrics> ProcessMetrics::CreateCurrentProcessMetrics() {
 #endif  // !defined(OS_MACOSX) || defined(OS_IOS)
 }
 
-#if !defined(OS_FREEBSD) || !defined(OS_POSIX)
+#if (!defined(OS_FREEBSD) && !defined(OS_DRAGONFLY)) || !defined(OS_POSIX)
 double ProcessMetrics::GetPlatformIndependentCPUUsage() {
   TimeDelta cumulative_cpu = GetCumulativeCPUUsage();
   TimeTicks time = TimeTicks::Now();
diff --git base/process/process_metrics.h base/process/process_metrics.h
index 0170a0c2db..38941e457d 100644
--- base/process/process_metrics.h
+++ base/process/process_metrics.h
@@ -41,7 +41,7 @@ namespace base {
 // Full declaration is in process_metrics_iocounters.h.
 struct IoCounters;
 
-#if defined(OS_LINUX) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_BSD)
 // Minor and major page fault counts since the process creation.
 // Both counts are process-wide, and exclude child processes.
 //
@@ -51,7 +51,7 @@ struct PageFaultCounts {
   int64_t minor;
   int64_t major;
 };
-#endif  // defined(OS_LINUX) || defined(OS_ANDROID)
+#endif  // defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_BSD)
 
 // Convert a POSIX timeval to microseconds.
 BASE_EXPORT int64_t TimeValToMicroseconds(const struct timeval& tv);
@@ -177,7 +177,7 @@ class BASE_EXPORT ProcessMetrics {
   // otherwise.
   bool GetIOCounters(IoCounters* io_counters) const;
 
-#if defined(OS_LINUX) || defined(OS_AIX) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_AIX) || defined(OS_ANDROID) || defined(OS_BSD)
   // Returns the number of file descriptors currently open by the process, or
   // -1 on error.
   int GetOpenFdCount() const;
@@ -185,16 +185,16 @@ class BASE_EXPORT ProcessMetrics {
   // Returns the soft limit of file descriptors that can be opened by the
   // process, or -1 on error.
   int GetOpenFdSoftLimit() const;
-#endif  // defined(OS_LINUX) || defined(OS_AIX) || defined(OS_ANDROID)
+#endif  // defined(OS_LINUX) || defined(OS_AIX) || defined(OS_ANDROID) || defined(OS_BSD)
 
-#if defined(OS_LINUX) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_BSD)
   // Bytes of swap as reported by /proc/[pid]/status.
   uint64_t GetVmSwapBytes() const;
 
   // Minor and major page fault count as reported by /proc/[pid]/stat.
   // Returns true for success.
   bool GetPageFaultCounts(PageFaultCounts* counts) const;
-#endif  // defined(OS_LINUX) || defined(OS_ANDROID)
+#endif  // defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_BSD)
 
   // Returns total memory usage of malloc.
   size_t GetMallocUsage();
@@ -206,7 +206,7 @@ class BASE_EXPORT ProcessMetrics {
   ProcessMetrics(ProcessHandle process, PortProvider* port_provider);
 #endif  // !defined(OS_MACOSX) || defined(OS_IOS)
 
-#if defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_AIX)
+#if defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_AIX) || defined(OS_BSD)
   int CalculateIdleWakeupsPerSecond(uint64_t absolute_idle_wakeups);
 #endif
 #if defined(OS_MACOSX)
@@ -229,7 +229,7 @@ class BASE_EXPORT ProcessMetrics {
   TimeDelta last_cumulative_cpu_;
 #endif
 
-#if defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_AIX)
+#if defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_AIX) || defined(OS_BSD)
   // Same thing for idle wakeups.
   TimeTicks last_idle_wakeups_time_;
   uint64_t last_absolute_idle_wakeups_;
@@ -250,6 +250,10 @@ class BASE_EXPORT ProcessMetrics {
 #endif  // defined(OS_MACOSX)
 #endif  // !defined(OS_IOS)
 
+#if defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
+  int fscale_;
+#endif
+
   DISALLOW_COPY_AND_ASSIGN(ProcessMetrics);
 };
 
@@ -275,7 +279,7 @@ BASE_EXPORT void IncreaseFdLimitTo(unsigned int max_descriptors);
 #endif  // defined(OS_POSIX) && !defined(OS_FUCHSIA)
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_ANDROID) || defined(OS_AIX) || defined(OS_FUCHSIA)
+    defined(OS_ANDROID) || defined(OS_AIX) || defined(OS_FUCHSIA) || defined(OS_BSD)
 // Data about system-wide memory consumption. Values are in KB. Available on
 // Windows, Mac, Linux, Android and Chrome OS.
 //
@@ -308,7 +312,7 @@ struct BASE_EXPORT SystemMemoryInfoKB {
   int avail_phys = 0;
 #endif
 
-#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_AIX)
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_AIX) || defined(OS_BSD)
   // This provides an estimate of available memory as described here:
   // https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=34e431b0ae398fc54ea69ff85ec700722c9da773
   // NOTE: this is ONLY valid in kernels 3.14 and up.  Its value will always
@@ -323,7 +327,7 @@ struct BASE_EXPORT SystemMemoryInfoKB {
 #endif
 
 #if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_AIX) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_BSD)
   int buffers = 0;
   int cached = 0;
   int active_anon = 0;
@@ -333,7 +337,7 @@ struct BASE_EXPORT SystemMemoryInfoKB {
   int dirty = 0;
   int reclaimable = 0;
 #endif  // defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_AIX) ||
-        // defined(OS_FUCHSIA)
+        // defined(OS_FUCHSIA) || defined(OS_BSD)
 
 #if defined(OS_CHROMEOS)
   int shmem = 0;
@@ -361,7 +365,7 @@ BASE_EXPORT bool GetSystemMemoryInfo(SystemMemoryInfoKB* meminfo);
 #endif  // defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) ||
         // defined(OS_ANDROID) || defined(OS_AIX) || defined(OS_FUCHSIA)
 
-#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_AIX)
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_AIX) || defined(OS_BSD)
 // Parse the data found in /proc/<pid>/stat and return the sum of the
 // CPU-related ticks.  Returns -1 on parse error.
 // Exposed for testing.
diff --git base/process/process_metrics_freebsd.cc base/process/process_metrics_freebsd.cc
index a552c033dd..7cc882fcfb 100644
--- base/process/process_metrics_freebsd.cc
+++ base/process/process_metrics_freebsd.cc
@@ -14,11 +14,26 @@
 #include "base/process/process_metrics_iocounters.h"
 #include "base/stl_util.h"
 
+#include <unistd.h> /* getpagesize() */
+#include <fcntl.h>  /* O_RDONLY */
+#include <kvm.h>
+
 namespace base {
 
 ProcessMetrics::ProcessMetrics(ProcessHandle process)
-    : process_(process),
-      last_cpu_(0) {}
+    : process_(process) {
+#if defined(OS_DRAGONFLY)
+  size_t len = sizeof(int);
+  int val;
+
+  if (sysctlbyname("kern.fscale", &val, &len, NULL, 0) == 0) {
+    fscale_ = val;
+    return;
+  }
+#else
+  fscale_ = FSCALE;
+#endif
+}
 
 // static
 std::unique_ptr<ProcessMetrics> ProcessMetrics::CreateProcessMetrics(
@@ -27,14 +42,48 @@ std::unique_ptr<ProcessMetrics> ProcessMetrics::CreateProcessMetrics(
 }
 
 double ProcessMetrics::GetPlatformIndependentCPUUsage() {
+#if defined(__DragonFly__)
+  std::vector<kinfo_proc> kinfo_procs;
+  int mib[] = {
+    CTL_KERN, KERN_PROC, KERN_PROC_PID + KERN_PROC_FLAG_LWP, process_
+  };
+  size_t length = 0;
+  int sum, st;
+  unsigned int i;
+#else
   struct kinfo_proc info;
   int mib[] = {CTL_KERN, KERN_PROC, KERN_PROC_PID, process_};
   size_t length = sizeof(info);
+#endif
 
-  if (sysctl(mib, base::size(mib), &info, &length, NULL, 0) < 0)
+#if defined(__DragonFly__)
+  if (sysctl(mib, arraysize(mib), NULL, &length, NULL, 0) < 0 || length == 0)
     return 0;
 
-  return (info.ki_pctcpu / FSCALE) * 100.0;
+  kinfo_procs.resize(length / sizeof(struct kinfo_proc) + 1);
+  do {
+    length = kinfo_procs.size() * sizeof(struct kinfo_proc);
+    st = sysctl(mib, arraysize(mib), kinfo_procs.data(), &length, NULL, 0);
+    if (st < 0) {
+      if (errno == ENOMEM) {
+        kinfo_procs.resize(length / sizeof(struct kinfo_proc) + 4);
+      } else {
+        return 0;
+      }
+    }
+  } while (st != 0);
+
+  kinfo_procs.resize(length / sizeof(struct kinfo_proc));
+  sum = 0;
+  for (i = 0; i < kinfo_procs.size(); i++)
+    sum += kinfo_procs[i].kp_lwp.kl_pctcpu;
+  return ((double)sum / fscale_) * 100.0;
+#else
+  if (sysctl(mib, arraysize(mib), &info, &length, NULL, 0) < 0 || length == 0)
+    return 0;
+
+  return ((double)info.ki_pctcpu / fscale_) * 100.0;
+#endif
 }
 
 TimeDelta ProcessMetrics::GetCumulativeCPUUsage() {
@@ -47,26 +96,89 @@ bool ProcessMetrics::GetIOCounters(IoCounters* io_counters) const {
 }
 
 size_t GetSystemCommitCharge() {
-  int mib[2], pagesize;
+  int pagesize;
+#if defined(OS_DRAGONFLY)
+  unsigned int mem_total, mem_free, mem_inactive;
+#else
   unsigned long mem_total, mem_free, mem_inactive;
+#endif
   size_t length = sizeof(mem_total);
 
-  if (sysctl(mib, base::size(mib), &mem_total, &length, NULL, 0) < 0)
+  if (sysctlbyname("vm.stats.vm.v_page_count", &mem_total, &length, NULL, 0) != 0)
     return 0;
 
   length = sizeof(mem_free);
-  if (sysctlbyname("vm.stats.vm.v_free_count", &mem_free, &length, NULL, 0) < 0)
+  if (sysctlbyname("vm.stats.vm.v_free_count", &mem_free, &length, NULL, 0) != 0)
     return 0;
 
   length = sizeof(mem_inactive);
   if (sysctlbyname("vm.stats.vm.v_inactive_count", &mem_inactive, &length,
-      NULL, 0) < 0) {
+      NULL, 0) != 0) {
     return 0;
   }
 
   pagesize = getpagesize();
 
-  return mem_total - (mem_free*pagesize) - (mem_inactive*pagesize);
+  return (mem_total - mem_free - mem_inactive) * pagesize;
+}
+
+int GetNumberOfThreads(ProcessHandle process) {
+  // Taken from FreeBSD top (usr.bin/top/machine.c)
+
+  kvm_t* kd = kvm_open(NULL, "/dev/null", NULL, O_RDONLY, "kvm_open");
+  if (kd == NULL)
+    return 0;
+
+  struct kinfo_proc* pbase;
+  int nproc;
+  pbase = kvm_getprocs(kd, KERN_PROC_PID, process, &nproc);
+  if (pbase == NULL)
+    return 0;
+
+  if (kvm_close(kd) == -1)
+    return 0;
+
+  return nproc;
+}
+
+bool GetSystemMemoryInfo(SystemMemoryInfoKB *meminfo) {
+  unsigned int mem_total, mem_free, swap_total, swap_used;
+  size_t length;
+  int pagesizeKB;
+
+  pagesizeKB = getpagesize() / 1024;
+
+  length = sizeof(mem_total);
+  if (sysctlbyname("vm.stats.vm.v_page_count", &mem_total,
+      &length, NULL, 0) != 0 || length != sizeof(mem_total))
+    return false;
+
+  length = sizeof(mem_free);
+  if (sysctlbyname("vm.stats.vm.v_free_count", &mem_free, &length, NULL, 0)
+      != 0 || length != sizeof(mem_free))
+    return false;
+
+  length = sizeof(swap_total);
+  if (sysctlbyname("vm.swap_size", &swap_total, &length, NULL, 0)
+      != 0 || length != sizeof(swap_total))
+    return false;
+
+  length = sizeof(swap_used);
+  if (sysctlbyname("vm.swap_anon_use", &swap_used, &length, NULL, 0)
+      != 0 || length != sizeof(swap_used))
+    return false;
+
+  meminfo->total = mem_total * pagesizeKB;
+  meminfo->free = mem_free * pagesizeKB;
+  meminfo->swap_total = swap_total * pagesizeKB;
+  meminfo->swap_free = (swap_total - swap_used) * pagesizeKB;
+
+  return true;
+}
+
+uint64_t ProcessMetrics::GetVmSwapBytes() const {
+   NOTIMPLEMENTED();
+   return 0;
 }
 
 }  // namespace base
diff --git base/process/process_metrics_posix.cc base/process/process_metrics_posix.cc
index a09bbf2c56..3d2e96266c 100644
--- base/process/process_metrics_posix.cc
+++ base/process/process_metrics_posix.cc
@@ -19,6 +19,8 @@
 
 #if defined(OS_MACOSX)
 #include <malloc/malloc.h>
+#elif defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
+#include <stdlib.h>
 #else
 #include <malloc.h>
 #endif
@@ -42,7 +44,8 @@ static const rlim_t kSystemDefaultMaxFds = 8192;
 static const rlim_t kSystemDefaultMaxFds = 256;
 #elif defined(OS_SOLARIS)
 static const rlim_t kSystemDefaultMaxFds = 8192;
-#elif defined(OS_FREEBSD)
+#elif defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
+/* Not sure if this is true on DragonFly. */
 static const rlim_t kSystemDefaultMaxFds = 8192;
 #elif defined(OS_NETBSD)
 static const rlim_t kSystemDefaultMaxFds = 1024;
@@ -107,7 +110,7 @@ size_t ProcessMetrics::GetMallocUsage() {
 #else
   return minfo.hblkhd + minfo.arena;
 #endif
-#elif defined(OS_FUCHSIA)
+#elif defined(OS_FUCHSIA) || defined(OS_BSD)
   // TODO(fuchsia): Not currently exposed. https://crbug.com/735087.
   return 0;
 #endif
diff --git base/process/process_posix.cc base/process/process_posix.cc
index 7645b78b19..cb51f8b41b 100644
--- base/process/process_posix.cc
+++ base/process/process_posix.cc
@@ -22,8 +22,17 @@
 #include <sys/event.h>
 #endif
 
+#if defined(OS_BSD)
+#include <sys/types.h>
+#include <sys/event.h>
+#include <sys/time.h>
+#endif
+
 namespace {
 
+const int kBackgroundPriority = 5;
+const int kForegroundPriority = 0;
+
 #if !defined(OS_NACL_NONSFI)
 
 bool WaitpidWithTimeout(base::ProcessHandle handle,
@@ -265,12 +274,10 @@ Process Process::DeprecatedGetProcessFromHandle(ProcessHandle handle) {
   return Process(handle);
 }
 
-#if !defined(OS_LINUX) && !defined(OS_MACOSX) && !defined(OS_AIX)
 // static
 bool Process::CanBackgroundProcesses() {
-  return false;
+  return true;
 }
-#endif  // !defined(OS_LINUX) && !defined(OS_MACOSX) && !defined(OS_AIX)
 
 // static
 void Process::TerminateCurrentProcessImmediately(int exit_code) {
@@ -354,21 +361,23 @@ bool Process::WaitForExitWithTimeout(TimeDelta timeout, int* exit_code) const {
 
 void Process::Exited(int exit_code) const {}
 
-#if !defined(OS_LINUX) && !defined(OS_MACOSX) && !defined(OS_AIX)
 bool Process::IsProcessBackgrounded() const {
   // See SetProcessBackgrounded().
   DCHECK(IsValid());
-  return false;
+  return GetPriority() == kBackgroundPriority;
 }
 
-bool Process::SetProcessBackgrounded(bool value) {
-  // Not implemented for POSIX systems other than Linux and Mac. With POSIX, if
-  // we were to lower the process priority we wouldn't be able to raise it back
-  // to its initial priority.
-  NOTIMPLEMENTED();
-  return false;
+bool Process::SetProcessBackgrounded(bool background) {
+  DCHECK(IsValid());
+
+  if (!CanBackgroundProcesses())
+    return false;
+
+  int priority = background ? kBackgroundPriority : kForegroundPriority;
+  int result = setpriority(PRIO_PROCESS, process_, priority);
+  DPCHECK(result == 0);
+  return result == 0;
 }
-#endif  // !defined(OS_LINUX) && !defined(OS_MACOSX) && !defined(OS_AIX)
 
 int Process::GetPriority() const {
   DCHECK(IsValid());
diff --git base/profiler/stack_sampling_profiler_unittest.cc base/profiler/stack_sampling_profiler_unittest.cc
index 8fc25c92c1..0b50bbf790 100644
--- base/profiler/stack_sampling_profiler_unittest.cc
+++ base/profiler/stack_sampling_profiler_unittest.cc
@@ -36,7 +36,7 @@
 #include <intrin.h>
 #include <malloc.h>
 #include <windows.h>
-#else
+#elif !defined(OS_BSD)
 #include <alloca.h>
 #endif
 
diff --git base/security_unittest.cc base/security_unittest.cc
index 13e9594e2d..6a2eebe899 100644
--- base/security_unittest.cc
+++ base/security_unittest.cc
@@ -59,7 +59,7 @@ NOINLINE Type HideValueFromCompiler(volatile Type value) {
 // FAILS_ is too clunky.
 void OverflowTestsSoftExpectTrue(bool overflow_detected) {
   if (!overflow_detected) {
-#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_MACOSX)
+#if defined(OS_POSIX) && !defined(OS_NACL)
     // Sadly, on Linux, Android, and OSX we don't have a good story yet. Don't
     // fail the test, but report.
     printf("Platform has overflow: %s\n",
diff --git base/sys_info_freebsd.cc base/sys_info_freebsd.cc
index 85916559f2..e83c78fe6f 100644
--- base/sys_info_freebsd.cc
+++ base/sys_info_freebsd.cc
@@ -13,26 +13,58 @@
 namespace base {
 
 int64_t SysInfo::AmountOfPhysicalMemoryImpl() {
-  int pages, page_size;
+  int pages, page_size, r = 0;
   size_t size = sizeof(pages);
-  sysctlbyname("vm.stats.vm.v_page_count", &pages, &size, NULL, 0);
-  sysctlbyname("vm.stats.vm.v_page_size", &page_size, &size, NULL, 0);
-  if (pages == -1 || page_size == -1) {
+  if(r == 0)
+    r = sysctlbyname("vm.stats.vm.v_page_count", &pages, &size, NULL, 0);
+  if(r == 0)
+    r =sysctlbyname("vm.stats.vm.v_page_size", &page_size, &size, NULL, 0);
+  if(r == -1) {
     NOTREACHED();
     return 0;
   }
   return static_cast<int64_t>(pages) * page_size;
 }
 
-// static
-uint64_t SysInfo::MaxSharedMemorySize() {
-  size_t limit;
-  size_t size = sizeof(limit);
-  if (sysctlbyname("kern.ipc.shmmax", &limit, &size, NULL, 0) < 0) {
+int64_t SysInfo::AmountOfAvailablePhysicalMemoryImpl() {
+  int page_size, r = 0;
+  unsigned pgfree, pginact, pgcache;
+  size_t size = sizeof(page_size);
+  size_t szpg = sizeof(pgfree);
+  if(r == 0)
+    r = sysctlbyname("vm.stats.vm.v_page_size", &page_size, &size, NULL, 0);
+  if(r == 0)
+    r = sysctlbyname("vm.stats.vm.v_free_count", &pgfree, &szpg, NULL, 0);
+  if(r == 0)
+    r = sysctlbyname("vm.stats.vm.v_inactive_count", &pginact, &szpg, NULL, 0);
+  if(r == 0)
+    r = sysctlbyname("vm.stats.vm.v_cache_count", &pgcache, &szpg, NULL, 0);
+  if(r == -1) {
     NOTREACHED();
     return 0;
   }
-  return static_cast<uint64_t>(limit);
+  return static_cast<int64_t>((pgfree + pginact + pgcache) * page_size);
+}
+
+// static
+std::string SysInfo::CPUModelName() {
+  int mib[] = { CTL_HW, HW_MODEL };
+  char name[256];
+  size_t size = arraysize(name);
+  if (sysctl(mib, arraysize(mib), &name, &size, NULL, 0) == 0)
+    return name;
+  return std::string();
+}
+
+int SysInfo::NumberOfProcessors() {
+  int mib[] = { CTL_HW, HW_NCPU };
+  int ncpu;
+  size_t size = sizeof(ncpu);
+  if (sysctl(mib, arraysize(mib), &ncpu, &size, NULL, 0) == -1) {
+    NOTREACHED();
+    return 1;
+  }
+  return ncpu;
 }
 
 }  // namespace base
diff --git base/sys_info_posix.cc base/sys_info_posix.cc
index f6fcd10fff..26c210914c 100644
--- base/sys_info_posix.cc
+++ base/sys_info_posix.cc
@@ -38,7 +38,7 @@
 
 namespace {
 
-#if !defined(OS_OPENBSD) && !defined(OS_FUCHSIA)
+#if !defined(OS_BSD) && !defined(OS_FUCHSIA)
 int NumberOfProcessors() {
   // sysconf returns the number of "logical" (not "physical") processors on both
   // Mac and Linux.  So we get the number of max available "logical" processors.
@@ -65,7 +65,7 @@ int NumberOfProcessors() {
 base::LazyInstance<
     base::internal::LazySysInfoValue<int, NumberOfProcessors> >::Leaky
     g_lazy_number_of_processors = LAZY_INSTANCE_INITIALIZER;
-#endif  // !defined(OS_OPENBSD) && !defined(OS_FUCHSIA)
+#endif  // !defined(OS_BSD) && !defined(OS_FUCHSIA)
 
 #if !defined(OS_FUCHSIA)
 int64_t AmountOfVirtualMemory() {
@@ -133,7 +133,7 @@ bool GetDiskSpaceInfo(const base::FilePath& path,
 
 namespace base {
 
-#if !defined(OS_OPENBSD) && !defined(OS_FUCHSIA)
+#if !defined(OS_BSD) && !defined(OS_FUCHSIA)
 int SysInfo::NumberOfProcessors() {
   return g_lazy_number_of_processors.Get().value();
 }
@@ -226,6 +226,8 @@ std::string SysInfo::OperatingSystemArchitecture() {
     arch = "x86";
   } else if (arch == "amd64") {
     arch = "x86_64";
+  } else if (arch == "arm64") {
+    arch = "aarch64";
   } else if (std::string(info.sysname) == "AIX") {
     arch = "ppc64";
   }
diff --git base/task_scheduler/scheduler_single_thread_task_runner_manager_unittest.cc base/task_scheduler/scheduler_single_thread_task_runner_manager_unittest.cc
index 52d99f6e83..b16ab44cd0 100644
--- base/task_scheduler/scheduler_single_thread_task_runner_manager_unittest.cc
+++ base/task_scheduler/scheduler_single_thread_task_runner_manager_unittest.cc
@@ -301,6 +301,9 @@ TEST_P(TaskSchedulerSingleThreadTaskRunnerManagerCommonTest,
   EXPECT_EQ(ThreadPriority::NORMAL, thread_priority_normal);
 }
 
+#if defined(OS_BSD)
+#define ThreadNamesSet DISABLED_ThreadNamesSet
+#endif
 TEST_P(TaskSchedulerSingleThreadTaskRunnerManagerCommonTest, ThreadNamesSet) {
   constexpr TaskTraits foo_traits = {TaskPriority::BACKGROUND,
                                      TaskShutdownBehavior::BLOCK_SHUTDOWN};
diff --git base/test/launcher/test_launcher.cc base/test/launcher/test_launcher.cc
index d3d986c49c..79e842f790 100644
--- base/test/launcher/test_launcher.cc
+++ base/test/launcher/test_launcher.cc
@@ -52,6 +52,7 @@
 #include "testing/gtest/include/gtest/gtest.h"
 
 #if defined(OS_POSIX)
+#include <signal.h>
 #include <fcntl.h>
 
 #include "base/files/file_descriptor_watcher_posix.h"
diff --git base/test/test_file_util_linux.cc base/test/test_file_util_linux.cc
index cf8b056272..cd599778d9 100644
--- base/test/test_file_util_linux.cc
+++ base/test/test_file_util_linux.cc
@@ -51,8 +51,10 @@ bool EvictFileFromSystemCache(const FilePath& file) {
     return false;
   if (fdatasync(fd.get()) != 0)
     return false;
+#if !defined(OS_BSD)
   if (posix_fadvise(fd.get(), 0, 0, POSIX_FADV_DONTNEED) != 0)
     return false;
+#endif
   return true;
 }
 
diff --git base/test/test_file_util_posix.cc base/test/test_file_util_posix.cc
index 87290fb3a2..e05afdf7df 100644
--- base/test/test_file_util_posix.cc
+++ base/test/test_file_util_posix.cc
@@ -79,7 +79,7 @@ bool DieFileDie(const FilePath& file, bool recurse) {
   return DeleteFile(file, recurse);
 }
 
-#if !defined(OS_LINUX) && !defined(OS_MACOSX) && !defined(OS_ANDROID)
+#if !defined(OS_LINUX) && !defined(OS_MACOSX) && !defined(OS_ANDROID) && !defined(OS_BSD)
 bool EvictFileFromSystemCache(const FilePath& file) {
   // There doesn't seem to be a POSIX way to cool the disk cache.
   NOTIMPLEMENTED();
diff --git base/third_party/libevent/BUILD.gn base/third_party/libevent/BUILD.gn
index e934454a10..4f020a9291 100644
--- base/third_party/libevent/BUILD.gn
+++ base/third_party/libevent/BUILD.gn
@@ -43,13 +43,20 @@ static_library("libevent") {
       "mac/event-config.h",
     ]
     include_dirs = [ "mac" ]
-  } else if (is_linux) {
+  } else if (is_linux && !is_bsd) {
     sources += [
       "epoll.c",
       "linux/config.h",
       "linux/event-config.h",
     ]
     include_dirs = [ "linux" ]
+  } else if (is_bsd) {
+    sources += [ 
+      "kqueue.c",
+      "freebsd/config.h",
+      "freebsd/event-config.h",
+    ]
+    include_dirs = [ "freebsd" ]
   } else if (is_android) {
     sources += [
       "android/config.h",
diff --git base/third_party/libevent/event-config.h base/third_party/libevent/event-config.h
index bbd23f1d81..3d9950cc1a 100644
--- base/third_party/libevent/event-config.h
+++ base/third_party/libevent/event-config.h
@@ -13,7 +13,7 @@
 #include "base/third_party/libevent/android/event-config.h"
 #elif defined(__linux__)
 #include "base/third_party/libevent/linux/event-config.h"
-#elif defined(__FreeBSD__)
+#elif defined(__FreeBSD__) || defined(__DragonFly__)
 #include "base/third_party/libevent/freebsd/event-config.h"
 #elif defined(__sun)
 #include "base/third_party/libevent/solaris/event-config.h"
diff --git base/threading/platform_thread.h base/threading/platform_thread.h
index faeb858b7c..b246364f76 100644
--- base/threading/platform_thread.h
+++ base/threading/platform_thread.h
@@ -36,8 +36,10 @@ typedef DWORD PlatformThreadId;
 typedef zx_handle_t PlatformThreadId;
 #elif defined(OS_MACOSX)
 typedef mach_port_t PlatformThreadId;
-#elif defined(OS_POSIX)
+#elif defined(OS_POSIX) && !defined(OS_DRAGONFLY)
 typedef pid_t PlatformThreadId;
+#elif defined(OS_DRAGONFLY)
+typedef lwpid_t PlatformThreadId;
 #endif
 
 // Used for thread checking and debugging.
@@ -217,7 +219,7 @@ class BASE_EXPORT PlatformThread {
 
   static ThreadPriority GetCurrentThreadPriority();
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // Toggles a specific thread's priority at runtime. This can be used to
   // change the priority of a thread in a different process and will fail
   // if the calling process does not have proper permissions. The
diff --git base/threading/platform_thread_internal_posix.h base/threading/platform_thread_internal_posix.h
index 5f4a215968..f8bb7250cb 100644
--- base/threading/platform_thread_internal_posix.h
+++ base/threading/platform_thread_internal_posix.h
@@ -7,6 +7,9 @@
 
 #include "base/base_export.h"
 #include "base/threading/platform_thread.h"
+#if defined(OS_DRAGONFLY)
+#include <sys/rtprio.h>
+#endif
 
 namespace base {
 
diff --git base/threading/platform_thread_linux.cc base/threading/platform_thread_linux.cc
index 190acedf7c..0380256f38 100644
--- base/threading/platform_thread_linux.cc
+++ base/threading/platform_thread_linux.cc
@@ -18,7 +18,9 @@
 
 #if !defined(OS_NACL) && !defined(OS_AIX)
 #include <pthread.h>
+#if !defined(OS_BSD)
 #include <sys/prctl.h>
+#endif
 #include <sys/resource.h>
 #include <sys/time.h>
 #include <sys/types.h>
@@ -128,7 +130,7 @@ bool GetCurrentThreadPriorityForPlatform(ThreadPriority* priority) {
 void PlatformThread::SetName(const std::string& name) {
   ThreadIdNameManager::GetInstance()->SetName(name);
 
-#if !defined(OS_NACL) && !defined(OS_AIX)
+#if !defined(OS_NACL) && !defined(OS_AIX) && !defined(OS_BSD)
   // On linux we can get the thread names to show up in the debugger by setting
   // the process name for the LWP.  We don't want to do this for the main
   // thread because that would rename the process, causing tools like killall
diff --git base/threading/platform_thread_posix.cc base/threading/platform_thread_posix.cc
index 2466b784d1..cc1ed2f437 100644
--- base/threading/platform_thread_posix.cc
+++ base/threading/platform_thread_posix.cc
@@ -13,6 +13,10 @@
 #include <sys/types.h>
 #include <unistd.h>
 
+#if defined(OS_DRAGONFLY)
+#include <pthread_np.h>
+#endif
+
 #include <memory>
 
 #include "base/debug/activity_tracker.h"
@@ -61,7 +65,7 @@ void* ThreadFunc(void* params) {
     if (!thread_params->joinable)
       base::ThreadRestrictions::SetSingletonAllowed(false);
 
-#if !defined(OS_NACL)
+#if !defined(OS_NACL) && !defined(OS_BSD)
     // Threads on linux/android may inherit their priority from the thread
     // where they were created. This explicitly sets the priority of all new
     // threads.
@@ -151,6 +155,8 @@ PlatformThreadId PlatformThread::CurrentId() {
 #elif defined(OS_NACL) && !defined(__GLIBC__)
   // Pointers are 32-bits in NaCl.
   return reinterpret_cast<int32_t>(pthread_self());
+#elif defined(OS_DRAGONFLY)
+  return pthread_getthreadid_np();
 #elif defined(OS_POSIX) && defined(OS_AIX)
   return pthread_self();
 #elif defined(OS_POSIX) && !defined(OS_AIX)
@@ -278,6 +284,14 @@ ThreadPriority PlatformThread::GetCurrentThreadPriority() {
 #if defined(OS_NACL)
   NOTIMPLEMENTED();
   return ThreadPriority::NORMAL;
+#elif defined(OS_DRAGONFLY)
+  // Mirrors SetCurrentThreadPriority()'s implementation.
+  ThreadPriority platform_specific_priority;
+  if (internal::GetCurrentThreadPriorityForPlatform(
+          &platform_specific_priority)) {
+    return platform_specific_priority;
+  }
+  return ThreadPriority::NORMAL;
 #else
   // Mirrors SetCurrentThreadPriority()'s implementation.
   ThreadPriority platform_specific_priority;
diff --git base/threading/thread_task_runner_handle.cc base/threading/thread_task_runner_handle.cc
index 314b303929..462cf6512d 100644
--- base/threading/thread_task_runner_handle.cc
+++ base/threading/thread_task_runner_handle.cc
@@ -7,6 +7,7 @@
 #include <utility>
 
 #include "base/bind.h"
+#include "base/callback_helpers.h"
 #include "base/lazy_instance.h"
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
@@ -37,6 +38,7 @@ bool ThreadTaskRunnerHandle::IsSet() {
   return !!thread_task_runner_tls.Pointer()->Get();
 }
 
+#if defined(OS_BSD)
 // static
 ScopedClosureRunner ThreadTaskRunnerHandle::OverrideForTesting(
     scoped_refptr<SingleThreadTaskRunner> overriding_task_runner) {
@@ -86,6 +88,7 @@ ScopedClosureRunner ThreadTaskRunnerHandle::OverrideForTesting(
       base::Unretained(ttrh->task_runner_.get()),
       std::move(no_running_during_override)));
 }
+#endif
 
 ThreadTaskRunnerHandle::ThreadTaskRunnerHandle(
     scoped_refptr<SingleThreadTaskRunner> task_runner)
diff --git base/trace_event/malloc_dump_provider.cc base/trace_event/malloc_dump_provider.cc
index 46fdb3e214..30b3428e38 100644
--- base/trace_event/malloc_dump_provider.cc
+++ base/trace_event/malloc_dump_provider.cc
@@ -17,6 +17,8 @@
 
 #if defined(OS_MACOSX)
 #include <malloc/malloc.h>
+#elif defined(OS_BSD)
+#include "stdlib.h"
 #else
 #include <malloc.h>
 #endif
@@ -132,6 +134,9 @@ bool MallocDumpProvider::OnMemoryDump(const MemoryDumpArgs& args,
   }
 #elif defined(OS_FUCHSIA)
 // TODO(fuchsia): Port, see https://crbug.com/706592.
+#elif defined(OS_BSD)
+  total_virtual_size = 0;
+  allocated_objects_size = 0;
 #else
   struct mallinfo info = mallinfo();
   DCHECK_GE(info.arena + info.hblkhd, info.uordblks);
diff --git base/trace_event/process_memory_dump.cc base/trace_event/process_memory_dump.cc
index 744257899e..d59adaf62d 100644
--- base/trace_event/process_memory_dump.cc
+++ base/trace_event/process_memory_dump.cc
@@ -95,7 +95,7 @@ size_t ProcessMemoryDump::CountResidentBytes(void* start_address,
 #if defined(OS_WIN)
   std::unique_ptr<PSAPI_WORKING_SET_EX_INFORMATION[]> vec(
       new PSAPI_WORKING_SET_EX_INFORMATION[max_vec_size]);
-#elif defined(OS_MACOSX)
+#elif defined(OS_MACOSX) || defined(OS_BSD)
   std::unique_ptr<char[]> vec(new char[max_vec_size]);
 #elif defined(OS_POSIX) || defined(OS_FUCHSIA)
   std::unique_ptr<unsigned char[]> vec(new unsigned char[max_vec_size]);
diff --git base/trace_event/process_memory_dump.h base/trace_event/process_memory_dump.h
index a732a2623c..3261996891 100644
--- base/trace_event/process_memory_dump.h
+++ base/trace_event/process_memory_dump.h
@@ -22,7 +22,7 @@
 
 // Define COUNT_RESIDENT_BYTES_SUPPORTED if platform supports counting of the
 // resident memory.
-#if !defined(OS_NACL)
+#if !defined(OS_NACL) && !defined(OS_BSD)
 #define COUNT_RESIDENT_BYTES_SUPPORTED
 #endif
 
diff --git build/build_config.h build/build_config.h
index c7b02664c8..4d630f7b78 100644
--- build/build_config.h
+++ build/build_config.h
@@ -57,6 +57,8 @@
 #define OS_NETBSD 1
 #elif defined(__OpenBSD__)
 #define OS_OPENBSD 1
+#elif defined(__DragonFly__)
+#define OS_DRAGONFLY 1
 #elif defined(__sun)
 #define OS_SOLARIS 1
 #elif defined(__QNXNTO__)
@@ -73,7 +75,8 @@
 
 // For access to standard BSD features, use OS_BSD instead of a
 // more specific macro.
-#if defined(OS_FREEBSD) || defined(OS_NETBSD) || defined(OS_OPENBSD)
+#if defined(OS_FREEBSD) || defined(OS_NETBSD) || defined(OS_OPENBSD) || \
+    defined(OS_DRAGONFLY)
 #define OS_BSD 1
 #endif
 
@@ -82,7 +85,7 @@
 #if defined(OS_AIX) || defined(OS_ANDROID) || defined(OS_ASMJS) ||    \
     defined(OS_FREEBSD) || defined(OS_LINUX) || defined(OS_MACOSX) || \
     defined(OS_NACL) || defined(OS_NETBSD) || defined(OS_OPENBSD) ||  \
-    defined(OS_QNX) || defined(OS_SOLARIS)
+    defined(OS_QNX) || defined(OS_SOLARIS) || defined(OS_DRAGONFLY)
 #define OS_POSIX 1
 #endif
 
diff --git build/config/BUILD.gn build/config/BUILD.gn
index 4ba4d3367e..724fa7ac45 100644
--- build/config/BUILD.gn
+++ build/config/BUILD.gn
@@ -167,7 +167,7 @@ config("debug") {
       # builds, and we have to tell it to turn it off.
       defines += [ "_HAS_ITERATOR_DEBUGGING=0" ]
     }
-  } else if (is_linux && current_cpu == "x64" && enable_iterator_debugging) {
+  } else if ((is_linux || is_bsd) && current_cpu == "x64" && enable_iterator_debugging) {
     # Enable libstdc++ debugging facilities to help catch problems early, see
     # http://crbug.com/65151 .
     # TODO(phajdan.jr): Should we enable this for all of POSIX?
@@ -269,9 +269,7 @@ config("default_libs") {
     ]
   } else if (is_linux) {
     libs = [
-      "dl",
       "pthread",
-      "rt",
     ]
   }
 }
@@ -320,7 +318,7 @@ config("executable_config") {
       "//build/config/ios:ios_dynamic_flags",
       "//build/config/ios:ios_executable_flags",
     ]
-  } else if (is_linux || is_android || current_os == "aix") {
+  } else if (is_linux || is_bsd || is_android || current_os == "aix") {
     configs += [ "//build/config/gcc:executable_ldconfig" ]
     if (is_android) {
       configs += [ "//build/config/android:executable_config" ]
diff --git build/config/BUILDCONFIG.gn build/config/BUILDCONFIG.gn
index 93a97ff280..707343d3f7 100644
--- build/config/BUILDCONFIG.gn
+++ build/config/BUILDCONFIG.gn
@@ -131,10 +131,10 @@ declare_args() {
   is_official_build = false
 
   # Whether we're a traditional desktop unix.
-  is_desktop_linux = current_os == "linux"
+  is_desktop_linux = current_os == "linux" || current_os == "bsd"
 
   # Set to true when compiling with the Clang compiler.
-  is_clang = current_os != "linux" ||
+  is_clang = current_os != "linux" || current_os == "bsd" ||
              (current_cpu != "s390x" && current_cpu != "s390" &&
               current_cpu != "ppc64" && current_cpu != "ppc" &&
               current_cpu != "mips" && current_cpu != "mips64")
@@ -186,8 +186,8 @@ if (host_toolchain == "") {
   # TODO(dpranke): Add some sort of assert here that verifies that
   # no toolchain omitted host_toolchain from its toolchain_args().
 
-  if (host_os == "linux") {
-    if (target_os != "linux") {
+  if (host_os == "linux" || host_os == "bsd") {
+    if (target_os != "linux" || target_os != "bsd") {
       # TODO(dpranke) - is_clang normally applies only to the target
       # build, and there is no way to indicate that you want to override
       # it for both the target build *and* the host build. Do we need to
@@ -227,7 +227,7 @@ if (target_os == "android") {
   assert(host_os == "linux" || host_os == "mac",
          "Android builds are only supported on Linux and Mac hosts.")
   _default_toolchain = "//build/toolchain/android:android_clang_$target_cpu"
-} else if (target_os == "chromeos" || target_os == "linux") {
+} else if (target_os == "chromeos" || target_os == "linux" || target_os == "bsd") {
   # See comments in build/toolchain/cros/BUILD.gn about board compiles.
   if (is_clang) {
     _default_toolchain = "//build/toolchain/linux:clang_$target_cpu"
@@ -300,6 +300,7 @@ if (current_os == "win" || current_os == "winuwp") {
   is_nacl = false
   is_posix = false
   is_win = true
+  is_bsd = false
 } else if (current_os == "mac") {
   is_android = false
   is_chromeos = false
@@ -310,6 +311,7 @@ if (current_os == "win" || current_os == "winuwp") {
   is_nacl = false
   is_posix = true
   is_win = false
+  is_bsd = false
 } else if (current_os == "android") {
   is_android = true
   is_chromeos = false
@@ -320,6 +322,7 @@ if (current_os == "win" || current_os == "winuwp") {
   is_nacl = false
   is_posix = true
   is_win = false
+  is_bsd = false
 } else if (current_os == "chromeos") {
   is_android = false
   is_chromeos = true
@@ -330,6 +333,7 @@ if (current_os == "win" || current_os == "winuwp") {
   is_nacl = false
   is_posix = true
   is_win = false
+  is_bsd = false
 } else if (current_os == "nacl") {
   # current_os == "nacl" will be passed by the nacl toolchain definition.
   # It is not set by default or on the command line. We treat is as a
@@ -343,6 +347,7 @@ if (current_os == "win" || current_os == "winuwp") {
   is_nacl = true
   is_posix = true
   is_win = false
+  is_bsd = false
 } else if (current_os == "fuchsia") {
   is_android = false
   is_chromeos = false
@@ -353,6 +358,7 @@ if (current_os == "win" || current_os == "winuwp") {
   is_nacl = false
   is_posix = false
   is_win = false
+  is_bsd = false
 } else if (current_os == "ios") {
   is_android = false
   is_chromeos = false
@@ -363,6 +369,7 @@ if (current_os == "win" || current_os == "winuwp") {
   is_nacl = false
   is_posix = true
   is_win = false
+  is_bsd = false
 } else if (current_os == "linux") {
   is_android = false
   is_chromeos = false
@@ -373,6 +380,7 @@ if (current_os == "win" || current_os == "winuwp") {
   is_nacl = false
   is_posix = true
   is_win = false
+  is_bsd = false
 } else if (current_os == "aix") {
   is_android = false
   is_chromeos = false
@@ -383,6 +391,18 @@ if (current_os == "win" || current_os == "winuwp") {
   is_nacl = false
   is_posix = true
   is_win = false
+  is_bsd = false
+} else if (current_os == "bsd" || current_os == "dragonfly") {
+  is_android = false
+  is_chromeos = false
+  is_fuchsia = false
+  is_ios = false
+  is_linux = true
+  is_mac = false
+  is_nacl = false
+  is_posix = true
+  is_win = false
+  is_bsd = true
 }
 
 # =============================================================================
diff --git build/config/allocator.gni build/config/allocator.gni
index 709f80f356..5d7637003b 100644
--- build/config/allocator.gni
+++ build/config/allocator.gni
@@ -6,7 +6,7 @@ import("//build/config/sanitizers/sanitizers.gni")
 
 # Temporarily disable tcmalloc on arm64 linux to get rid of compilation errors.
 if (is_android || is_mac || is_ios || is_asan || is_lsan || is_tsan ||
-    is_msan || is_win || is_fuchsia || (is_linux && target_cpu == "arm64")) {
+    is_msan || is_win || is_fuchsia || (is_linux && target_cpu == "arm64") || is_bsd) {
   _default_allocator = "none"
 } else {
   _default_allocator = "tcmalloc"
@@ -17,7 +17,7 @@ if (is_android || is_mac || is_ios || is_asan || is_lsan || is_tsan ||
 # against the debug CRT with "is_nacl=false".
 if ((is_linux || is_android || is_mac ||
      (is_win && !is_component_build && !is_debug)) && !is_asan && !is_lsan &&
-    !is_tsan && !is_msan) {
+    !is_tsan && !is_msan && !is_bsd) {
   _default_use_allocator_shim = true
 } else {
   _default_use_allocator_shim = false
diff --git build/config/compiler/BUILD.gn build/config/compiler/BUILD.gn
index 83337d52e4..c202a7a62c 100644
--- build/config/compiler/BUILD.gn
+++ build/config/compiler/BUILD.gn
@@ -51,7 +51,7 @@ declare_args() {
   # only two architectures that are currently checked in). Turn this off when
   # you are using a custom toolchain and need to control -B in cflags.
   linux_use_bundled_binutils =
-      linux_use_bundled_binutils_override && is_linux &&
+      linux_use_bundled_binutils_override && (is_linux && !is_bsd) &&
       (current_cpu == "x64" || current_cpu == "x86")
   binutils_path = rebase_path("//third_party/binutils/Linux_x64/Release/bin",
                               root_build_dir)
@@ -266,7 +266,7 @@ config("compiler") {
     # Linker warnings.
     if (fatal_linker_warnings && !(is_chromeos && current_cpu == "arm") &&
         !(is_android && use_order_profiling) && !is_mac && !is_ios &&
-        current_os != "aix") {
+        current_os != "aix" && !is_bsd) {
       # TODO(jochen): Enable this on chromeos on arm. http://crbug.com/356580
       # TODO(lizeb,pasko): Fix link errors when linking with order_profiling=1
       # crbug.com/485542
@@ -380,12 +380,6 @@ config("compiler") {
       "-Wl,-z,now",
       "-Wl,-z,relro",
     ]
-    if (!using_sanitizer) {
-      ldflags += [
-        "-Wl,-z,defs",
-        "-Wl,--as-needed",
-      ]
-    }
   }
 
   # Linux-specific compiler flags setup.
@@ -489,7 +483,7 @@ config("compiler") {
   }
 
   if (is_clang && !is_nacl && current_toolchain == host_toolchain &&
-      target_os != "chromeos") {
+      target_os != "chromeos" && !is_bsd) {
     cflags += [
       # TODO(hans): Remove this once Clang generates better optimized debug info
       # by default. https://crbug.com/765793
@@ -734,7 +728,7 @@ config("compiler_cpu_abi") {
         cflags += [ "-mtune=$arm_tune" ]
       }
     } else if (current_cpu == "arm64") {
-      if (is_clang && !is_android && !is_nacl && !is_fuchsia) {
+      if (is_clang && !is_android && !is_nacl && !is_fuchsia && !is_bsd) {
         cflags += [ "--target=aarch64-linux-gnu" ]
         ldflags += [ "--target=aarch64-linux-gnu" ]
       }
@@ -1415,10 +1409,6 @@ config("default_warnings") {
 
         # TODO(hans): https://crbug.com/766891
         "-Wno-null-pointer-arithmetic",
-
-        # Ignore warnings about MSVC optimization pragmas.
-        # TODO(thakis): Only for no_chromium_code? http://crbug.com/505314
-        "-Wno-ignored-pragma-optimize",
       ]
     } else if (use_xcode_clang) {
       cflags += [
@@ -1594,7 +1584,7 @@ config("thin_archive") {
   # Mac and iOS use the mac-specific "libtool" command, not ar, which doesn't
   # have a "thin archive" mode (it does accept -T, but it means truncating
   # archive names to 16 characters, which is not what we want).
-  if ((is_posix && !is_nacl && !is_mac && !is_ios) || is_fuchsia) {
+  if ((is_posix && !is_nacl && !is_mac && !is_ios && !is_bsd) || is_fuchsia) {
     arflags = [ "-T" ]
   }
 }
@@ -2119,7 +2109,7 @@ config("symbols") {
         # [1] crrev.com/a81d5ade0b043208e06ad71a38bcf9c348a1a52f
         cflags += [ "-gdwarf-3" ]
       }
-      cflags += [ "-g2" ]
+      cflags += [ "-g0" ]
     }
     if (use_debug_fission && !is_nacl && !is_android) {
       # NOTE: Some Chrome OS builds globally set |use_debug_fission| to true,
@@ -2139,7 +2129,7 @@ config("symbols") {
     # DWARF info may be corrupt; offsets in a range list entry are in different
     # sections" there.  Maybe just a bug in nacl_switch_32.S.
     if (!is_mac && !is_ios && !is_nacl && target_cpu != "x86" &&
-        (use_gold || use_lld)) {
+        (use_gold || use_lld) && !is_bsd) {
       if (is_clang) {
         # This flag enables the GNU-format pubnames and pubtypes sections,
         # which lld needs in order to generate a correct GDB index.
diff --git build/config/compiler/compiler.gni build/config/compiler/compiler.gni
index 0b13302021..5916215f14 100644
--- build/config/compiler/compiler.gni
+++ build/config/compiler/compiler.gni
@@ -172,7 +172,7 @@ declare_args() {
 
 declare_args() {
   # Whether to use the gold linker from binutils instead of lld or bfd.
-  use_gold = !use_lld && !(is_chromecast && is_linux &&
+  use_gold = !is_bsd && !use_lld && !(is_chromecast && is_linux &&
                            (current_cpu == "arm" || current_cpu == "mipsel")) &&
              ((is_linux && (current_cpu == "x64" || current_cpu == "x86" ||
                             current_cpu == "arm" || current_cpu == "mipsel" ||
diff --git build/config/features.gni build/config/features.gni
index 09cddfd90c..89d9ea2d51 100644
--- build/config/features.gni
+++ build/config/features.gni
@@ -46,7 +46,7 @@ declare_args() {
   fieldtrial_testing_like_official_build = is_chrome_branded
 
   # libudev usage. This currently only affects the content layer.
-  use_udev = is_linux && !is_chromecast
+  use_udev = is_linux && !is_chromecast && !is_bsd
 
   use_dbus = is_linux && !is_chromecast
 
diff --git build/config/linux/BUILD.gn build/config/linux/BUILD.gn
index e3488ab922..c5d6932022 100644
--- build/config/linux/BUILD.gn
+++ build/config/linux/BUILD.gn
@@ -28,7 +28,7 @@ config("runtime_library") {
   }
 
   if ((!is_chromeos || default_toolchain != "//build/toolchain/cros:target") &&
-      (!use_custom_libcxx || current_cpu == "mipsel")) {
+      (!use_custom_libcxx || current_cpu == "mipsel") && !is_bsd) {
     libs = [ "atomic" ]
   }
 }
diff --git build/config/linux/pkg-config.py build/config/linux/pkg-config.py
index 5ef73227df..541ae0f29c 100755
--- build/config/linux/pkg-config.py
+++ build/config/linux/pkg-config.py
@@ -57,8 +57,12 @@ def SetConfigPath(options):
     print "You must specify an architecture via -a if using a sysroot."
     sys.exit(1)
 
-  libdir = sysroot + '/usr/' + options.system_libdir + '/pkgconfig'
-  libdir += ':' + sysroot + '/usr/share/pkgconfig'
+  if "linux" in sys.platform:
+    libdir = sysroot + '/libdata/' + options.system_libdir + '/pkgconfig'
+    libdir += ':' + sysroot + '/usr/share/pkgconfig'
+  elif ("bsd" in sys.platform) or ("dragonfly" in sys.platform):
+    libdir = sysroot + '/libdata/pkgconfig'
+    libdir += ':' + '/usr/libdata/pkgconfig'
   os.environ['PKG_CONFIG_LIBDIR'] = libdir
   return libdir
 
@@ -107,7 +111,7 @@ def main():
   # If this is run on non-Linux platforms, just return nothing and indicate
   # success. This allows us to "kind of emulate" a Linux build from other
   # platforms.
-  if "linux" not in sys.platform:
+  if ("bsd" not in sys.platform) and ("dragonfly" not in sys.platform):
     print "[[],[],[],[],[]]"
     return 0
 
diff --git build/gn_run_binary.py build/gn_run_binary.py
index d7f7165e18..4bb1490394 100644
--- build/gn_run_binary.py
+++ build/gn_run_binary.py
@@ -19,7 +19,7 @@ path = './' + sys.argv[1]
 # The rest of the arguments are passed directly to the executable.
 args = [path] + sys.argv[2:]
 
-ret = subprocess.call(args)
+ret = subprocess.call(args, env={"CHROME_EXE_PATH":"${WRKSRC}/out/Release/chrome"})
 if ret != 0:
   if ret <= -100:
     # Windows error codes such as 0xC0000005 and 0xC0000409 are much easier to
diff --git build/linux/libpci/BUILD.gn build/linux/libpci/BUILD.gn
index 2d1e267e12..267df6c8c9 100644
--- build/linux/libpci/BUILD.gn
+++ build/linux/libpci/BUILD.gn
@@ -3,20 +3,36 @@
 # found in the LICENSE file.
 
 import("//tools/generate_library_loader/generate_library_loader.gni")
+import("//build/config/linux/pkg_config.gni")
 
-# This generates a target named "libpci".
-generate_library_loader("libpci") {
-  name = "LibPciLoader"
-  output_h = "libpci.h"
-  output_cc = "libpci_loader.cc"
-  header = "<pci/pci.h>"
+declare_args() {
+  use_system_libpci = is_bsd
+}
+
+if (use_system_libpci) {
+  pkg_config("system_libpci") {
+    packages = [ "libpci" ]
+  }
+
+  source_set("libpci") {
+    public_configs = [ ":system_libpci" ]
+  }
+
+} else {
+  # This generates a target named "libpci".
+  generate_library_loader("libpci") {
+    name = "LibPciLoader"
+    output_h = "libpci.h"
+    output_cc = "libpci_loader.cc"
+    header = "<pci/pci.h>"
 
-  functions = [
-    "pci_alloc",
-    "pci_init",
-    "pci_cleanup",
-    "pci_scan_bus",
-    "pci_fill_info",
-    "pci_lookup_name",
-  ]
+    functions = [
+      "pci_alloc",
+      "pci_init",
+      "pci_cleanup",
+      "pci_scan_bus",
+      "pci_fill_info",
+      "pci_lookup_name",
+    ]
+  }
 }
diff --git build/linux/unbundle/ffmpeg.gn build/linux/unbundle/ffmpeg.gn
index ee3da1533f..978298a7f2 100644
--- build/linux/unbundle/ffmpeg.gn
+++ build/linux/unbundle/ffmpeg.gn
@@ -14,8 +14,8 @@ pkg_config("system_ffmpeg") {
   ]
 }
 
-buildflag_header("ffmpeg_buildflags") {
-  header = "ffmpeg_buildflags.h"
+buildflag_header("ffmpeg_features") {
+  header = "ffmpeg_features.h"
   flags = [ "USE_SYSTEM_FFMPEG=true" ]
 }
 
@@ -30,7 +30,7 @@ shim_headers("ffmpeg_shim") {
 
 source_set("ffmpeg") {
   deps = [
-    ":ffmpeg_buildflags",
+    ":ffmpeg_features",
     ":ffmpeg_shim",
   ]
   public_configs = [ ":system_ffmpeg" ]
diff --git build/linux/unbundle/libusb.gn build/linux/unbundle/libusb.gn
new file mode 100644
index 0000000000..9f56f092d1
--- /dev/null
+++ build/linux/unbundle/libusb.gn
@@ -0,0 +1,24 @@
+# Copyright 2016 The Chromium Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("//build/config/linux/pkg_config.gni")
+import("//build/shim_headers.gni")
+
+pkg_config("system_libusb") {
+  packages = [ "libusb-1.0" ]
+}
+
+shim_headers("libusb_shim") {
+  root_path = "src/libusb"
+  headers = [
+    "libusb.h",
+  ]
+}
+
+source_set("libusb") {
+  deps = [
+    ":libusb_shim",
+  ]
+  public_configs = [ ":system_libusb" ]
+}
diff --git build/linux/unbundle/libwebp.gn build/linux/unbundle/libwebp.gn
index ab92adecf4..12574d87be 100644
--- build/linux/unbundle/libwebp.gn
+++ build/linux/unbundle/libwebp.gn
@@ -2,12 +2,34 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
+import("//build/config/linux/pkg_config.gni")
+import("//build/shim_headers.gni")
+
+pkg_config("system_libwebp") {
+  packages = [
+    "libwebp",
+    "libwebpdemux",
+    "libwebpmux",
+  ]
+}
+
+shim_headers("libwebp_shim") {
+  root_path = "src"
+  headers = [
+    "webp/decode.h",
+    "webp/demux.h",
+    "webp/encode.h",
+    "webp/mux.h",
+    "webp/mux_types.h",
+    "webp/types.h",
+  ]
+}
+
 source_set("libwebp_webp") {
-  libs = [
-    "webp",
-    "webpdemux",
-    "webpmux",
+  deps = [
+    ":libwebp_shim",
   ]
+  public_configs = [ ":system_libwebp" ]
 }
 
 group("libwebp") {
diff --git build/linux/unbundle/replace_gn_files.py build/linux/unbundle/replace_gn_files.py
index d4d07f23d9..51cef31a94 100755
--- build/linux/unbundle/replace_gn_files.py
+++ build/linux/unbundle/replace_gn_files.py
@@ -27,6 +27,7 @@ REPLACEMENTS = {
   'libevent': 'base/third_party/libevent/BUILD.gn',
   'libjpeg': 'third_party/libjpeg.gni',
   'libpng': 'third_party/libpng/BUILD.gn',
+  'libusb': 'third_party/libusb/BUILD.gn',
   'libvpx': 'third_party/libvpx/BUILD.gn',
   'libwebp': 'third_party/libwebp/BUILD.gn',
   'libxml': 'third_party/libxml/BUILD.gn',
diff --git build/toolchain/get_concurrent_links.py build/toolchain/get_concurrent_links.py
index 45a932c164..e57678e2b3 100644
--- build/toolchain/get_concurrent_links.py
+++ build/toolchain/get_concurrent_links.py
@@ -46,6 +46,14 @@ def _GetTotalMemoryInBytes():
       return int(subprocess.check_output(['sysctl', '-n', 'hw.memsize']))
     except Exception:
       return 0
+  elif sys.platform.startswith('freebsd'):
+    try:
+      avail_bytes = int(subprocess.check_output(['sysctl', '-n', 'hw.physmem']))
+      # With -fuse-lld it doesn't take a lot of ram, feel free to change that
+      # 1 * ... to needed amount
+      return max(1, avail_bytes / (1 * (2 ** 30)))  # total / 4GB
+    except Exception:
+      return 1
   # TODO(scottmg): Implement this for other platforms.
   return 0
 
diff --git build/toolchain/linux/BUILD.gn build/toolchain/linux/BUILD.gn
index 4e9ff440d1..f4f00279f1 100644
--- build/toolchain/linux/BUILD.gn
+++ build/toolchain/linux/BUILD.gn
@@ -14,7 +14,6 @@ clang_toolchain("clang_arm") {
 }
 
 clang_toolchain("clang_arm64") {
-  toolprefix = "aarch64-linux-gnu-"
   toolchain_args = {
     current_cpu = "arm64"
     current_os = "linux"
diff --git cc/BUILD.gn cc/BUILD.gn
index 4f6b936f03..4ed16ea169 100644
--- cc/BUILD.gn
+++ cc/BUILD.gn
@@ -554,7 +554,7 @@ cc_static_library("test_support") {
     "//ui/gl:test_support",
     "//ui/latency",
   ]
-  if (!is_android) {
+  if (!is_android && !is_bsd) {
     data_deps = [
       "//third_party/mesa:osmesa",
     ]
@@ -754,10 +754,6 @@ cc_test("cc_unittests") {
     "//ui/gl",
     "//ui/gl:test_support",
   ]
-
-  data_deps = [
-    "//third_party/mesa:osmesa",
-  ]
 }
 
 cc_test("cc_perftests") {
diff --git cc/layers/scrollbar_layer_impl_base.cc cc/layers/scrollbar_layer_impl_base.cc
index 6a0f9eb613..3e52c488d1 100644
--- cc/layers/scrollbar_layer_impl_base.cc
+++ cc/layers/scrollbar_layer_impl_base.cc
@@ -210,8 +210,8 @@ gfx::Rect ScrollbarLayerImplBase::ComputeThumbQuadRectWithThumbThicknessScale(
   int thumb_offset = TrackStart();
   if (maximum > 0) {
     float ratio = clamped_current_pos / maximum;
-    float max_offset = track_length - thumb_length;
-    thumb_offset += static_cast<int>(ratio * max_offset);
+    float _max_offset = track_length - thumb_length;
+    thumb_offset += static_cast<int>(ratio * _max_offset);
   }
 
   float thumb_thickness_adjustment =
diff --git cc/trees/property_tree.cc cc/trees/property_tree.cc
index 3553d91d01..944ae802c3 100644
--- cc/trees/property_tree.cc
+++ cc/trees/property_tree.cc
@@ -1287,13 +1287,13 @@ gfx::ScrollOffset ScrollTree::MaxScrollOffset(int scroll_node_id) const {
 
   gfx::Size clip_layer_bounds = container_bounds(scroll_node->id);
 
-  gfx::ScrollOffset max_offset(
+  gfx::ScrollOffset _max_offset(
       scaled_scroll_bounds.width() - clip_layer_bounds.width(),
       scaled_scroll_bounds.height() - clip_layer_bounds.height());
 
-  max_offset.Scale(1 / scale_factor);
-  max_offset.SetToMax(gfx::ScrollOffset());
-  return max_offset;
+  _max_offset.Scale(1 / scale_factor);
+  _max_offset.SetToMax(gfx::ScrollOffset());
+  return _max_offset;
 }
 
 void ScrollTree::OnScrollOffsetAnimated(ElementId id,
diff --git chrome/app/chrome_command_ids.h chrome/app/chrome_command_ids.h
index b10ac6533b..0fdc356580 100644
--- chrome/app/chrome_command_ids.h
+++ chrome/app/chrome_command_ids.h
@@ -67,7 +67,7 @@
 #define IDC_VISIT_DESKTOP_OF_LRU_USER_2 34049
 #define IDC_VISIT_DESKTOP_OF_LRU_USER_3 34050
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
 #define IDC_USE_SYSTEM_TITLE_BAR        34051
 #define IDC_RESTORE_WINDOW              34052
 #endif
diff --git chrome/app/chrome_main.cc chrome/app/chrome_main.cc
index 9ff589299b..9be841df5a 100644
--- chrome/app/chrome_main.cc
+++ chrome/app/chrome_main.cc
@@ -89,14 +89,14 @@ int ChromeMain(int argc, const char** argv) {
   ALLOW_UNUSED_LOCAL(command_line);
 
   // Chrome-specific process modes.
-#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN) || defined(OS_BSD)
   if (command_line->HasSwitch(switches::kHeadless)) {
 #if defined(OS_MACOSX)
     SetUpBundleOverrides();
 #endif
     return headless::HeadlessShellMain(params);
   }
-#endif  // defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN)
+#endif  // defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN) || defined(OS_BSD)
 
   int rv = content::ContentMain(params);
 
diff --git chrome/app/chrome_main_delegate.cc chrome/app/chrome_main_delegate.cc
index 8cd410e6d8..dd9b27fcc3 100644
--- chrome/app/chrome_main_delegate.cc
+++ chrome/app/chrome_main_delegate.cc
@@ -97,7 +97,7 @@
 #include "chrome/app/shutdown_signal_handlers_posix.h"
 #endif
 
-#if BUILDFLAG(ENABLE_NACL) && defined(OS_LINUX)
+#if BUILDFLAG(ENABLE_NACL) && defined(OS_LINUX) && !defined(OS_BSD)
 #include "components/nacl/common/nacl_paths.h"
 #include "components/nacl/zygote/nacl_fork_delegate_linux.h"
 #endif
@@ -132,7 +132,7 @@
 #include "v8/include/v8.h"
 #endif
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include "base/environment.h"
 #endif
 
@@ -232,7 +232,7 @@ bool UseHooks() {
 
 #endif  // defined(OS_WIN)
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) && !defined(OS_BSD)
 void AdjustLinuxOOMScore(const std::string& process_type) {
   // Browsers and zygotes should still be killable, but killed last.
   const int kZygoteScore = 0;
@@ -400,7 +400,7 @@ void InitializeUserDataDir(base::CommandLine* command_line) {
   std::string process_type =
       command_line->GetSwitchValueASCII(switches::kProcessType);
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // On Linux, Chrome does not support running multiple copies under different
   // DISPLAYs, so the profile directory can be specified in the environment to
   // support the virtual desktop use-case.
@@ -573,7 +573,7 @@ bool ChromeMainDelegate::BasicStartupComplete(int* exit_code) {
 #if defined(OS_CHROMEOS)
   chromeos::RegisterPathProvider();
 #endif
-#if BUILDFLAG(ENABLE_NACL) && defined(OS_LINUX)
+#if BUILDFLAG(ENABLE_NACL) && defined(OS_LINUX) && !defined(OS_BSD)
   nacl::RegisterPathProvider();
 #endif
 
@@ -595,7 +595,7 @@ bool ChromeMainDelegate::BasicStartupComplete(int* exit_code) {
       std::string format_str =
           command_line.GetSwitchValueASCII(switches::kDiagnosticsFormat);
       if (format_str == "machine") {
-        format = diagnostics::DiagnosticsWriter::MACHINE;
+        format = diagnostics::DiagnosticsWriter::THEMACHINE;
       } else if (format_str == "log") {
         format = diagnostics::DiagnosticsWriter::LOG;
       } else {
@@ -642,7 +642,7 @@ bool ChromeMainDelegate::BasicStartupComplete(int* exit_code) {
       std::string format_str =
           command_line.GetSwitchValueASCII(switches::kDiagnosticsFormat);
       if (format_str == "machine") {
-        format = diagnostics::DiagnosticsWriter::MACHINE;
+        format = diagnostics::DiagnosticsWriter::THEMACHINE;
       } else if (format_str == "human") {
         format = diagnostics::DiagnosticsWriter::HUMAN;
       } else {
@@ -890,7 +890,7 @@ void ChromeMainDelegate::PreSandboxStartup() {
   InitializePDF();
 #endif
 
-#if defined(OS_POSIX) && !defined(OS_MACOSX)
+#if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_BSD)
   // Zygote needs to call InitCrashReporter() in RunZygote().
   if (process_type != service_manager::switches::kZygoteProcess) {
 #if defined(OS_ANDROID)
@@ -906,7 +906,7 @@ void ChromeMainDelegate::PreSandboxStartup() {
     breakpad::InitCrashReporter(process_type);
 #endif  // defined(OS_ANDROID)
   }
-#endif  // defined(OS_POSIX) && !defined(OS_MACOSX)
+#endif  // defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_BSD)
 
   // After all the platform Breakpads have been initialized, store the command
   // line for crash reporting.
@@ -916,7 +916,7 @@ void ChromeMainDelegate::PreSandboxStartup() {
 void ChromeMainDelegate::SandboxInitialized(const std::string& process_type) {
   // Note: If you are adding a new process type below, be sure to adjust the
   // AdjustLinuxOOMScore function too.
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) && !defined(OS_BSD)
   AdjustLinuxOOMScore(process_type);
 #endif
 #if defined(OS_WIN)
diff --git chrome/app/chromium_strings.grd chrome/app/chromium_strings.grd
index 75e3062a93..aa4fbc7066 100644
--- chrome/app/chromium_strings.grd
+++ chrome/app/chromium_strings.grd
@@ -837,7 +837,7 @@ Signing in anyway will merge Chromium information like bookmarks, history, and o
       </message>
 
       <!-- ProcessSingleton -->
-      <if expr="is_linux or is_macosx">
+      <if expr="is_linux or is_macosx or is_posix">
         <message name="IDS_PROFILE_IN_USE_POSIX" desc="Message shown when the browser cannot start because the profile is in use on a different host.">
           The profile appears to be in use by another Chromium process (<ph name="PROCESS_ID">$1<ex>12345</ex></ph>) on another computer (<ph name="HOST_NAME">$2<ex>example.com</ex></ph>). Chromium has locked the profile so that it doesn't get corrupted. If you are sure no other processes are using this profile, you can unlock the profile and relaunch Chromium.
         </message>
diff --git chrome/app/generated_resources.grd chrome/app/generated_resources.grd
index c0d79d0669..8f7002a015 100644
--- chrome/app/generated_resources.grd
+++ chrome/app/generated_resources.grd
@@ -6281,7 +6281,7 @@ I don't think this site should be blocked!
         Google Pay
       </message>
 
-      <if expr="not is_linux or chromeos">
+      <if expr="not is_posix or chromeos">
         <message name="IDS_THEMES_GROUP_NAME" desc="The title of the themes group">
           Themes
         </message>
@@ -6289,7 +6289,7 @@ I don't think this site should be blocked!
       <message name="IDS_THEMES_RESET_BUTTON" desc="The button to reset your theme">
         Reset to default theme
       </message>
-      <if expr="is_linux and not chromeos">
+      <if expr="is_posix and not chromeos">
         <message name="IDS_THEMES_GTK_BUTTON" desc="The button to choose GTK colors and icons as the current theme.">
           Use GTK+ theme
         </message>
@@ -7526,7 +7526,7 @@ Please help our engineers fix this problem. Tell us what happened right before y
         Set as default
       </message>
 
-      <if expr="is_linux and not chromeos">
+      <if expr="is_posix and not chromeos">
         <message name="IDS_MINIMIZE_WINDOW_MENU" desc="The Linux browser window menu item text for minimizing the window.">
           Minimize
         </message>
diff --git chrome/app/google_chrome_strings.grd chrome/app/google_chrome_strings.grd
index 804eed7424..66a8f113cd 100644
--- chrome/app/google_chrome_strings.grd
+++ chrome/app/google_chrome_strings.grd
@@ -848,7 +848,7 @@ Signing in anyway will merge Chrome information like bookmarks, history, and oth
       </message>
 
       <!-- ProcessSingleton -->
-      <if expr="is_linux or is_macosx">
+      <if expr="is_linux or is_macosx or is_posix">
         <message name="IDS_PROFILE_IN_USE_POSIX" desc="Message shown when the browser cannot start because the profile is in use on a different host.">
           The profile appears to be in use by another Google Chrome process (<ph name="PROCESS_ID">$1<ex>12345</ex></ph>) on another computer (<ph name="HOST_NAME">$2<ex>example.com</ex></ph>).  Chrome has locked the profile so that it doesn't get corrupted.  If you are sure no other processes are using this profile, you can unlock the profile and relaunch Chrome.
         </message>
diff --git chrome/app/settings_strings.grdp chrome/app/settings_strings.grdp
index 60ad72d83e..a87b9c28ca 100644
--- chrome/app/settings_strings.grdp
+++ chrome/app/settings_strings.grdp
@@ -502,7 +502,7 @@
       Themes
     </message>
   </if>
-  <if expr="is_linux and not chromeos">
+  <if expr="is_posix and not chromeos">
     <message name="IDS_SETTINGS_SYSTEM_THEME" desc="Text of the label describing the system (GTK+) browser theme on Linux">
       GTK+
     </message>
@@ -516,7 +516,7 @@
       Use Classic
     </message>
   </if>
-  <if expr="not is_linux or chromeos">
+  <if expr="not is_posix or chromeos">
     <message name="IDS_SETTINGS_RESET_TO_DEFAULT_THEME" desc="Name of the control which resets the browser theme back to the default theme.">
       Reset to default
     </message>
diff --git chrome/app/shutdown_signal_handlers_posix.cc chrome/app/shutdown_signal_handlers_posix.cc
index 5c7ffd9220..e83e54ea02 100644
--- chrome/app/shutdown_signal_handlers_posix.cc
+++ chrome/app/shutdown_signal_handlers_posix.cc
@@ -183,6 +183,11 @@ void InstallShutdownSignalHandlers(
   g_pipe_pid = getpid();
   g_shutdown_pipe_read_fd = pipefd[0];
   g_shutdown_pipe_write_fd = pipefd[1];
+#if defined(OS_BSD)
+  // PTHREAD_STACK_MIN causes chromium to crash under FreeBSD,
+  // we request the default pthread stack size by specifying 0 here.
+  const size_t kShutdownDetectorThreadStackSize = 0;
+#else 
 #if !defined(ADDRESS_SANITIZER) && !defined(KEEP_SHADOW_STACKS)
   const size_t kShutdownDetectorThreadStackSize = PTHREAD_STACK_MIN * 2;
 #else
@@ -190,6 +195,7 @@ void InstallShutdownSignalHandlers(
   // shadow stacks) bloat the stack frames, so we need to increase the stack
   // size to avoid hitting the guard page.
   const size_t kShutdownDetectorThreadStackSize = PTHREAD_STACK_MIN * 4;
+#endif
 #endif
   ShutdownDetector* detector = new ShutdownDetector(
       g_shutdown_pipe_read_fd, shutdown_callback, task_runner);
diff --git chrome/app/theme/chrome_unscaled_resources.grd chrome/app/theme/chrome_unscaled_resources.grd
index 9b89ae3bcf..3b18831215 100644
--- chrome/app/theme/chrome_unscaled_resources.grd
+++ chrome/app/theme/chrome_unscaled_resources.grd
@@ -88,7 +88,7 @@
         <include name="IDR_PROFILE_AVATAR_2X_25" file="default_200_percent/common/profile_avatar_sun_cloud.png" type="BINDATA" />
         <include name="IDR_PROFILE_AVATAR_2X_26" file="default_200_percent/common/profile_avatar_placeholder.png" type="BINDATA" />
       </if>
-      <if expr="is_linux and enable_app_list">
+      <if expr="is_posix and enable_app_list">
         <!-- App Launcher icons for desktop icon. -->
         <if expr="_google_chrome">
           <then>
diff --git chrome/browser/about_flags.cc chrome/browser/about_flags.cc
index 10bda7b8b3..72bde4bc7c 100644
--- chrome/browser/about_flags.cc
+++ chrome/browser/about_flags.cc
@@ -2408,7 +2408,7 @@ const FeatureEntry kFeatureEntries[] = {
      flag_descriptions::kEnableMaterialDesignExtensionsDescription, kOsDesktop,
      FEATURE_VALUE_TYPE(features::kMaterialDesignExtensions)},
 #endif  // ENABLE_EXTENSIONS
-#if defined(OS_WIN) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_BSD)
     {"enable-input-ime-api", flag_descriptions::kEnableInputImeApiName,
      flag_descriptions::kEnableInputImeApiDescription, kOsWin | kOsLinux,
      ENABLE_DISABLE_VALUE_TYPE(switches::kEnableInputImeAPI,
@@ -3024,7 +3024,7 @@ const FeatureEntry kFeatureEntries[] = {
      flag_descriptions::kLeftToRightUrlsDescription, kOsDesktop,
      FEATURE_VALUE_TYPE(features::kLeftToRightUrls)},
 
-#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN) || defined(OS_BSD)
     {"omnibox-new-answer-layout",
      flag_descriptions::kOmniboxNewAnswerLayoutName,
      flag_descriptions::kOmniboxNewAnswerLayoutDescription, kOsDesktop,
diff --git chrome/browser/after_startup_task_utils.cc chrome/browser/after_startup_task_utils.cc
index 729d3d7fd8..de00ada62b 100644
--- chrome/browser/after_startup_task_utils.cc
+++ chrome/browser/after_startup_task_utils.cc
@@ -101,7 +101,7 @@ void QueueTask(std::unique_ptr<AfterStartupTask> queued_task) {
 
 void SetBrowserStartupIsComplete() {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-#if defined(OS_MACOSX) || defined(OS_WIN) || defined(OS_LINUX)
+#if defined(OS_MACOSX) || defined(OS_WIN) || defined(OS_LINUX) || defined(OS_BSD)
   // CurrentProcessInfo::CreationTime() is not available on all platforms.
   const base::Time process_creation_time =
       base::CurrentProcessInfo::CreationTime();
diff --git chrome/browser/background/background_mode_optimizer.cc chrome/browser/background/background_mode_optimizer.cc
index 70ee422508..a73d6f0102 100644
--- chrome/browser/background/background_mode_optimizer.cc
+++ chrome/browser/background/background_mode_optimizer.cc
@@ -30,10 +30,10 @@ std::unique_ptr<BackgroundModeOptimizer> BackgroundModeOptimizer::Create() {
           switches::kKeepAliveForTest))
     return nullptr;
 
-#if defined(OS_WIN) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_BSD)
   if (base::FeatureList::IsEnabled(features::kBackgroundModeAllowRestart))
     return base::WrapUnique(new BackgroundModeOptimizer());
-#endif  // defined(OS_WIN) || defined(OS_LINUX)
+#endif  // defined(OS_WIN) || defined(OS_LINUX) || defined(OS_BSD)
 
   return nullptr;
 }
diff --git chrome/browser/browser_process_impl.cc chrome/browser/browser_process_impl.cc
index a5237f650f..397240221d 100644
--- chrome/browser/browser_process_impl.cc
+++ chrome/browser/browser_process_impl.cc
@@ -174,7 +174,7 @@
 #include "chrome/browser/plugins/plugins_resource_service.h"
 #endif
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
 #include "chrome/browser/resource_coordinator/tab_manager.h"
 #endif
 
@@ -842,7 +842,7 @@ gcm::GCMDriver* BrowserProcessImpl::gcm_driver() {
 
 resource_coordinator::TabManager* BrowserProcessImpl::GetTabManager() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
   if (!tab_manager_) {
     tab_manager_ = std::make_unique<resource_coordinator::TabManager>();
     tab_lifecycle_unit_source_ =
diff --git chrome/browser/browser_process_impl.h chrome/browser/browser_process_impl.h
index 3c9e785174..e4af5285b1 100644
--- chrome/browser/browser_process_impl.h
+++ chrome/browser/browser_process_impl.h
@@ -363,7 +363,7 @@ class BrowserProcessImpl : public BrowserProcess,
 
   std::unique_ptr<ChromeDeviceClient> device_client_;
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
   // Any change to this #ifdef must be reflected as well in
   // chrome/browser/resource_coordinator/tab_manager_browsertest.cc
   std::unique_ptr<resource_coordinator::TabManager> tab_manager_;
diff --git chrome/browser/browser_resources.grd chrome/browser/browser_resources.grd
index 58912721f9..032ed647fe 100644
--- chrome/browser/browser_resources.grd
+++ chrome/browser/browser_resources.grd
@@ -625,7 +625,7 @@
         <include name="IDR_WELCOME_WIN10_PIN_WEBP" file="resources\welcome\pin.webp" type="BINDATA" />
       </if>
       <include name="IDR_SSL_ERROR_ASSISTANT_PB" file="${root_gen_dir}/chrome/browser/resources/ssl/ssl_error_assistant/ssl_error_assistant.pb" use_base_dir="false" type="BINDATA" />
-      <if expr="is_android or is_linux">
+      <if expr="is_android or is_posix">
         <include name="IDR_SANDBOX_INTERNALS_HTML" file="resources\sandbox_internals\sandbox_internals.html" flattenhtml="true" allowexternalscript="true" type="BINDATA" compress="gzip" />
         <include name="IDR_SANDBOX_INTERNALS_JS" file="resources\sandbox_internals\sandbox_internals.js" type="BINDATA" compress="gzip" />
       </if>
diff --git chrome/browser/chrome_browser_main.cc chrome/browser/chrome_browser_main.cc
index 4a477cf300..aba63605c3 100644
--- chrome/browser/chrome_browser_main.cc
+++ chrome/browser/chrome_browser_main.cc
@@ -213,7 +213,7 @@
 #include "chromeos/settings/cros_settings_names.h"
 #endif  // defined(OS_CHROMEOS)
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
 #include "chrome/browser/first_run/upgrade_util_linux.h"
 #endif  // defined(OS_LINUX) && !defined(OS_CHROMEOS)
 
@@ -253,7 +253,7 @@
 #endif  // defined(OS_WIN)
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || \
-    (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+    (defined(OS_LINUX) && !defined(OS_CHROMEOS) || defined(OS_BSD))
 #include "chrome/browser/metrics/desktop_session_duration/desktop_session_duration_tracker.h"
 #endif
 
@@ -1369,10 +1369,10 @@ int ChromeBrowserMainParts::PreCreateThreadsImpl() {
   }
 #endif  // !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
 
-#if defined(OS_LINUX) || defined(OS_OPENBSD)
+#if defined(OS_LINUX)
   // Set the product channel for crash reports.
   breakpad::SetChannelCrashKey(chrome::GetChannelName());
-#endif  // defined(OS_LINUX) || defined(OS_OPENBSD)
+#endif  // defined(OS_LINUX)
 
 #if defined(OS_MACOSX)
   // Get the Keychain API to register for distributed notifications on the main
@@ -1396,7 +1396,7 @@ int ChromeBrowserMainParts::PreCreateThreadsImpl() {
   }
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || \
-    (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+    (defined(OS_LINUX) && !defined(OS_CHROMEOS) || defined(OS_BSD))
   metrics::DesktopSessionDurationTracker::Initialize();
 #endif
   metrics::RendererUptimeTracker::Initialize();
@@ -1543,7 +1543,7 @@ void ChromeBrowserMainParts::PreBrowserStart() {
 
 // Start the tab manager here so that we give the most amount of time for the
 // other services to start up before we start adjusting the oom priority.
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
   g_browser_process->GetTabManager()->Start();
 #endif
 
diff --git chrome/browser/chrome_browser_main_linux.cc chrome/browser/chrome_browser_main_linux.cc
index be63d8b34a..0aee41da2c 100644
--- chrome/browser/chrome_browser_main_linux.cc
+++ chrome/browser/chrome_browser_main_linux.cc
@@ -86,12 +86,14 @@ void ChromeBrowserMainPartsLinux::PreProfileInit() {
 void ChromeBrowserMainPartsLinux::PostProfileInit() {
   ChromeBrowserMainPartsPosix::PostProfileInit();
 
+#if !defined(OS_BSD)
   g_browser_process->metrics_service()->RecordBreakpadRegistration(
       breakpad::IsCrashReporterEnabled());
+#endif
 }
 
 void ChromeBrowserMainPartsLinux::PostMainMessageLoopStart() {
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_BSD)
   bluez::DBusThreadManagerLinux::Initialize();
   bluez::BluezDBusManager::Initialize(
       bluez::DBusThreadManagerLinux::Get()->GetSystemBus(), false);
@@ -101,7 +103,7 @@ void ChromeBrowserMainPartsLinux::PostMainMessageLoopStart() {
 }
 
 void ChromeBrowserMainPartsLinux::PostDestroyThreads() {
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_BSD)
   bluez::BluezDBusManager::Shutdown();
   bluez::DBusThreadManagerLinux::Shutdown();
 #endif
diff --git chrome/browser/chrome_browser_main_posix.cc chrome/browser/chrome_browser_main_posix.cc
index 94b0a0b2b9..d5d8025dac 100644
--- chrome/browser/chrome_browser_main_posix.cc
+++ chrome/browser/chrome_browser_main_posix.cc
@@ -139,7 +139,7 @@ void ChromeBrowserMainPartsPosix::PostMainMessageLoopStart() {
 void ChromeBrowserMainPartsPosix::ShowMissingLocaleMessageBox() {
 #if defined(OS_CHROMEOS)
   NOTREACHED();  // Should not ever happen on ChromeOS.
-#elif defined(OS_MACOSX)
+#elif defined(OS_MACOSX) || defined(OS_BSD)
   // Not called on Mac because we load the locale files differently.
   NOTREACHED();
 #elif defined(USE_AURA)
diff --git chrome/browser/chrome_content_browser_client.cc chrome/browser/chrome_content_browser_client.cc
index ec54b365d4..a5cfe931d5 100644
--- chrome/browser/chrome_content_browser_client.cc
+++ chrome/browser/chrome_content_browser_client.cc
@@ -309,7 +309,7 @@
 #include "chromeos/chromeos_switches.h"
 #include "components/user_manager/user_manager.h"
 #include "services/service_manager/public/mojom/interface_provider_spec.mojom.h"
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
 #include "chrome/browser/chrome_browser_main_linux.h"
 #elif defined(OS_ANDROID)
 #include "base/android/application_status_listener.h"
@@ -347,7 +347,7 @@
 #include "chrome/common/importer/profile_import.mojom.h"
 #endif
 
-#if defined(OS_LINUX) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_WIN) || defined(OS_BSD)
 #include "chrome/browser/webshare/share_service_impl.h"
 #endif
 
@@ -361,7 +361,7 @@
 #include "chrome/browser/ui/views/chrome_browser_main_extra_parts_views.h"
 #endif
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
 #include "chrome/browser/ui/views/chrome_browser_main_extra_parts_views_linux.h"
 #endif
 
@@ -1061,7 +1061,7 @@ content::BrowserMainParts* ChromeContentBrowserClient::CreateBrowserMainParts(
 #elif defined(OS_CHROMEOS)
   main_parts = new chromeos::ChromeBrowserMainPartsChromeos(
       parameters, std::move(service_manifest_data_pack_));
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   main_parts = new ChromeBrowserMainPartsLinux(
       parameters, std::move(service_manifest_data_pack_));
 #elif defined(OS_ANDROID)
@@ -1081,7 +1081,7 @@ content::BrowserMainParts* ChromeContentBrowserClient::CreateBrowserMainParts(
   // Construct additional browser parts. Stages are called in the order in
   // which they are added.
 #if defined(TOOLKIT_VIEWS)
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(USE_OZONE)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS) && !defined(USE_OZONE)
   main_parts->AddParts(new ChromeBrowserMainExtraPartsViewsLinux());
 #else
   main_parts->AddParts(new ChromeBrowserMainExtraPartsViews());
@@ -1823,7 +1823,7 @@ void ChromeContentBrowserClient::AppendExtraCommandLineSwitches(
     command_line->AppendSwitchASCII(switches::kMetricsClientID,
                                     client_info->client_id);
   }
-#elif defined(OS_POSIX)
+#elif defined(OS_POSIX) && !defined(OS_BSD)
   if (breakpad::IsCrashReporterEnabled()) {
     std::string switch_value;
     std::unique_ptr<metrics::ClientInfo> client_info =
@@ -3177,7 +3177,7 @@ void ChromeContentBrowserClient::GetAdditionalFileSystemBackends(
   }
 }
 
-#if defined(OS_POSIX) && !defined(OS_MACOSX)
+#if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_BSD)
 void ChromeContentBrowserClient::GetAdditionalMappedFilesForChildProcess(
     const base::CommandLine& command_line,
     int child_process_id,
@@ -3892,7 +3892,7 @@ void ChromeContentBrowserClient::InitWebContextInterfaces() {
 #if defined(OS_ANDROID)
   frame_interfaces_parameterized_->AddInterface(base::Bind(
       &ForwardToJavaWebContentsRegistry<blink::mojom::ShareService>));
-#elif defined(OS_LINUX) || defined(OS_WIN)
+#elif defined(OS_LINUX) || defined(OS_WIN) || defined(OS_BSD)
   frame_interfaces_->AddInterface(base::Bind(&ShareServiceImpl::Create));
 #endif
 
diff --git chrome/browser/chrome_content_browser_client.h chrome/browser/chrome_content_browser_client.h
index d392303a78..48fd99db4b 100644
--- chrome/browser/chrome_content_browser_client.h
+++ chrome/browser/chrome_content_browser_client.h
@@ -302,12 +302,12 @@ class ChromeContentBrowserClient : public content::ContentBrowserClient {
   void OverridePageVisibilityState(
       content::RenderFrameHost* render_frame_host,
       blink::mojom::PageVisibilityState* visibility_state) override;
-#if defined(OS_POSIX) && !defined(OS_MACOSX)
+#if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_BSD)
   void GetAdditionalMappedFilesForChildProcess(
       const base::CommandLine& command_line,
       int child_process_id,
       content::PosixFileDescriptorInfo* mappings) override;
-#endif  // defined(OS_POSIX) && !defined(OS_MACOSX)
+#endif  // defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_BSD)
 #if defined(OS_WIN)
   bool PreSpawnRenderer(sandbox::TargetPolicy* policy) override;
   base::string16 GetAppContainerSidForSandboxType(
diff --git chrome/browser/defaults.cc chrome/browser/defaults.cc
index 2aec41babc..4a4ec0b32e 100644
--- chrome/browser/defaults.cc
+++ chrome/browser/defaults.cc
@@ -44,7 +44,7 @@ const bool kSyncAutoStarts = true;
 const bool kSyncAutoStarts = false;
 #endif
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
 const bool kScrollEventChangesTab = true;
 #else
 const bool kScrollEventChangesTab = false;
diff --git chrome/browser/devtools/devtools_eye_dropper.cc chrome/browser/devtools/devtools_eye_dropper.cc
index fe1ce9fbe8..0af98c7f11 100644
--- chrome/browser/devtools/devtools_eye_dropper.cc
+++ chrome/browser/devtools/devtools_eye_dropper.cc
@@ -209,7 +209,7 @@ void DevToolsEyeDropper::UpdateCursor() {
 // magnified projection only with centered hotspot.
 // Mac Retina requires cursor to be > 120px in order to render smoothly.
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   const float kCursorSize = 63;
   const float kDiameter = 63;
   const float kHotspotOffset = 32;
diff --git chrome/browser/diagnostics/diagnostics_writer.cc chrome/browser/diagnostics/diagnostics_writer.cc
index 2f62550cc7..711c8d54de 100644
--- chrome/browser/diagnostics/diagnostics_writer.cc
+++ chrome/browser/diagnostics/diagnostics_writer.cc
@@ -265,7 +265,7 @@ bool DiagnosticsWriter::WriteResult(bool success,
       console_->SetColor(color);
       console_->Write(base::ASCIIToUTF16(result));
     }
-    if (format_ == MACHINE) {
+    if (format_ == THEMACHINE) {
       return WriteInfoLine(base::StringPrintf(
           "%03d %s (%s)", outcome_code, id.c_str(), extra.c_str()));
     } else {
diff --git chrome/browser/diagnostics/diagnostics_writer.h chrome/browser/diagnostics/diagnostics_writer.h
index 094ae64b4c..3f80e98e45 100644
--- chrome/browser/diagnostics/diagnostics_writer.h
+++ chrome/browser/diagnostics/diagnostics_writer.h
@@ -19,7 +19,7 @@ class DiagnosticsWriter : public DiagnosticsModel::Observer {
  public:
   // The type of formatting done by this writer.
   enum FormatType {
-    MACHINE,
+    THEMACHINE,
     LOG,
     HUMAN
   };
diff --git chrome/browser/download/chrome_download_manager_delegate.cc chrome/browser/download/chrome_download_manager_delegate.cc
index 8d0bff3e46..f0a8f0c5a4 100644
--- chrome/browser/download/chrome_download_manager_delegate.cc
+++ chrome/browser/download/chrome_download_manager_delegate.cc
@@ -1148,7 +1148,7 @@ void ChromeDownloadManagerDelegate::OnDownloadTargetDetermined(
         target_info->is_filetype_handled_safely)
       DownloadItemModel(item).SetShouldPreferOpeningInBrowser(true);
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     if (item->GetOriginalMimeType() == "application/x-x509-user-cert")
       DownloadItemModel(item).SetShouldPreferOpeningInBrowser(true);
 #endif
@@ -1168,7 +1168,7 @@ void ChromeDownloadManagerDelegate::OnDownloadTargetDetermined(
 
 bool ChromeDownloadManagerDelegate::IsOpenInBrowserPreferreredForFile(
     const base::FilePath& path) {
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
   if (path.MatchesExtension(FILE_PATH_LITERAL(".pdf"))) {
     return !download_prefs_->ShouldOpenPdfInSystemReader();
   }
diff --git chrome/browser/download/download_commands.cc chrome/browser/download/download_commands.cc
index 3a64f7928c..22eaa937bd 100644
--- chrome/browser/download/download_commands.cc
+++ chrome/browser/download/download_commands.cc
@@ -249,7 +249,7 @@ bool DownloadCommands::IsCommandChecked(Command command) const {
       return download_item_->GetOpenWhenComplete() ||
              download_crx_util::IsExtensionDownload(*download_item_);
     case ALWAYS_OPEN_TYPE:
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
       if (CanOpenPdfInSystemViewer()) {
         DownloadPrefs* prefs = DownloadPrefs::FromBrowserContext(
             content::DownloadItemUtils::GetBrowserContext(download_item_));
@@ -293,7 +293,7 @@ void DownloadCommands::ExecuteCommand(Command command) {
       bool is_checked = IsCommandChecked(ALWAYS_OPEN_TYPE);
       DownloadPrefs* prefs = DownloadPrefs::FromBrowserContext(
           content::DownloadItemUtils::GetBrowserContext(download_item_));
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
       if (CanOpenPdfInSystemViewer()) {
         prefs->SetShouldOpenPdfInSystemReader(!is_checked);
         DownloadItemModel(download_item_)
@@ -408,7 +408,7 @@ Browser* DownloadCommands::GetBrowser() const {
   return browser_displayer.browser();
 }
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
 bool DownloadCommands::IsDownloadPdf() const {
   base::FilePath path = download_item_->GetTargetFilePath();
   return path.MatchesExtension(FILE_PATH_LITERAL(".pdf"));
@@ -425,7 +425,7 @@ bool DownloadCommands::CanOpenPdfInSystemViewer() const {
   return IsDownloadPdf() &&
          (IsAdobeReaderDefaultPDFViewer() ? is_adobe_pdf_reader_up_to_date
                                           : true);
-#elif defined(OS_MACOSX) || defined(OS_LINUX)
+#elif defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
   return IsDownloadPdf();
 #endif
 }
diff --git chrome/browser/download/download_commands.h chrome/browser/download/download_commands.h
index 9c94b831a5..9294adec61 100644
--- chrome/browser/download/download_commands.h
+++ chrome/browser/download/download_commands.h
@@ -42,7 +42,7 @@ class DownloadCommands {
   bool IsCommandVisible(Command command) const;
   void ExecuteCommand(Command command);
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
   bool IsDownloadPdf() const;
   bool CanOpenPdfInSystemViewer() const;
 #endif
diff --git chrome/browser/download/download_prefs.cc chrome/browser/download/download_prefs.cc
index 095f65c5a7..211ec26ddf 100644
--- chrome/browser/download/download_prefs.cc
+++ chrome/browser/download/download_prefs.cc
@@ -62,7 +62,7 @@ namespace {
 // Consider downloads 'dangerous' if they go to the home directory on Linux and
 // to the desktop on any platform.
 bool DownloadPathIsDangerous(const base::FilePath& download_path) {
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   base::FilePath home_dir = base::GetHomeDir();
   if (download_path == home_dir) {
     return true;
@@ -141,7 +141,7 @@ DownloadPrefs::DownloadPrefs(Profile* profile) : profile_(profile) {
                                 GetDefaultDownloadDirectoryForProfile()));
 #endif  // defined(OS_CHROMEOS)
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
   should_open_pdf_in_system_reader_ =
       prefs->GetBoolean(prefs::kOpenPdfDownloadInSystemReader);
 #endif
@@ -238,7 +238,7 @@ void DownloadPrefs::RegisterProfilePrefs(
                                  default_download_path);
   registry->RegisterFilePathPref(prefs::kSaveFileDefaultDirectory,
                                  default_download_path);
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
   registry->RegisterBooleanPref(prefs::kOpenPdfDownloadInSystemReader, false);
 #endif
 #if defined(OS_ANDROID)
@@ -346,7 +346,7 @@ bool DownloadPrefs::IsDownloadPathManaged() const {
 }
 
 bool DownloadPrefs::IsAutoOpenUsed() const {
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
   if (ShouldOpenPdfInSystemReader())
     return true;
 #endif
@@ -360,7 +360,7 @@ bool DownloadPrefs::IsAutoOpenEnabledBasedOnExtension(
     return false;
   DCHECK(extension[0] == base::FilePath::kExtensionSeparator);
   extension.erase(0, 1);
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
   if (base::FilePath::CompareEqualIgnoreCase(extension,
                                              FILE_PATH_LITERAL("pdf")) &&
       ShouldOpenPdfInSystemReader())
@@ -397,7 +397,7 @@ void DownloadPrefs::DisableAutoOpenBasedOnExtension(
   SaveAutoOpenState();
 }
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
 void DownloadPrefs::SetShouldOpenPdfInSystemReader(bool should_open) {
   if (should_open_pdf_in_system_reader_ == should_open)
     return;
@@ -418,7 +418,7 @@ bool DownloadPrefs::ShouldOpenPdfInSystemReader() const {
 #endif
 
 void DownloadPrefs::ResetAutoOpen() {
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
   SetShouldOpenPdfInSystemReader(false);
 #endif
   auto_open_.clear();
diff --git chrome/browser/download/download_prefs.h chrome/browser/download/download_prefs.h
index f591f9aa72..b62c2ad882 100644
--- chrome/browser/download/download_prefs.h
+++ chrome/browser/download/download_prefs.h
@@ -99,7 +99,7 @@ class DownloadPrefs {
   // Disables auto-open based on file extension.
   void DisableAutoOpenBasedOnExtension(const base::FilePath& file_name);
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
   // Store the user preference to disk. If |should_open| is true, also disable
   // the built-in PDF plugin. If |should_open| is false, enable the PDF plugin.
   void SetShouldOpenPdfInSystemReader(bool should_open);
@@ -143,7 +143,7 @@ class DownloadPrefs {
                    AutoOpenCompareFunctor> AutoOpenSet;
   AutoOpenSet auto_open_;
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
   bool should_open_pdf_in_system_reader_;
 #endif
 
diff --git chrome/browser/download/download_query.cc chrome/browser/download/download_query.cc
index d768257d0d..73932bc327 100644
--- chrome/browser/download/download_query.cc
+++ chrome/browser/download/download_query.cc
@@ -27,7 +27,11 @@
 #include "components/download/public/common/download_item.h"
 #include "components/url_formatter/url_formatter.h"
 #include "content/public/browser/content_browser_client.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 #include "url/gurl.h"
 
 using download::DownloadDangerType;
diff --git chrome/browser/download/download_shelf_context_menu.cc chrome/browser/download/download_shelf_context_menu.cc
index d0139e5984..a9c0e62b21 100644
--- chrome/browser/download/download_shelf_context_menu.cc
+++ chrome/browser/download/download_shelf_context_menu.cc
@@ -131,7 +131,7 @@ base::string16 DownloadShelfContextMenu::GetLabelForCommandId(
                    : IDS_DOWNLOAD_MENU_PLATFORM_OPEN_ALWAYS;
           break;
         }
-#elif defined(OS_MACOSX) || defined(OS_LINUX)
+#elif defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
         if (can_open_pdf_in_system_viewer) {
           id = IDS_DOWNLOAD_MENU_PLATFORM_OPEN_ALWAYS;
           break;
diff --git chrome/browser/download/download_status_updater.cc chrome/browser/download/download_status_updater.cc
index b21aa1cc82..8896fe0835 100644
--- chrome/browser/download/download_status_updater.cc
+++ chrome/browser/download/download_status_updater.cc
@@ -13,7 +13,7 @@
 #include "base/memory/ptr_util.h"
 #include "build/build_config.h"
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
 #include "ui/views/linux_ui/linux_ui.h"
 #endif
 
@@ -136,7 +136,7 @@ void DownloadStatusUpdater::OnDownloadUpdated(content::DownloadManager* manager,
 #if defined(OS_ANDROID) || (defined(USE_AURA) && !defined(OS_WIN))
 void DownloadStatusUpdater::UpdateAppIconDownloadProgress(
     download::DownloadItem* download) {
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   const views::LinuxUI* linux_ui = views::LinuxUI::instance();
   if (linux_ui) {
     float progress = 0;
diff --git chrome/browser/extensions/BUILD.gn chrome/browser/extensions/BUILD.gn
index fae6b2027b..e83923e711 100644
--- chrome/browser/extensions/BUILD.gn
+++ chrome/browser/extensions/BUILD.gn
@@ -1133,6 +1133,12 @@ static_library("extensions") {
     deps += [ "//chrome/common:service_process_mojom" ]
   }
 
+  if (is_bsd) {
+    sources -= [
+      "api/image_writer_private/removable_storage_provider_linux.cc",
+    ]
+  }
+
   if (enable_service_discovery) {
     sources += [
       "api/mdns/mdns_api.cc",
diff --git chrome/browser/extensions/activity_log/activity_log.cc chrome/browser/extensions/activity_log/activity_log.cc
index c37d5d5817..a297758351 100644
--- chrome/browser/extensions/activity_log/activity_log.cc
+++ chrome/browser/extensions/activity_log/activity_log.cc
@@ -50,7 +50,11 @@
 #include "extensions/common/extension.h"
 #include "extensions/common/extension_messages.h"
 #include "extensions/common/one_shot_event.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 #include "url/gurl.h"
 
 namespace constants = activity_log_constants;
diff --git chrome/browser/extensions/api/image_writer_private/removable_storage_provider.cc chrome/browser/extensions/api/image_writer_private/removable_storage_provider.cc
index c16b847be5..a5b5b35ffc 100644
--- chrome/browser/extensions/api/image_writer_private/removable_storage_provider.cc
+++ chrome/browser/extensions/api/image_writer_private/removable_storage_provider.cc
@@ -20,6 +20,7 @@ static base::LazyInstance<scoped_refptr<StorageDeviceList>>::DestructorAtExit
 
 void RemovableStorageProvider::GetAllDevices(DeviceListReadyCallback callback) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+#if !defined(OS_BSD)
   if (g_test_device_list.Get().get() != nullptr) {
     base::ThreadTaskRunnerHandle::Get()->PostTask(
         FROM_HERE,
@@ -33,6 +34,9 @@ void RemovableStorageProvider::GetAllDevices(DeviceListReadyCallback callback) {
        base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN},
       base::BindOnce(&RemovableStorageProvider::PopulateDeviceList),
       std::move(callback));
+#else
+  NOTIMPLEMENTED();
+#endif
 }
 
 // static
diff --git chrome/browser/extensions/api/input_ime/input_ime_api.h chrome/browser/extensions/api/input_ime/input_ime_api.h
index 385fe7c2a2..03fefb802e 100644
--- chrome/browser/extensions/api/input_ime/input_ime_api.h
+++ chrome/browser/extensions/api/input_ime/input_ime_api.h
@@ -30,7 +30,7 @@
 
 #if defined(OS_CHROMEOS)
 #include "chrome/browser/extensions/api/input_ime/input_ime_api_chromeos.h"
-#elif defined(OS_LINUX) || defined(OS_WIN)
+#elif defined(OS_LINUX) || defined(OS_WIN) || defined(OS_BSD)
 #include "chrome/browser/extensions/api/input_ime/input_ime_api_nonchromeos.h"
 #endif  // defined(OS_CHROMEOS)
 
diff --git chrome/browser/extensions/api/music_manager_private/device_id_linux.cc chrome/browser/extensions/api/music_manager_private/device_id_linux.cc
index ddc0c9a121..4f18ec0186 100644
--- chrome/browser/extensions/api/music_manager_private/device_id_linux.cc
+++ chrome/browser/extensions/api/music_manager_private/device_id_linux.cc
@@ -4,6 +4,10 @@
 
 #include "chrome/browser/extensions/api/music_manager_private/device_id.h"
 
+#if defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
+#include <sys/types.h>
+#include <net/if_dl.h>
+#endif
 #include <ifaddrs.h>
 #include <net/if.h>
 #include <stddef.h>
@@ -106,11 +110,33 @@ class MacAddressProcessor {
                         const char* const prefixes[],
                         size_t prefixes_count) {
     const int MAC_LENGTH = 6;
+#if defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
+    struct ifaddrs *ifap, *ifinfo;
+#else
     struct ifreq ifinfo;
+#endif
 
     memset(&ifinfo, 0, sizeof(ifinfo));
-    strncpy(ifinfo.ifr_name, ifaddr->ifa_name, sizeof(ifinfo.ifr_name) - 1);
 
+#if defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
+    int result = getifaddrs(&ifap);
+    if (result != 0)
+      return true;
+    result = 1; // no MAC found yet
+    for (ifinfo = ifap; ifinfo != NULL; ifinfo = ifinfo->ifa_next) {
+      struct sockaddr* sa = ifinfo->ifa_addr;
+      if (sa->sa_family == AF_LINK &&
+        !strncmp(ifinfo->ifa_name, ifaddr->ifa_name,
+        sizeof(ifinfo->ifa_name) - 1)) { 
+          result = 0;
+	  break;
+      }
+    }
+
+    char mac_address[6];
+    strncpy(mac_address, (const char*)LLADDR((struct sockaddr_dl*)ifinfo->ifa_addr), sizeof(mac_address));
+#else
+    strncpy(ifinfo.ifr_name, ifaddr->ifa_name, sizeof(ifinfo.ifr_name) - 1);
     int sd = socket(AF_INET, SOCK_DGRAM, 0);
     int result = ioctl(sd, SIOCGIFHWADDR, &ifinfo);
     close(sd);
@@ -120,11 +146,17 @@ class MacAddressProcessor {
 
     const char* mac_address =
         static_cast<const char*>(ifinfo.ifr_hwaddr.sa_data);
+#endif
     if (!is_valid_mac_address_.Run(mac_address, MAC_LENGTH))
       return true;
 
+#if defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
+    if (!IsValidPrefix(ifinfo->ifa_name, prefixes, prefixes_count))
+      return true;
+#else
     if (!IsValidPrefix(ifinfo.ifr_name, prefixes, prefixes_count))
       return true;
+#endif
 
     // Got one!
     found_mac_address_ =
diff --git chrome/browser/extensions/api/runtime/chrome_runtime_api_delegate.cc chrome/browser/extensions/api/runtime/chrome_runtime_api_delegate.cc
index b30736cadb..6a0fc22af2 100644
--- chrome/browser/extensions/api/runtime/chrome_runtime_api_delegate.cc
+++ chrome/browser/extensions/api/runtime/chrome_runtime_api_delegate.cc
@@ -269,6 +269,8 @@ bool ChromeRuntimeAPIDelegate::GetPlatformInfo(PlatformInfo* info) {
     info->os = extensions::api::runtime::PLATFORM_OS_CROS;
   } else if (strcmp(os, "linux") == 0) {
     info->os = extensions::api::runtime::PLATFORM_OS_LINUX;
+  } else if (strcmp(os, "freebsd") == 0) {
+    info->os = extensions::api::runtime::PLATFORM_OS_FREEBSD;
   } else if (strcmp(os, "openbsd") == 0) {
     info->os = extensions::api::runtime::PLATFORM_OS_OPENBSD;
   } else {
diff --git chrome/browser/extensions/api/settings_private/prefs_util.cc chrome/browser/extensions/api/settings_private/prefs_util.cc
index 70c8081978..4c7f837a91 100644
--- chrome/browser/extensions/api/settings_private/prefs_util.cc
+++ chrome/browser/extensions/api/settings_private/prefs_util.cc
@@ -122,7 +122,7 @@ const PrefsUtil::TypedPrefMap& PrefsUtil::GetWhitelistedKeys() {
       settings_api::PrefType::PREF_TYPE_BOOLEAN;
   (*s_whitelist)[bookmarks::prefs::kShowBookmarkBar] =
       settings_api::PrefType::PREF_TYPE_BOOLEAN;
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
   (*s_whitelist)[::prefs::kUseCustomChromeFrame] =
       settings_api::PrefType::PREF_TYPE_BOOLEAN;
 #endif
@@ -132,7 +132,7 @@ const PrefsUtil::TypedPrefMap& PrefsUtil::GetWhitelistedKeys() {
   // Appearance settings.
   (*s_whitelist)[::prefs::kCurrentThemeID] =
       settings_api::PrefType::PREF_TYPE_STRING;
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
   (*s_whitelist)[::prefs::kUsesSystemTheme] =
       settings_api::PrefType::PREF_TYPE_BOOLEAN;
 #endif
diff --git chrome/browser/extensions/bookmark_app_helper.cc chrome/browser/extensions/bookmark_app_helper.cc
index 7d1edb9a29..8cedb2fc0e 100644
--- chrome/browser/extensions/bookmark_app_helper.cc
+++ chrome/browser/extensions/bookmark_app_helper.cc
@@ -797,7 +797,7 @@ void BookmarkAppHelper::FinishInstallation(const Extension* extension) {
 #if !defined(OS_MACOSX)
 #if !defined(OS_CHROMEOS)
   web_app::ShortcutLocations creation_locations;
-#if defined(OS_LINUX) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_WIN) || defined(OS_BSD)
   creation_locations.on_desktop = true;
 #else
   creation_locations.on_desktop = false;
diff --git chrome/browser/extensions/browser_context_keyed_service_factories.cc chrome/browser/extensions/browser_context_keyed_service_factories.cc
index 631489e7f1..9d5ee2f4a5 100644
--- chrome/browser/extensions/browser_context_keyed_service_factories.cc
+++ chrome/browser/extensions/browser_context_keyed_service_factories.cc
@@ -57,7 +57,7 @@
 #include "chrome/browser/chromeos/extensions/media_player_api.h"
 #include "chrome/browser/extensions/api/input_ime/input_ime_api.h"
 #include "chrome/browser/extensions/api/screenlock_private/screenlock_private_api.h"
-#elif defined(OS_LINUX) || defined(OS_WIN)
+#elif defined(OS_LINUX) || defined(OS_WIN) || defined(OS_BSD)
 #include "chrome/browser/extensions/api/input_ime/input_ime_api.h"
 #endif
 
@@ -99,7 +99,7 @@ void EnsureBrowserContextKeyedServiceFactoriesBuilt() {
 #if defined(OS_CHROMEOS)
   extensions::InputImeAPI::GetFactoryInstance();
   extensions::InputMethodAPI::GetFactoryInstance();
-#elif defined(OS_LINUX) || defined(OS_WIN)
+#elif defined(OS_LINUX) || defined(OS_WIN) || defined(OS_BSD)
   extensions::InputImeAPI::GetFactoryInstance();
 #endif
   extensions::LanguageSettingsPrivateDelegateFactory::GetInstance();
diff --git chrome/browser/extensions/external_provider_impl.cc chrome/browser/extensions/external_provider_impl.cc
index db07f7a544..6cdf0effc1 100644
--- chrome/browser/extensions/external_provider_impl.cc
+++ chrome/browser/extensions/external_provider_impl.cc
@@ -689,7 +689,7 @@ void ExternalProviderImpl::CreateExternalProviders(
         Manifest::EXTERNAL_PREF, Manifest::EXTERNAL_PREF_DOWNLOAD,
         oem_extension_creation_flags));
   }
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   if (!profile->IsLegacySupervised()) {
     provider_list->push_back(std::make_unique<ExternalProviderImpl>(
         service,
@@ -717,7 +717,7 @@ void ExternalProviderImpl::CreateExternalProviders(
         bundled_extension_creation_flags));
 
     // Define a per-user source of external extensions.
-#if defined(OS_MACOSX) || (defined(OS_LINUX) && defined(CHROMIUM_BUILD))
+#if defined(OS_MACOSX) || ((defined(OS_LINUX) || defined(OS_BSD)) && defined(CHROMIUM_BUILD))
     provider_list->push_back(std::make_unique<ExternalProviderImpl>(
         service,
         new ExternalPrefLoader(chrome::DIR_USER_EXTERNAL_EXTENSIONS,
diff --git chrome/browser/first_run/first_run_internal_posix.cc chrome/browser/first_run/first_run_internal_posix.cc
index ec17ddf4a6..1e1bec242c 100644
--- chrome/browser/first_run/first_run_internal_posix.cc
+++ chrome/browser/first_run/first_run_internal_posix.cc
@@ -34,7 +34,7 @@ base::OnceClosure& GetBeforeShowFirstRunDialogHookForTesting() {
 namespace internal {
 namespace {
 
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_BSD)
 // Returns whether the first run dialog should be shown. This is only true for
 // certain builds, and only if the user has not already set preferences. In a
 // real, official-build first run, initializes the default metrics reporting if
@@ -80,7 +80,7 @@ bool ShouldShowFirstRunDialog() {
 }  // namespace
 
 void DoPostImportPlatformSpecificTasks(Profile* profile) {
-#if !defined(OS_CHROMEOS)
+#if !defined(OS_CHROMEOS) && !defined(OS_BSD)
   if (!ShouldShowFirstRunDialog())
     return;
 
diff --git chrome/browser/flag_descriptions.cc chrome/browser/flag_descriptions.cc
index f4b60cdab7..6209dd109d 100644
--- chrome/browser/flag_descriptions.cc
+++ chrome/browser/flag_descriptions.cc
@@ -3126,7 +3126,7 @@ const char kZipArchiverUnpackerDescription[] =
 
 // Random platform combinations -----------------------------------------------
 
-#if defined(OS_WIN) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_BSD)
 
 const char kEnableInputImeApiName[] = "Enable Input IME API";
 const char kEnableInputImeApiDescription[] =
diff --git chrome/browser/flag_descriptions.h chrome/browser/flag_descriptions.h
index de5079e304..32c09fa514 100644
--- chrome/browser/flag_descriptions.h
+++ chrome/browser/flag_descriptions.h
@@ -1919,7 +1919,7 @@ extern const char kZipArchiverUnpackerDescription[];
 
 // Random platform combinations -----------------------------------------------
 
-#if defined(OS_WIN) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_BSD)
 
 extern const char kEnableInputImeApiName[];
 extern const char kEnableInputImeApiDescription[];
@@ -1931,7 +1931,7 @@ extern const char kWarnBeforeQuittingFlagDescription[];
 
 #endif  // !defined(OS_CHROMEOS)
 
-#endif  // defined(OS_WIN) || defined(OS_LINUX)
+#endif  // defined(OS_WIN) || defined(OS_LINUX) || defined(OS_BSD)
 
 #if defined(OS_WIN) || defined(OS_MACOSX)
 
diff --git chrome/browser/media/router/discovery/discovery_network_list_posix.cc chrome/browser/media/router/discovery/discovery_network_list_posix.cc
index d177de5b1d..3f209d922a 100644
--- chrome/browser/media/router/discovery/discovery_network_list_posix.cc
+++ chrome/browser/media/router/discovery/discovery_network_list_posix.cc
@@ -10,6 +10,7 @@
 #include <netinet/in.h>
 #include <sys/socket.h>
 #include <sys/types.h>
+#include <sys/time.h>
 
 #include <algorithm>
 
@@ -19,7 +20,7 @@
 #include "chrome/browser/media/router/discovery/discovery_network_list_wifi.h"
 #include "net/base/net_errors.h"
 
-#if !defined(OS_MACOSX)
+#if !defined(OS_MACOSX) && !defined(OS_BSD)
 #include <netpacket/packet.h>
 #else
 #include <net/if_dl.h>
@@ -28,7 +29,7 @@
 namespace media_router {
 namespace {
 
-#if !defined(OS_MACOSX)
+#if !defined(OS_MACOSX) && !defined(OS_BSD)
 using sll = struct sockaddr_ll;
 #define SOCKET_ARP_TYPE(s) ((s)->sll_hatype)
 #define SOCKET_ADDRESS_LEN(s) ((s)->sll_halen)
diff --git chrome/browser/media/router/discovery/discovery_network_list_wifi_linux.cc chrome/browser/media/router/discovery/discovery_network_list_wifi_linux.cc
index ed40c44f30..46db000cf8 100644
--- chrome/browser/media/router/discovery/discovery_network_list_wifi_linux.cc
+++ chrome/browser/media/router/discovery/discovery_network_list_wifi_linux.cc
@@ -9,8 +9,6 @@
 #include <sys/socket.h>
 #include <sys/types.h>
 
-#include <linux/wireless.h>
-
 #include "base/files/scoped_file.h"
 #include "base/logging.h"
 #include "net/base/network_interfaces_linux.h"
@@ -20,6 +18,7 @@ namespace media_router {
 bool MaybeGetWifiSSID(const std::string& if_name, std::string* ssid_out) {
   DCHECK(ssid_out);
 
+#if !defined(OS_BSD)
   base::ScopedFD ioctl_socket(socket(AF_INET, SOCK_DGRAM, 0));
   if (!ioctl_socket.is_valid()) {
     // AF_INET is for IPv4, so it may fail for IPv6-only hosts even when there
@@ -41,6 +40,7 @@ bool MaybeGetWifiSSID(const std::string& if_name, std::string* ssid_out) {
     ssid_out->assign(ssid);
     return true;
   }
+#endif
   return false;
 }
 
diff --git chrome/browser/media/router/providers/wired_display/wired_display_media_route_provider.cc chrome/browser/media/router/providers/wired_display/wired_display_media_route_provider.cc
index b1e9447c63..3ea4712ee2 100644
--- chrome/browser/media/router/providers/wired_display/wired_display_media_route_provider.cc
+++ chrome/browser/media/router/providers/wired_display/wired_display_media_route_provider.cc
@@ -111,6 +111,11 @@ void WiredDisplayMediaRouteProvider::CreateRoute(
     bool incognito,
     CreateRouteCallback callback) {
   DCHECK(!base::ContainsKey(presentations_, presentation_id));
+#if defined(OS_BSD) // XXX
+   std::move(callback).Run(base::nullopt, std::string("Not implemented"),
+                           RouteRequestResult::UNKNOWN_ERROR);
+   return;
+#else
   base::Optional<Display> display = GetDisplayBySinkId(sink_id);
   if (!display) {
     std::move(callback).Run(base::nullopt, std::string("Display not found"),
@@ -135,6 +140,7 @@ void WiredDisplayMediaRouteProvider::CreateRoute(
   presentation.receiver()->Start(presentation_id, GURL(media_source));
   std::move(callback).Run(route, base::nullopt, RouteRequestResult::OK);
   NotifyRouteObservers();
+#endif
 }
 
 void WiredDisplayMediaRouteProvider::JoinRoute(
diff --git chrome/browser/media/webrtc/webrtc_event_log_uploader.cc chrome/browser/media/webrtc/webrtc_event_log_uploader.cc
index 4ecea498e8..f91835fa3e 100644
--- chrome/browser/media/webrtc/webrtc_event_log_uploader.cc
+++ chrome/browser/media/webrtc/webrtc_event_log_uploader.cc
@@ -51,7 +51,7 @@ constexpr size_t kExpectedMimeOverheadBytes = 1000;  // Intentional overshot.
 const char kProduct[] = "Chrome";
 #elif defined(OS_MACOSX)
 const char kProduct[] = "Chrome_Mac";
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
 const char kProduct[] = "Chrome_Linux";
 #elif defined(OS_ANDROID)
 const char kProduct[] = "Chrome_Android";
diff --git chrome/browser/media/webrtc/webrtc_log_uploader.cc chrome/browser/media/webrtc/webrtc_log_uploader.cc
index 7f25f2adc8..e727e9566e 100644
--- chrome/browser/media/webrtc/webrtc_log_uploader.cc
+++ chrome/browser/media/webrtc/webrtc_log_uploader.cc
@@ -345,6 +345,10 @@ void WebRtcLogUploader::SetupMultipart(
   const char product[] = "Chrome_Android";
 #elif defined(OS_CHROMEOS)
   const char product[] = "Chrome_ChromeOS";
+#elif defined(OS_FREEBSD)
+  const char product[] = "Chrome_FreeBSD";
+#elif defined(OS_DRAGONFLY)
+  const char product[] = "Chrome_DragonFly";
 #else
 #error Platform not supported.
 #endif
diff --git chrome/browser/media_galleries/fileapi/mtp_device_map_service.cc chrome/browser/media_galleries/fileapi/mtp_device_map_service.cc
index f877b9751b..79013a1209 100644
--- chrome/browser/media_galleries/fileapi/mtp_device_map_service.cc
+++ chrome/browser/media_galleries/fileapi/mtp_device_map_service.cc
@@ -38,10 +38,12 @@ void MTPDeviceMapService::RegisterMTPFileSystem(
     // Note that this initializes the delegate asynchronously, but since
     // the delegate will only be used from the IO thread, it is guaranteed
     // to be created before use of it expects it to be there.
+#if !defined(OS_FREEBSD)
     CreateMTPDeviceAsyncDelegate(
         device_location, read_only,
         base::Bind(&MTPDeviceMapService::AddAsyncDelegate,
                    base::Unretained(this), device_location, read_only));
+#endif
     mtp_device_usage_map_[key] = 0;
   }
 
diff --git chrome/browser/media_galleries/media_file_system_registry.cc chrome/browser/media_galleries/media_file_system_registry.cc
index d9e1947db8..f2d8defc52 100644
--- chrome/browser/media_galleries/media_file_system_registry.cc
+++ chrome/browser/media_galleries/media_file_system_registry.cc
@@ -739,7 +739,10 @@ class MediaFileSystemRegistry::MediaFileSystemContextImpl
 // Constructor in 'private' section because depends on private class definition.
 MediaFileSystemRegistry::MediaFileSystemRegistry()
     : file_system_context_(new MediaFileSystemContextImpl) {
-  StorageMonitor::GetInstance()->AddObserver(this);
+  // This conditional is needed for shutdown.  Destructors
+  // try to get the media file system registry.
+  if (StorageMonitor::GetInstance())
+    StorageMonitor::GetInstance()->AddObserver(this);
 }
 
 MediaFileSystemRegistry::~MediaFileSystemRegistry() {
diff --git chrome/browser/memory_details.cc chrome/browser/memory_details.cc
index 509b62c783..4f3623b191 100644
--- chrome/browser/memory_details.cc
+++ chrome/browser/memory_details.cc
@@ -36,7 +36,7 @@
 #include "services/resource_coordinator/public/cpp/memory_instrumentation/memory_instrumentation.h"
 #include "ui/base/l10n/l10n_util.h"
 
-#if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_ANDROID)
+#if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_ANDROID) && !defined(OS_BSD)
 #include "services/service_manager/zygote/zygote_host_linux.h"
 #endif
 
@@ -341,7 +341,7 @@ void MemoryDetails::CollectChildInfoOnUIThread() {
       process.titles.push_back(title);
     }
 
-#if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_ANDROID)
+#if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_ANDROID) && !defined(OS_BSD)
     if (service_manager::ZygoteHost::GetInstance()->IsZygotePid(process.pid)) {
       process.process_type = content::PROCESS_TYPE_ZYGOTE;
     }
diff --git chrome/browser/memory_details_linux.cc chrome/browser/memory_details_linux.cc
index 2cc9a8c29c..832d00dc0e 100644
--- chrome/browser/memory_details_linux.cc
+++ chrome/browser/memory_details_linux.cc
@@ -70,8 +70,10 @@ ProcessData GetProcessDataMemoryInformation(
 
     std::unique_ptr<base::ProcessMetrics> metrics(
         base::ProcessMetrics::CreateProcessMetrics(pid));
+#if !defined(OS_BSD)
     pmi.num_open_fds = metrics->GetOpenFdCount();
     pmi.open_fds_soft_limit = metrics->GetOpenFdSoftLimit();
+#endif
 
     process_data.processes.push_back(pmi);
   }
diff --git chrome/browser/metrics/chrome_browser_main_extra_parts_metrics.cc chrome/browser/metrics/chrome_browser_main_extra_parts_metrics.cc
index e4ae467ac5..56d07e30b4 100644
--- chrome/browser/metrics/chrome_browser_main_extra_parts_metrics.cc
+++ chrome/browser/metrics/chrome_browser_main_extra_parts_metrics.cc
@@ -44,7 +44,9 @@
 
 #if defined(OS_LINUX) && !defined(OS_CHROMEOS)
 #include <gnu/libc-version.h>
+#endif
 
+#if (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_BSD)
 #include "base/linux_util.h"
 #include "base/strings/string_split.h"
 #include "base/strings/string_util.h"
@@ -52,7 +54,7 @@
 #if defined(USE_X11)
 #include "ui/base/x/x11_util.h"
 #endif
-#endif  // defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#endif  // defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_BSD)
 
 #if defined(USE_OZONE) || defined(USE_X11)
 #include "ui/events/devices/input_device_event_observer.h"
diff --git chrome/browser/notifications/message_center_notification_manager.cc chrome/browser/notifications/message_center_notification_manager.cc
index f36d4de0f5..483a61f72d 100644
--- chrome/browser/notifications/message_center_notification_manager.cc
+++ chrome/browser/notifications/message_center_notification_manager.cc
@@ -46,7 +46,7 @@ MessageCenterNotificationManager::MessageCenterNotificationManager()
 #endif
 
 #if defined(OS_WIN) || defined(OS_MACOSX) \
-  || (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+  || (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_BSD)
   // On Windows, Linux and Mac, the notification manager owns the tray icon and
   // views.Other platforms have global ownership and Create will return NULL.
   tray_.reset(CreateUiDelegate());
diff --git chrome/browser/password_manager/chrome_password_manager_client.cc chrome/browser/password_manager/chrome_password_manager_client.cc
index e2e81b87d0..dd8574bc09 100644
--- chrome/browser/password_manager/chrome_password_manager_client.cc
+++ chrome/browser/password_manager/chrome_password_manager_client.cc
@@ -69,7 +69,11 @@
 #include "net/base/url_util.h"
 #include "net/cert/cert_status_flags.h"
 #include "services/metrics/public/cpp/ukm_recorder.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 #include "url/url_constants.h"
 
 #if defined(SAFE_BROWSING_DB_LOCAL)
diff --git chrome/browser/platform_util.h chrome/browser/platform_util.h
index afdb5fda6b..e002e90a40 100644
--- chrome/browser/platform_util.h
+++ chrome/browser/platform_util.h
@@ -40,7 +40,7 @@ enum OpenOperationResult {
 enum OpenItemType {
   OPEN_FILE,
   OPEN_FOLDER,
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   SHOW_ITEM_IN_FOLDER
 #endif
 };
diff --git chrome/browser/plugins/plugins_resource_service.cc chrome/browser/plugins/plugins_resource_service.cc
index 6f49c3de23..a3c0b1ea1e 100644
--- chrome/browser/plugins/plugins_resource_service.cc
+++ chrome/browser/plugins/plugins_resource_service.cc
@@ -60,7 +60,7 @@ GURL GetPluginsServerURL() {
   filename = "plugins_win.json";
 #elif defined(OS_CHROMEOS)
   filename = "plugins_chromeos.json";
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   filename = "plugins_linux.json";
 #elif defined(OS_MACOSX)
   filename = "plugins_mac.json";
diff --git chrome/browser/policy/policy_prefs_browsertest.cc chrome/browser/policy/policy_prefs_browsertest.cc
index 14c8927e41..1b7fbe3ccc 100644
--- chrome/browser/policy/policy_prefs_browsertest.cc
+++ chrome/browser/policy/policy_prefs_browsertest.cc
@@ -185,6 +185,8 @@ class PolicyTestCase {
     const std::string os("chromeos");
 #elif defined(OS_LINUX)
     const std::string os("linux");
+#elif defined(OS_FREEBSD)
+    const std::string os("freebsd");
 #else
 #error "Unknown platform"
 #endif
diff --git chrome/browser/process_singleton_posix.cc chrome/browser/process_singleton_posix.cc
index 330ec23acf..84dc6d46da 100644
--- chrome/browser/process_singleton_posix.cc
+++ chrome/browser/process_singleton_posix.cc
@@ -91,11 +91,11 @@
 #include "net/base/network_interfaces.h"
 #include "ui/base/l10n/l10n_util.h"
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include "chrome/browser/ui/process_singleton_dialog_linux.h"
 #endif
 
-#if defined(TOOLKIT_VIEWS) && defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(TOOLKIT_VIEWS) && (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
 #include "ui/views/linux_ui/linux_ui.h"
 #endif
 
@@ -323,7 +323,7 @@ bool DisplayProfileInUseError(const base::FilePath& lock_path,
   if (g_disable_prompt)
     return g_user_opted_unlock_in_use_profile;
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   base::string16 relaunch_button_text = l10n_util::GetStringUTF16(
       IDS_PROFILE_IN_USE_LINUX_RELAUNCH);
   return ShowProcessSingletonDialog(error, relaunch_button_text);
@@ -903,7 +903,7 @@ ProcessSingleton::NotifyResult ProcessSingleton::NotifyOtherProcessWithTimeout(
     SendRemoteProcessInteractionResultHistogram(REMOTE_PROCESS_SHUTTING_DOWN);
     return PROCESS_NONE;
   } else if (strncmp(buf, kACKToken, arraysize(kACKToken) - 1) == 0) {
-#if defined(TOOLKIT_VIEWS) && defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(TOOLKIT_VIEWS) && (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
     // Likely NULL in unit tests.
     views::LinuxUI* linux_ui = views::LinuxUI::instance();
     if (linux_ui)
diff --git chrome/browser/renderer_context_menu/render_view_context_menu.cc chrome/browser/renderer_context_menu/render_view_context_menu.cc
index 21bb03f537..bb8da9ef76 100644
--- chrome/browser/renderer_context_menu/render_view_context_menu.cc
+++ chrome/browser/renderer_context_menu/render_view_context_menu.cc
@@ -1428,7 +1428,7 @@ void RenderViewContextMenu::AppendEditableItems() {
 // 'Undo' and 'Redo' for text input with no suggestions and no text selected.
 // We make an exception for OS X as context clicking will select the closest
 // word. In this case both items are always shown.
-#if defined(OS_MACOSX)
+#if defined(OS_MACOSX) || defined(OS_BSD)
   menu_model_.AddItemWithStringId(IDC_CONTENT_CONTEXT_UNDO,
                                   IDS_CONTENT_CONTEXT_UNDO);
   menu_model_.AddItemWithStringId(IDC_CONTENT_CONTEXT_REDO,
@@ -1470,7 +1470,7 @@ void RenderViewContextMenu::AppendLanguageSettings() {
   if (!use_spelling)
     return;
 
-#if defined(OS_MACOSX)
+#if defined(OS_MACOSX) || defined(OS_BSD)
   menu_model_.AddItemWithStringId(IDC_CONTENT_CONTEXT_LANGUAGE_SETTINGS,
                                   IDS_CONTENT_CONTEXT_LANGUAGE_SETTINGS);
 #else
@@ -1734,7 +1734,7 @@ bool RenderViewContextMenu::IsCommandIdEnabled(int id) const {
     case IDC_CHECK_SPELLING_WHILE_TYPING:
       return prefs->GetBoolean(spellcheck::prefs::kSpellCheckEnable);
 
-#if !defined(OS_MACOSX) && defined(OS_POSIX)
+#if !defined(OS_MACOSX) && !defined(OS_BSD) && defined(OS_POSIX)
     // TODO(suzhe): this should not be enabled for password fields.
     case IDC_INPUT_METHODS_MENU:
       return true;
diff --git chrome/browser/renderer_preferences_util.cc chrome/browser/renderer_preferences_util.cc
index e0fa371f0a..1ac7c1c956 100644
--- chrome/browser/renderer_preferences_util.cc
+++ chrome/browser/renderer_preferences_util.cc
@@ -20,7 +20,7 @@
 #include "third_party/blink/public/public_buildflags.h"
 #include "third_party/skia/include/core/SkColor.h"
 
-#if defined(OS_LINUX) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_BSD)
 #include "ui/gfx/font_render_params.h"
 #endif
 
@@ -32,7 +32,7 @@
 #include "ui/base/cocoa/defaults_utils.h"
 #endif
 
-#if defined(USE_AURA) && defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(USE_AURA) && (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
 #include "chrome/browser/themes/theme_service.h"
 #include "chrome/browser/themes/theme_service_factory.h"
 #include "ui/views/linux_ui/linux_ui.h"
@@ -132,7 +132,7 @@ void UpdateFromSystemSettings(content::RendererPreferences* prefs,
     prefs->caret_blink_interval = interval;
 #endif
 
-#if defined(USE_AURA) && defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(USE_AURA) && (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
   views::LinuxUI* linux_ui = views::LinuxUI::instance();
   if (linux_ui) {
     if (ThemeServiceFactory::GetForProfile(profile)->UsingSystemTheme()) {
@@ -154,7 +154,7 @@ void UpdateFromSystemSettings(content::RendererPreferences* prefs,
   }
 #endif
 
-#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_WIN) || defined(OS_BSD)
   CR_DEFINE_STATIC_LOCAL(const gfx::FontRenderParams, params,
       (gfx::GetFontRenderParams(gfx::FontRenderParamsQuery(), NULL)));
   prefs->should_antialias_text = params.antialiasing;
diff --git chrome/browser/resources/safe_browsing/gen_file_type_proto.py chrome/browser/resources/safe_browsing/gen_file_type_proto.py
index 651ed98dad..76501d73e4 100755
--- chrome/browser/resources/safe_browsing/gen_file_type_proto.py
+++ chrome/browser/resources/safe_browsing/gen_file_type_proto.py
@@ -31,6 +31,7 @@ def PlatformTypes():
     "android": download_file_types_pb2.DownloadFileType.PLATFORM_ANDROID,
     "chromeos": download_file_types_pb2.DownloadFileType.PLATFORM_CHROME_OS,
     "linux": download_file_types_pb2.DownloadFileType.PLATFORM_LINUX,
+    "bsd": download_file_types_pb2.DownloadFileType.PLATFORM_LINUX,
     "mac": download_file_types_pb2.DownloadFileType.PLATFORM_MAC,
     "win": download_file_types_pb2.DownloadFileType.PLATFORM_WINDOWS,
   }
@@ -169,7 +170,7 @@ class DownloadFileTypeProtoGenerator(BinaryProtoGenerator):
                       'Outfile must have a %d for version and %s for platform.')
     parser.add_option('-t', '--type',
                       help='The platform type. One of android, chromeos, ' +
-                      'linux, mac, win')
+                      'linux, bsd, mac, win')
 
   def AddExtraCommandLineArgsForVirtualEnvRun(self, opts, command):
     if opts.type is not None:
diff --git chrome/browser/resources/settings/appearance_page/appearance_page.html chrome/browser/resources/settings/appearance_page/appearance_page.html
index dbe25f5001..b5f9654f8e 100644
--- chrome/browser/resources/settings/appearance_page/appearance_page.html
+++ chrome/browser/resources/settings/appearance_page/appearance_page.html
@@ -71,7 +71,7 @@
               hidden="[[!pageVisibility.setTheme]]"
               label="$i18n{themes}" sub-label="[[themeSublabel_]]"
               on-click="openThemeUrl_"></cr-link-row>
-<if expr="not is_linux or chromeos">
+<if expr="not is_posix or chromeos">
           <template is="dom-if" if="[[prefs.extensions.theme.id.value]]">
             <div class="separator"></div>
             <paper-button id="useDefault" on-click="onUseDefaultTap_"
@@ -80,7 +80,7 @@
             </paper-button>
           </template>
 </if>
-<if expr="is_linux and not chromeos">
+<if expr="is_posix and not chromeos">
           <div class="settings-row continuation"
               hidden="[[!showThemesSecondary_(
               prefs.extensions.theme.id.value, useSystemTheme_)]]"
@@ -145,7 +145,7 @@
             pref="{{prefs.bookmark_bar.show_on_all_tabs}}"
             label="$i18n{showBookmarksBar}">
         </settings-toggle-button>
-<if expr="is_linux and not chromeos">
+<if expr="is_posix and not chromeos">
         <settings-toggle-button
             class$="[[getFirst_(pageVisibility.bookmarksBar)]]"
             pref="{{prefs.browser.custom_chrome_frame}}"
diff --git chrome/browser/safe_browsing/incident_reporting/incident_handler_util.cc chrome/browser/safe_browsing/incident_reporting/incident_handler_util.cc
index fe5605e1df..2eec5c4e81 100644
--- chrome/browser/safe_browsing/incident_reporting/incident_handler_util.cc
+++ chrome/browser/safe_browsing/incident_reporting/incident_handler_util.cc
@@ -8,7 +8,12 @@
 
 #include "base/hash.h"
 #include "base/logging.h"
+//XXX(rene) needs shim headers?
+#if defined(USE_SYSTEM_PROTOBUF)
+#include <google/protobuf/message_lite.h>
+#else
 #include "third_party/protobuf/src/google/protobuf/message_lite.h"
+#endif
 
 namespace safe_browsing {
 
diff --git chrome/browser/safe_browsing/incident_reporting/incident_reporting_service.cc chrome/browser/safe_browsing/incident_reporting/incident_reporting_service.cc
index 57e1df9c63..ced9e12fb7 100644
--- chrome/browser/safe_browsing/incident_reporting/incident_reporting_service.cc
+++ chrome/browser/safe_browsing/incident_reporting/incident_reporting_service.cc
@@ -715,7 +715,7 @@ void IncidentReportingService::OnEnvironmentDataCollected(
   environment_collection_pending_ = false;
 
 // CurrentProcessInfo::CreationTime() is missing on some platforms.
-#if defined(OS_MACOSX) || defined(OS_WIN) || defined(OS_LINUX)
+#if defined(OS_MACOSX) || defined(OS_WIN) || defined(OS_LINUX) || defined(OS_BSD)
   base::TimeDelta uptime =
       first_incident_time_ - base::CurrentProcessInfo::CreationTime();
   environment_data->mutable_process()->set_uptime_msec(uptime.InMilliseconds());
diff --git chrome/browser/search/local_files_ntp_source.cc chrome/browser/search/local_files_ntp_source.cc
index d3d66eee0f..4e7d3f42d8 100644
--- chrome/browser/search/local_files_ntp_source.cc
+++ chrome/browser/search/local_files_ntp_source.cc
@@ -20,8 +20,13 @@
 #include "build/build_config.h"
 #include "chrome/common/url_constants.h"
 #include "content/public/browser/url_data_source.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#include <re2/stringpiece.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
 #include "third_party/re2/src/re2/stringpiece.h"
+#endif
 
 namespace {
 
diff --git chrome/browser/speech/tts_controller_impl.cc chrome/browser/speech/tts_controller_impl.cc
index 692a736b1f..9f60b71c01 100644
--- chrome/browser/speech/tts_controller_impl.cc
+++ chrome/browser/speech/tts_controller_impl.cc
@@ -446,9 +446,13 @@ int TtsControllerImpl::QueueSize() {
 }
 
 TtsPlatformImpl* TtsControllerImpl::GetPlatformImpl() {
+#if defined(OS_BSD)
+  return NULL;
+#else
   if (!platform_impl_)
     platform_impl_ = TtsPlatformImpl::GetInstance();
   return platform_impl_;
+#endif
 }
 
 int TtsControllerImpl::GetMatchingVoice(
diff --git chrome/browser/ssl/ssl_error_controller_client.cc chrome/browser/ssl/ssl_error_controller_client.cc
index ee226e9ff1..bfb00da3cb 100644
--- chrome/browser/ssl/ssl_error_controller_client.cc
+++ chrome/browser/ssl/ssl_error_controller_client.cc
@@ -67,7 +67,7 @@ void LaunchDateAndTimeSettingsImpl() {
 #if defined(OS_ANDROID)
   chrome::android::OpenDateAndTimeSettings();
 
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   struct ClockCommand {
     const char* const pathname;
     const char* const argument;
@@ -213,7 +213,7 @@ void SSLErrorControllerClient::Proceed() {
 
 bool SSLErrorControllerClient::CanLaunchDateAndTimeSettings() {
 #if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_MACOSX) || \
-    defined(OS_WIN)
+    defined(OS_WIN) || defined(OS_BSD)
   return true;
 #else
   return false;
diff --git chrome/browser/sync/chrome_sync_client.cc chrome/browser/sync/chrome_sync_client.cc
index 9838d0c7a9..3ba5ba1380 100644
--- chrome/browser/sync/chrome_sync_client.cc
+++ chrome/browser/sync/chrome_sync_client.cc
@@ -634,7 +634,7 @@ void ChromeSyncClient::RegisterDesktopDataTypes(
           BrowserThread::GetTaskRunnerForThread(BrowserThread::UI)));
 #endif  // BUILDFLAG(ENABLE_APP_LIST)
 
-#if defined(OS_LINUX) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_WIN) || defined(OS_BSD)
   // Dictionary sync is enabled by default.
   if (!disabled_types.Has(syncer::DICTIONARY)) {
     sync_service->RegisterDataTypeController(
@@ -642,7 +642,7 @@ void ChromeSyncClient::RegisterDesktopDataTypes(
             syncer::DICTIONARY, error_callback, this, syncer::GROUP_UI,
             BrowserThread::GetTaskRunnerForThread(BrowserThread::UI)));
   }
-#endif  // defined(OS_LINUX) || defined(OS_WIN)
+#endif  // defined(OS_LINUX) || defined(OS_WIN) || defined(OS_BSD)
 
 #if BUILDFLAG(ENABLE_SUPERVISED_USERS)
   sync_service->RegisterDataTypeController(
diff --git chrome/browser/task_manager/sampling/task_group.cc chrome/browser/task_manager/sampling/task_group.cc
index 3c3dccdc5e..d9649a4395 100644
--- chrome/browser/task_manager/sampling/task_group.cc
+++ chrome/browser/task_manager/sampling/task_group.cc
@@ -32,9 +32,9 @@ const int kBackgroundRefreshTypesMask =
 #if defined(OS_WIN)
     REFRESH_TYPE_START_TIME | REFRESH_TYPE_CPU_TIME |
 #endif  // defined(OS_WIN)
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     REFRESH_TYPE_FD_COUNT |
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
 #if BUILDFLAG(ENABLE_NACL)
     REFRESH_TYPE_NACL |
 #endif  // BUILDFLAG(ENABLE_NACL)
@@ -109,9 +109,9 @@ TaskGroup::TaskGroup(
 #if BUILDFLAG(ENABLE_NACL)
       nacl_debug_stub_port_(nacl::kGdbDebugStubPortUnknown),
 #endif  // BUILDFLAG(ENABLE_NACL)
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
       open_fd_count_(-1),
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
       idle_wakeups_per_second_(-1),
       gpu_memory_has_duplicates_(false),
       is_backgrounded_(false),
@@ -125,10 +125,10 @@ TaskGroup::TaskGroup(
                    weak_ptr_factory_.GetWeakPtr()),
         base::Bind(&TaskGroup::OnIdleWakeupsRefreshDone,
                    weak_ptr_factory_.GetWeakPtr()),
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
         base::Bind(&TaskGroup::OnOpenFdCountRefreshDone,
                    weak_ptr_factory_.GetWeakPtr()),
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
         base::Bind(&TaskGroup::OnProcessPriorityDone,
                    weak_ptr_factory_.GetWeakPtr()));
 
@@ -288,14 +288,14 @@ void TaskGroup::OnRefreshNaClDebugStubPortDone(int nacl_debug_stub_port) {
 }
 #endif  // BUILDFLAG(ENABLE_NACL)
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 void TaskGroup::OnOpenFdCountRefreshDone(int open_fd_count) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   open_fd_count_ = open_fd_count;
   OnBackgroundRefreshTypeFinished(REFRESH_TYPE_FD_COUNT);
 }
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
 
 void TaskGroup::OnCpuRefreshDone(double cpu_usage) {
   DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
diff --git chrome/browser/task_manager/sampling/task_group.h chrome/browser/task_manager/sampling/task_group.h
index 7778af1119..459b68debe 100644
--- chrome/browser/task_manager/sampling/task_group.h
+++ chrome/browser/task_manager/sampling/task_group.h
@@ -103,9 +103,9 @@ class TaskGroup {
   int nacl_debug_stub_port() const { return nacl_debug_stub_port_; }
 #endif  // BUILDFLAG(ENABLE_NACL)
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   int open_fd_count() const { return open_fd_count_; }
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
 
   int idle_wakeups_per_second() const { return idle_wakeups_per_second_; }
 
@@ -119,9 +119,9 @@ class TaskGroup {
   void RefreshNaClDebugStubPort(int child_process_unique_id);
   void OnRefreshNaClDebugStubPortDone(int port);
 #endif
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   void OnOpenFdCountRefreshDone(int open_fd_count);
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
 
   void OnCpuRefreshDone(double cpu_usage);
   void OnSwappedMemRefreshDone(int64_t swapped_mem_bytes);
@@ -181,10 +181,10 @@ class TaskGroup {
 #if BUILDFLAG(ENABLE_NACL)
   int nacl_debug_stub_port_;
 #endif  // BUILDFLAG(ENABLE_NACL)
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // The number of file descriptors currently open by the process.
   int open_fd_count_;
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
   int idle_wakeups_per_second_;
   bool gpu_memory_has_duplicates_;
   bool is_backgrounded_;
diff --git chrome/browser/task_manager/sampling/task_group_sampler.cc chrome/browser/task_manager/sampling/task_group_sampler.cc
index c838e91982..eefd4d0e56 100644
--- chrome/browser/task_manager/sampling/task_group_sampler.cc
+++ chrome/browser/task_manager/sampling/task_group_sampler.cc
@@ -42,9 +42,9 @@ TaskGroupSampler::TaskGroupSampler(
     const OnCpuRefreshCallback& on_cpu_refresh,
     const OnSwappedMemRefreshCallback& on_swapped_mem_refresh,
     const OnIdleWakeupsCallback& on_idle_wakeups,
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     const OnOpenFdCountCallback& on_open_fd_count,
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
     const OnProcessPriorityCallback& on_process_priority)
     : process_(std::move(process)),
       process_metrics_(CreateProcessMetrics(process_.Handle())),
@@ -52,9 +52,9 @@ TaskGroupSampler::TaskGroupSampler(
       on_cpu_refresh_callback_(on_cpu_refresh),
       on_swapped_mem_refresh_callback_(on_swapped_mem_refresh),
       on_idle_wakeups_callback_(on_idle_wakeups),
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
       on_open_fd_count_callback_(on_open_fd_count),
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
       on_process_priority_callback_(on_process_priority) {
   DCHECK(blocking_pool_runner.get());
 
@@ -85,7 +85,7 @@ void TaskGroupSampler::Refresh(int64_t refresh_flags) {
         on_swapped_mem_refresh_callback_);
   }
 
-#if defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
   if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_IDLE_WAKEUPS,
                                                     refresh_flags)) {
     base::PostTaskAndReplyWithResult(
@@ -94,7 +94,7 @@ void TaskGroupSampler::Refresh(int64_t refresh_flags) {
         base::Bind(&TaskGroupSampler::RefreshIdleWakeupsPerSecond, this),
         on_idle_wakeups_callback_);
   }
-#endif  // defined(OS_MACOSX) || defined(OS_LINUX)
+#endif  // defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
 
 #if defined(OS_LINUX)
   if (TaskManagerObserver::IsResourceRefreshEnabled(REFRESH_TYPE_FD_COUNT,
diff --git chrome/browser/task_manager/sampling/task_group_sampler.h chrome/browser/task_manager/sampling/task_group_sampler.h
index c0c6241668..0c19e70286 100644
--- chrome/browser/task_manager/sampling/task_group_sampler.h
+++ chrome/browser/task_manager/sampling/task_group_sampler.h
@@ -32,9 +32,9 @@ class TaskGroupSampler : public base::RefCountedThreadSafe<TaskGroupSampler> {
   using OnCpuRefreshCallback = base::Callback<void(double)>;
   using OnSwappedMemRefreshCallback = base::Callback<void(int64_t)>;
   using OnIdleWakeupsCallback = base::Callback<void(int)>;
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   using OnOpenFdCountCallback = base::Callback<void(int)>;
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
   using OnProcessPriorityCallback = base::Callback<void(bool)>;
 
   TaskGroupSampler(
@@ -43,9 +43,9 @@ class TaskGroupSampler : public base::RefCountedThreadSafe<TaskGroupSampler> {
       const OnCpuRefreshCallback& on_cpu_refresh,
       const OnSwappedMemRefreshCallback& on_memory_refresh,
       const OnIdleWakeupsCallback& on_idle_wakeups,
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
       const OnOpenFdCountCallback& on_open_fd_count,
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
       const OnProcessPriorityCallback& on_process_priority);
 
   // Refreshes the expensive process' stats (CPU usage, memory usage, and idle
@@ -60,9 +60,9 @@ class TaskGroupSampler : public base::RefCountedThreadSafe<TaskGroupSampler> {
   double RefreshCpuUsage();
   int64_t RefreshSwappedMem();
   int RefreshIdleWakeupsPerSecond();
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   int RefreshOpenFdCount();
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
   bool RefreshProcessPriority();
 
   // The process that holds the handle that we own so that we can use it for
@@ -80,9 +80,9 @@ class TaskGroupSampler : public base::RefCountedThreadSafe<TaskGroupSampler> {
   const OnCpuRefreshCallback on_cpu_refresh_callback_;
   const OnSwappedMemRefreshCallback on_swapped_mem_refresh_callback_;
   const OnIdleWakeupsCallback on_idle_wakeups_callback_;
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   const OnOpenFdCountCallback on_open_fd_count_callback_;
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
   const OnProcessPriorityCallback on_process_priority_callback_;
 
   // To assert we're running on the correct thread.
diff --git chrome/browser/task_manager/sampling/task_manager_impl.cc chrome/browser/task_manager/sampling/task_manager_impl.cc
index dfea4eabe5..33b3f1147f 100644
--- chrome/browser/task_manager/sampling/task_manager_impl.cc
+++ chrome/browser/task_manager/sampling/task_manager_impl.cc
@@ -205,11 +205,11 @@ void TaskManagerImpl::GetUSERHandles(TaskId task_id,
 }
 
 int TaskManagerImpl::GetOpenFdCount(TaskId task_id) const {
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   return GetTaskGroupByTaskId(task_id)->open_fd_count();
 #else
   return -1;
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
 }
 
 bool TaskManagerImpl::IsTaskOnBackgroundedProcess(TaskId task_id) const {
diff --git chrome/browser/task_manager/task_manager_observer.h chrome/browser/task_manager/task_manager_observer.h
index ad9913e3fe..116c85dfde 100644
--- chrome/browser/task_manager/task_manager_observer.h
+++ chrome/browser/task_manager/task_manager_observer.h
@@ -43,11 +43,11 @@ enum RefreshType {
   // or backgrounded.
   REFRESH_TYPE_PRIORITY = 1 << 13,
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // For observers interested in getting the number of open file descriptors of
   // processes.
   REFRESH_TYPE_FD_COUNT = 1 << 14,
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
 
   REFRESH_TYPE_MEMORY_STATE = 1 << 15,
   REFRESH_TYPE_KEEPALIVE_COUNT = 1 << 16,
diff --git chrome/browser/tracing/crash_service_uploader.cc chrome/browser/tracing/crash_service_uploader.cc
index 6a93657bca..7b138d05b2 100644
--- chrome/browser/tracing/crash_service_uploader.cc
+++ chrome/browser/tracing/crash_service_uploader.cc
@@ -158,6 +158,10 @@ void TraceCrashServiceUploader::DoCompressOnBackgroundThread(
   const char product[] = "Chrome_Linux";
 #elif defined(OS_ANDROID)
   const char product[] = "Chrome_Android";
+#elif defined(OS_FREEBSD)
+  const char product[] = "Chrome_FreeBSD";
+#elif defined(OS_DRAGONFLY)
+  const char product[] = "Chrome_DragonFly";
 #else
 #error Platform not supported.
 #endif
diff --git chrome/browser/ui/browser_command_controller.cc chrome/browser/ui/browser_command_controller.cc
index a44b8b7daa..c567a25229 100644
--- chrome/browser/ui/browser_command_controller.cc
+++ chrome/browser/ui/browser_command_controller.cc
@@ -77,7 +77,7 @@
 #include "chrome/browser/ui/browser_commands_chromeos.h"
 #endif
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
 #include "ui/base/ime/linux/text_edit_key_bindings_delegate_auralinux.h"
 #endif
 
@@ -210,7 +210,7 @@ bool BrowserCommandController::IsReservedCommandOrKey(
 #endif
   }
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   // If this key was registered by the user as a content editing hotkey, then
   // it is not reserved.
   ui::TextEditKeyBindingsDelegateAuraLinux* delegate =
@@ -415,7 +415,7 @@ bool BrowserCommandController::ExecuteCommandWithDisposition(
       break;
 #endif
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
     case IDC_MINIMIZE_WINDOW:
       browser_->window()->Minimize();
       break;
@@ -835,7 +835,7 @@ void BrowserCommandController::InitCommandState() {
   command_updater_.UpdateCommandEnabled(IDC_VISIT_DESKTOP_OF_LRU_USER_2, true);
   command_updater_.UpdateCommandEnabled(IDC_VISIT_DESKTOP_OF_LRU_USER_3, true);
 #endif
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   command_updater_.UpdateCommandEnabled(IDC_MINIMIZE_WINDOW, true);
   command_updater_.UpdateCommandEnabled(IDC_MAXIMIZE_WINDOW, true);
   command_updater_.UpdateCommandEnabled(IDC_RESTORE_WINDOW, true);
diff --git chrome/browser/ui/exclusive_access/exclusive_access_bubble.cc chrome/browser/ui/exclusive_access/exclusive_access_bubble.cc
index 9e89857e60..94587de4fa 100644
--- chrome/browser/ui/exclusive_access/exclusive_access_bubble.cc
+++ chrome/browser/ui/exclusive_access/exclusive_access_bubble.cc
@@ -16,7 +16,7 @@
 
 // NOTE(koz): Linux doesn't use the thick shadowed border, so we add padding
 // here.
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 const int ExclusiveAccessBubble::kPaddingPx = 8;
 #else
 const int ExclusiveAccessBubble::kPaddingPx = 15;
diff --git chrome/browser/ui/input_method/input_method_engine.h chrome/browser/ui/input_method/input_method_engine.h
index 2b3de7c510..c464777799 100644
--- chrome/browser/ui/input_method/input_method_engine.h
+++ chrome/browser/ui/input_method/input_method_engine.h
@@ -27,7 +27,7 @@ class InputMethodEngine : public InputMethodEngineBase,
 
   // ui::IMEEngineHandlerInterface:
   bool IsActive() const override;
-  std::string GetExtensionId() const override;
+  std::string GetExtensionId() const;
 
   // Creates and shows the IME window.
   // Returns 0 for errors and |error| will contains the error message.
diff --git chrome/browser/ui/input_method/input_method_engine_base.cc chrome/browser/ui/input_method/input_method_engine_base.cc
index 91de5a44e1..9df10a6e9e 100644
--- chrome/browser/ui/input_method/input_method_engine_base.cc
+++ chrome/browser/ui/input_method/input_method_engine_base.cc
@@ -31,7 +31,7 @@
 #include "ui/base/ime/chromeos/ime_keymap.h"
 #elif defined(OS_WIN)
 #include "ui/events/keycodes/keyboard_codes_win.h"
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
 #include "ui/events/keycodes/keyboard_codes_posix.h"
 #endif
 
diff --git chrome/browser/ui/libgtkui/nav_button_provider_gtk3.h chrome/browser/ui/libgtkui/nav_button_provider_gtk3.h
index a0fc0cd69a..9bef9ab43b 100644
--- chrome/browser/ui/libgtkui/nav_button_provider_gtk3.h
+++ chrome/browser/ui/libgtkui/nav_button_provider_gtk3.h
@@ -38,7 +38,7 @@ class LIBGTKUI_EXPORT NavButtonProviderGtk3 : public views::NavButtonProvider {
 
  private:
   std::map<chrome::FrameButtonDisplayType,
-           gfx::ImageSkia[views::Button::STATE_COUNT]>
+           std::array<gfx::ImageSkia, views::Button::STATE_COUNT>>
       button_images_;
   std::map<chrome::FrameButtonDisplayType, gfx::Insets> button_margins_;
   gfx::Insets top_area_spacing_;
diff --git chrome/browser/ui/libgtkui/print_dialog_gtk.cc chrome/browser/ui/libgtkui/print_dialog_gtk.cc
index ab15c730b9..aa56522589 100644
--- chrome/browser/ui/libgtkui/print_dialog_gtk.cc
+++ chrome/browser/ui/libgtkui/print_dialog_gtk.cc
@@ -350,6 +350,7 @@ void PrintDialogGtk2::ShowDialog(
   // Since we only generate PDF, only show printers that support PDF.
   // TODO(thestig) Add more capabilities to support?
   GtkPrintCapabilities cap = static_cast<GtkPrintCapabilities>(
+      GTK_PRINT_CAPABILITY_GENERATE_PS |
       GTK_PRINT_CAPABILITY_GENERATE_PDF |
       GTK_PRINT_CAPABILITY_PAGE_SET |
       GTK_PRINT_CAPABILITY_COPIES |
diff --git chrome/browser/ui/sad_tab.cc chrome/browser/ui/sad_tab.cc
index 660d7858f5..2f5a91ac1b 100644
--- chrome/browser/ui/sad_tab.cc
+++ chrome/browser/ui/sad_tab.cc
@@ -180,7 +180,7 @@ std::vector<int> SadTab::GetSubMessages() {
       // Only show incognito suggestion if not already in Incognito mode.
       if (!web_contents_->GetBrowserContext()->IsOffTheRecord())
         message_ids.insert(message_ids.begin(), IDS_SAD_TAB_RELOAD_INCOGNITO);
-#if defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
       // Note: on macOS, Linux and ChromeOS, the first bullet is either one of
       // IDS_SAD_TAB_RELOAD_CLOSE_TABS or IDS_SAD_TAB_RELOAD_CLOSE_NOTABS
       // followed by one of the above suggestions.
diff --git chrome/browser/ui/startup/bad_flags_prompt.cc chrome/browser/ui/startup/bad_flags_prompt.cc
index 51d651b0fc..21f63dbfc1 100644
--- chrome/browser/ui/startup/bad_flags_prompt.cc
+++ chrome/browser/ui/startup/bad_flags_prompt.cc
@@ -82,7 +82,7 @@ static const char* kBadFlags[] = {
     extensions::switches::kExtensionsOnChromeURLs,
 #endif
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
     // Speech dispatcher is buggy, it can crash and it can make Chrome freeze.
     // http://crbug.com/327295
     switches::kEnableSpeechDispatcher,
diff --git chrome/browser/ui/startup/startup_browser_creator.cc chrome/browser/ui/startup/startup_browser_creator.cc
index a52bf25cf6..22084dd057 100644
--- chrome/browser/ui/startup/startup_browser_creator.cc
+++ chrome/browser/ui/startup/startup_browser_creator.cc
@@ -81,7 +81,7 @@
 #include "chrome/browser/ui/user_manager.h"
 #endif
 
-#if defined(TOOLKIT_VIEWS) && defined(OS_LINUX)
+#if defined(TOOLKIT_VIEWS) && (defined(OS_LINUX) || defined(OS_BSD))
 #include "ui/events/devices/x11/touch_factory_x11.h"  // nogncheck
 #endif
 
@@ -639,9 +639,11 @@ bool StartupBrowserCreator::ProcessCmdLineImpl(
   }
 #endif  // OS_CHROMEOS
 
+#if 0 /* XXX */
 #if defined(TOOLKIT_VIEWS) && defined(USE_X11)
   ui::TouchFactory::SetTouchDeviceListFromCommandLine();
 #endif
+#endif
 
 #if defined(OS_MACOSX)
   if (web_app::MaybeRebuildShortcut(command_line))
diff --git chrome/browser/ui/tab_helpers.cc chrome/browser/ui/tab_helpers.cc
index b8bb2042e2..0c196ad2d1 100644
--- chrome/browser/ui/tab_helpers.cc
+++ chrome/browser/ui/tab_helpers.cc
@@ -301,7 +301,7 @@ void TabHelpers::AttachTabHelpers(WebContents* web_contents) {
 #endif
 
 #if defined(OS_WIN) || defined(OS_MACOSX) || \
-    (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+    (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_BSD)
   metrics::DesktopSessionDurationObserver::CreateForWebContents(web_contents);
 #endif
 
diff --git chrome/browser/ui/task_manager/task_manager_columns.cc chrome/browser/ui/task_manager/task_manager_columns.cc
index 1b46063f79..a14622c2a4 100644
--- chrome/browser/ui/task_manager/task_manager_columns.cc
+++ chrome/browser/ui/task_manager/task_manager_columns.cc
@@ -93,10 +93,10 @@ const TableColumnData kColumns[] = {
      arraysize("100000") * kCharWidth, -1, true, false, false},
 #endif
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     {IDS_TASK_MANAGER_OPEN_FD_COUNT_COLUMN, ui::TableColumn::RIGHT, -1, 0,
      arraysize("999") * kCharWidth, -1, true, false, false},
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
     {IDS_TASK_MANAGER_PROCESS_PRIORITY_COLUMN, ui::TableColumn::LEFT, -1, 0,
      arraysize("background") * kCharWidth, -1, true, true, false},
     {IDS_TASK_MANAGER_MEMORY_STATE_COLUMN, ui::TableColumn::LEFT, -1, 0,
diff --git chrome/browser/ui/task_manager/task_manager_table_model.cc chrome/browser/ui/task_manager/task_manager_table_model.cc
index 379ab55e5b..86191388a8 100644
--- chrome/browser/ui/task_manager/task_manager_table_model.cc
+++ chrome/browser/ui/task_manager/task_manager_table_model.cc
@@ -457,13 +457,13 @@ base::string16 TaskManagerTableModel::GetText(int row, int column) {
           ? stringifier_->backgrounded_string()
           : stringifier_->foregrounded_string();
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     case IDS_TASK_MANAGER_OPEN_FD_COUNT_COLUMN: {
       const int fd_count = observed_task_manager()->GetOpenFdCount(tasks_[row]);
       return fd_count >= 0 ? base::FormatNumber(fd_count)
                            : stringifier_->n_a_string();
     }
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
 
     case IDS_TASK_MANAGER_MEMORY_STATE_COLUMN: {
       return stringifier_->GetMemoryStateText(
@@ -623,7 +623,7 @@ int TaskManagerTableModel::CompareValues(int row1,
       return BooleanCompare(is_proc1_bg, is_proc2_bg);
     }
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     case IDS_TASK_MANAGER_OPEN_FD_COUNT_COLUMN: {
       const int proc1_fd_count =
           observed_task_manager()->GetOpenFdCount(tasks_[row1]);
@@ -631,7 +631,7 @@ int TaskManagerTableModel::CompareValues(int row1,
           observed_task_manager()->GetOpenFdCount(tasks_[row2]);
       return ValueCompare(proc1_fd_count, proc2_fd_count);
     }
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
 
     default:
       NOTREACHED();
@@ -797,11 +797,11 @@ void TaskManagerTableModel::UpdateRefreshTypes(int column_id, bool visibility) {
       type = REFRESH_TYPE_KEEPALIVE_COUNT;
       break;
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     case IDS_TASK_MANAGER_OPEN_FD_COUNT_COLUMN:
       type = REFRESH_TYPE_FD_COUNT;
       break;
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
 
     default:
       NOTREACHED();
diff --git chrome/browser/ui/toolbar/app_menu_model.cc chrome/browser/ui/toolbar/app_menu_model.cc
index 5c8a704ea9..0a00e69d69 100644
--- chrome/browser/ui/toolbar/app_menu_model.cc
+++ chrome/browser/ui/toolbar/app_menu_model.cc
@@ -668,7 +668,7 @@ bool AppMenuModel::IsCommandIdVisible(int command_id) const {
     case IDC_UPGRADE_DIALOG:
       return browser_defaults::kShowUpgradeMenuItem &&
           UpgradeDetector::GetInstance()->notify_upgrade();
-#if !defined(OS_LINUX) || defined(USE_AURA)
+#if (!defined(OS_LINUX) && !defined(OS_BSD)) || defined(USE_AURA)
     case IDC_BOOKMARK_PAGE:
       return !chrome::ShouldRemoveBookmarkThisPageUI(browser_->profile());
     case IDC_BOOKMARK_ALL_TABS:
diff --git chrome/browser/ui/views/accelerator_table.cc chrome/browser/ui/views/accelerator_table.cc
index d1fcbbc44f..c1d7ce788e 100644
--- chrome/browser/ui/views/accelerator_table.cc
+++ chrome/browser/ui/views/accelerator_table.cc
@@ -44,7 +44,7 @@ const AcceleratorMapping kAcceleratorMap[] = {
     {ui::VKEY_S, ui::EF_PLATFORM_ACCELERATOR, IDC_SAVE_PAGE},
     {ui::VKEY_9, ui::EF_PLATFORM_ACCELERATOR, IDC_SELECT_LAST_TAB},
     {ui::VKEY_NUMPAD9, ui::EF_PLATFORM_ACCELERATOR, IDC_SELECT_LAST_TAB},
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
     {ui::VKEY_9, ui::EF_ALT_DOWN, IDC_SELECT_LAST_TAB},
     {ui::VKEY_NUMPAD9, ui::EF_ALT_DOWN, IDC_SELECT_LAST_TAB},
     {ui::VKEY_NEXT, ui::EF_CONTROL_DOWN | ui::EF_SHIFT_DOWN, IDC_MOVE_TAB_NEXT},
@@ -74,7 +74,7 @@ const AcceleratorMapping kAcceleratorMap[] = {
     {ui::VKEY_NUMPAD7, ui::EF_PLATFORM_ACCELERATOR, IDC_SELECT_TAB_6},
     {ui::VKEY_8, ui::EF_PLATFORM_ACCELERATOR, IDC_SELECT_TAB_7},
     {ui::VKEY_NUMPAD8, ui::EF_PLATFORM_ACCELERATOR, IDC_SELECT_TAB_7},
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
     {ui::VKEY_1, ui::EF_ALT_DOWN, IDC_SELECT_TAB_0},
     {ui::VKEY_NUMPAD1, ui::EF_ALT_DOWN, IDC_SELECT_TAB_0},
     {ui::VKEY_2, ui::EF_ALT_DOWN, IDC_SELECT_TAB_1},
@@ -119,7 +119,7 @@ const AcceleratorMapping kAcceleratorMap[] = {
 #endif  // !OS_MACOSX
 
   // Platform-specific key maps.
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     {ui::VKEY_BROWSER_BACK, ui::EF_NONE, IDC_BACK},
     {ui::VKEY_BROWSER_FORWARD, ui::EF_NONE, IDC_FORWARD},
     {ui::VKEY_BROWSER_HOME, ui::EF_NONE, IDC_HOME},
diff --git chrome/browser/ui/views/apps/chrome_native_app_window_views_aura.cc chrome/browser/ui/views/apps/chrome_native_app_window_views_aura.cc
index 8d85090485..4f7efb48bf 100644
--- chrome/browser/ui/views/apps/chrome_native_app_window_views_aura.cc
+++ chrome/browser/ui/views/apps/chrome_native_app_window_views_aura.cc
@@ -19,7 +19,7 @@
 #include "ui/gfx/image/image_skia.h"
 #include "ui/views/widget/widget.h"
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include "chrome/browser/shell_integration_linux.h"
 #endif
 
diff --git chrome/browser/ui/views/chrome_browser_main_extra_parts_views.cc chrome/browser/ui/views/chrome_browser_main_extra_parts_views.cc
index d7d63e8ae2..4c97451e08 100644
--- chrome/browser/ui/views/chrome_browser_main_extra_parts_views.cc
+++ chrome/browser/ui/views/chrome_browser_main_extra_parts_views.cc
@@ -37,7 +37,7 @@
 #include "ui/wm/core/wm_state.h"
 #endif  // defined(USE_AURA)
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <unistd.h>
@@ -47,7 +47,7 @@
 #include "chrome/grit/generated_resources.h"
 #include "content/public/common/content_switches.h"
 #include "ui/base/l10n/l10n_util.h"
-#endif  // defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#endif  // (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
 
 #if defined(OS_CHROMEOS)
 #include "ash/public/interfaces/constants.mojom.h"
@@ -113,7 +113,7 @@ void ChromeBrowserMainExtraPartsViews::PreProfileInit() {
   }
 #endif
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
   // On the Linux desktop, we want to prevent the user from logging in as root,
   // so that we don't destroy the profile. Now that we have some minimal ui
   // initialized, check to see if we're running as root and bail if we are.
@@ -144,7 +144,7 @@ void ChromeBrowserMainExtraPartsViews::PreProfileInit() {
   base::RunLoop().RunUntilIdle();
 
   exit(EXIT_FAILURE);
-#endif  // defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#endif  // (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
 }
 
 void ChromeBrowserMainExtraPartsViews::ServiceManagerConnectionStarted(
diff --git chrome/browser/ui/views/chrome_views_delegate.h chrome/browser/ui/views/chrome_views_delegate.h
index 7e6d5fcca1..bee65640d4 100644
--- chrome/browser/ui/views/chrome_views_delegate.h
+++ chrome/browser/ui/views/chrome_views_delegate.h
@@ -43,7 +43,7 @@ class ChromeViewsDelegate : public views::ViewsDelegate {
   HICON GetSmallWindowIcon() const override;
   int GetAppbarAutohideEdges(HMONITOR monitor,
                              const base::Closure& callback) override;
-#elif defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#elif (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
   gfx::ImageSkia* GetDefaultWindowIcon() const override;
   bool WindowManagerProvidesTitleBar(bool maximized) override;
 #endif
diff --git chrome/browser/ui/views/first_run_dialog.cc chrome/browser/ui/views/first_run_dialog.cc
index 97232460f4..693981dc66 100644
--- chrome/browser/ui/views/first_run_dialog.cc
+++ chrome/browser/ui/views/first_run_dialog.cc
@@ -39,8 +39,10 @@ using views::GridLayout;
 namespace {
 
 void InitCrashReporterIfEnabled(bool enabled) {
+#if !defined(OS_BSD)
   if (enabled)
     breakpad::InitCrashReporter(std::string());
+#endif
 }
 
 }  // namespace
@@ -111,8 +113,10 @@ views::View* FirstRunDialog::CreateExtraView() {
 bool FirstRunDialog::Accept() {
   GetWidget()->Hide();
 
+#if !defined(OS_BSD)
   ChangeMetricsReportingStateWithReply(report_crashes_->checked(),
                                        base::Bind(&InitCrashReporterIfEnabled));
+#endif
 
   if (make_default_->checked())
     shell_integration::SetAsDefaultBrowser();
diff --git chrome/browser/ui/views/frame/browser_frame.cc chrome/browser/ui/views/frame/browser_frame.cc
index b02fb9cdec..f0fc33a855 100644
--- chrome/browser/ui/views/frame/browser_frame.cc
+++ chrome/browser/ui/views/frame/browser_frame.cc
@@ -36,7 +36,7 @@
 #include "components/user_manager/user_manager.h"
 #endif
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include "chrome/browser/ui/views/frame/browser_command_handler_linux.h"
 #endif
 
@@ -90,7 +90,7 @@ void BrowserFrame::InitBrowserFrame() {
     non_client_view()->set_context_menu_controller(this);
   }
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   browser_command_handler_.reset(new BrowserCommandHandlerLinux(browser_view_));
 #endif
 }
diff --git chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc
index ee5b465250..7c76c320a1 100644
--- chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc
+++ chrome/browser/ui/views/frame/browser_non_client_frame_view_factory_views.cc
@@ -18,7 +18,7 @@
 #include "chrome/browser/ui/views/frame/glass_browser_frame_view.h"
 #endif
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
 #include "ui/views/linux_ui/linux_ui.h"
 #endif
 
diff --git chrome/browser/ui/views/frame/opaque_browser_frame_view.cc chrome/browser/ui/views/frame/opaque_browser_frame_view.cc
index 2d198ac7ba..6bcbd4dcbc 100644
--- chrome/browser/ui/views/frame/opaque_browser_frame_view.cc
+++ chrome/browser/ui/views/frame/opaque_browser_frame_view.cc
@@ -39,7 +39,7 @@
 #include "ui/views/window/frame_background.h"
 #include "ui/views/window/window_shape.h"
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include "ui/views/controls/menu/menu_runner.h"
 #endif
 
@@ -318,7 +318,7 @@ void OpaqueBrowserFrameView::ButtonPressed(views::Button* sender,
 void OpaqueBrowserFrameView::OnMenuButtonClicked(views::MenuButton* source,
                                                  const gfx::Point& point,
                                                  const ui::Event* event) {
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   views::MenuRunner menu_runner(frame()->GetSystemMenuModel(),
                                 views::MenuRunner::HAS_MNEMONICS);
   menu_runner.RunMenuAt(browser_view()->GetWidget(), window_icon_,
diff --git chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc
index 1e0dc83b83..d400d72583 100644
--- chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc
+++ chrome/browser/ui/views/frame/opaque_browser_frame_view_layout.cc
@@ -21,7 +21,7 @@ namespace {
 
 constexpr int kCaptionButtonHeight = 18;
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
 // Default spacing around window caption buttons.
 constexpr int kCaptionButtonSpacing = 2;
 #else
diff --git chrome/browser/ui/views/frame/opaque_browser_frame_view_platform_specific.cc chrome/browser/ui/views/frame/opaque_browser_frame_view_platform_specific.cc
index c3e5f2683a..9c51a01c70 100644
--- chrome/browser/ui/views/frame/opaque_browser_frame_view_platform_specific.cc
+++ chrome/browser/ui/views/frame/opaque_browser_frame_view_platform_specific.cc
@@ -10,7 +10,7 @@ bool OpaqueBrowserFrameViewPlatformSpecific::IsUsingSystemTheme() {
   return false;
 }
 
-#if !defined(OS_LINUX)
+#if !defined(OS_LINUX) && !defined(OS_FREEBSD)
 
 // static
 OpaqueBrowserFrameViewPlatformSpecific*
diff --git chrome/browser/ui/views/frame/system_menu_model_builder.cc chrome/browser/ui/views/frame/system_menu_model_builder.cc
index c365d2947a..391cfc7ad0 100644
--- chrome/browser/ui/views/frame/system_menu_model_builder.cc
+++ chrome/browser/ui/views/frame/system_menu_model_builder.cc
@@ -89,7 +89,7 @@ void SystemMenuModelBuilder::BuildSystemMenuForBrowserWindow(
     model->AddSeparator(ui::NORMAL_SEPARATOR);
     model->AddItemWithStringId(IDC_TASK_MANAGER, IDS_TASK_MANAGER);
   }
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   model->AddSeparator(ui::NORMAL_SEPARATOR);
   model->AddCheckItemWithStringId(IDC_USE_SYSTEM_TITLE_BAR,
                                   IDS_SHOW_WINDOW_DECORATIONS_MENU);
@@ -125,7 +125,7 @@ void SystemMenuModelBuilder::BuildSystemMenuForAppOrPopupWindow(
     model->AddSeparator(ui::NORMAL_SEPARATOR);
     model->AddItemWithStringId(IDC_TASK_MANAGER, IDS_TASK_MANAGER);
   }
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   model->AddSeparator(ui::NORMAL_SEPARATOR);
   model->AddItemWithStringId(IDC_CLOSE_WINDOW, IDS_CLOSE);
 #endif
diff --git chrome/browser/ui/views/frame/system_menu_model_delegate.cc chrome/browser/ui/views/frame/system_menu_model_delegate.cc
index 0045dd6ae4..037fb3683d 100644
--- chrome/browser/ui/views/frame/system_menu_model_delegate.cc
+++ chrome/browser/ui/views/frame/system_menu_model_delegate.cc
@@ -15,7 +15,7 @@
 #include "components/sessions/core/tab_restore_service.h"
 #include "ui/base/l10n/l10n_util.h"
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
 #include "chrome/common/pref_names.h"
 #include "components/prefs/pref_service.h"
 #endif
@@ -30,7 +30,7 @@ SystemMenuModelDelegate::SystemMenuModelDelegate(
 SystemMenuModelDelegate::~SystemMenuModelDelegate() {}
 
 bool SystemMenuModelDelegate::IsCommandIdChecked(int command_id) const {
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   if (command_id == IDC_USE_SYSTEM_TITLE_BAR) {
     PrefService* prefs = browser_->profile()->GetPrefs();
     return !prefs->GetBoolean(prefs::kUseCustomChromeFrame);
diff --git chrome/browser/ui/views/profiles/avatar_button.cc chrome/browser/ui/views/profiles/avatar_button.cc
index e1a0431cc7..949b4b478d 100644
--- chrome/browser/ui/views/profiles/avatar_button.cc
+++ chrome/browser/ui/views/profiles/avatar_button.cc
@@ -250,7 +250,7 @@ AvatarButton::AvatarButton(views::MenuButtonListener* listener,
   } else if (apply_ink_drop) {
     SetInkDropMode(InkDropMode::ON);
     SetFocusPainter(nullptr);
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     set_ink_drop_base_color(SK_ColorWHITE);
     SetBorder(std::make_unique<AvatarButtonThemedBorder>());
     generic_avatar_ =
@@ -544,7 +544,7 @@ bool AvatarButton::IsCondensible() const {
 #endif
 }
 bool AvatarButton::ShouldApplyInkDrop() const {
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   DCHECK_EQ(AvatarButtonStyle::THEMED, button_style_);
   return true;
 #elif defined(OS_MACOSX)
diff --git chrome/browser/ui/views/tabs/new_tab_button.cc chrome/browser/ui/views/tabs/new_tab_button.cc
index 855badb4a2..2407f817ca 100644
--- chrome/browser/ui/views/tabs/new_tab_button.cc
+++ chrome/browser/ui/views/tabs/new_tab_button.cc
@@ -88,7 +88,7 @@ NewTabButton::NewTabButton(TabStrip* tab_strip, views::ButtonListener* listener)
       tab_strip_(tab_strip),
       is_incognito_(tab_strip->IsIncognito()) {
   set_animate_on_state_change(true);
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   set_triggerable_event_flags(triggerable_event_flags() |
                               ui::EF_MIDDLE_MOUSE_BUTTON);
 #endif
diff --git chrome/browser/ui/views/tabs/tab_drag_controller.cc chrome/browser/ui/views/tabs/tab_drag_controller.cc
index d33983f54a..b975f9af58 100644
--- chrome/browser/ui/views/tabs/tab_drag_controller.cc
+++ chrome/browser/ui/views/tabs/tab_drag_controller.cc
@@ -290,7 +290,7 @@ void TabDragController::Init(TabStrip* source_tabstrip,
   //     synchronous on desktop Linux, so use that.
   // - Chrome OS
   //     Releasing capture on Ash cancels gestures so avoid it.
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   can_release_capture_ = false;
 #endif
   start_point_in_screen_ = gfx::Point(source_tab_offset, mouse_offset.y());
@@ -637,7 +637,7 @@ TabDragController::DragBrowserToNewTabStrip(TabStrip* target_tabstrip,
     else
       target_tabstrip->GetWidget()->SetCapture(attached_tabstrip_);
 
-#if !defined(OS_LINUX)
+#if !defined(OS_LINUX) || defined(OS_BSD)
     // EndMoveLoop is going to snap the window back to its original location.
     // Hide it so users don't see this. Hiding a window in Linux aura causes
     // it to lose capture so skip it.
@@ -1877,7 +1877,7 @@ TabDragController::Liveness TabDragController::GetLocalProcessWindow(
     if (dragged_window)
       exclude.insert(dragged_window);
   }
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_BSD)
   // Exclude windows which are pending deletion via Browser::TabStripEmpty().
   // These windows can be returned in the Linux Aura port because the browser
   // window which was used for dragging is not hidden once all of its tabs are
diff --git chrome/browser/ui/webui/about_ui.cc chrome/browser/ui/webui/about_ui.cc
index a54cb8f97e..4923cbfff6 100644
--- chrome/browser/ui/webui/about_ui.cc
+++ chrome/browser/ui/webui/about_ui.cc
@@ -386,7 +386,7 @@ class AboutDnsHandler : public base::RefCountedThreadSafe<AboutDnsHandler> {
   DISALLOW_COPY_AND_ASSIGN(AboutDnsHandler);
 };
 
-#if defined(OS_LINUX) || defined(OS_OPENBSD)
+#if defined(OS_LINUX) || defined(OS_BSD)
 std::string AboutLinuxProxyConfig() {
   std::string data;
   AppendHeader(&data, 0,
@@ -444,7 +444,7 @@ void AboutUIHTMLSource::StartDataRequest(
   } else if (source_name_ == chrome::kChromeUIDNSHost) {
     AboutDnsHandler::Start(profile(), callback);
     return;
-#if defined(OS_LINUX) || defined(OS_OPENBSD)
+#if defined(OS_LINUX) || defined(OS_BSD)
   } else if (source_name_ == chrome::kChromeUILinuxProxyConfigHost) {
     response = AboutLinuxProxyConfig();
 #endif
diff --git chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
index 4ad61d2d8c..d0412aad49 100644
--- chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
+++ chrome/browser/ui/webui/chrome_web_ui_controller_factory.cc
@@ -178,11 +178,11 @@
 #include "chrome/browser/ui/webui/welcome_win10_ui.h"
 #endif
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
 #include "chrome/browser/ui/webui/discards/discards_ui.h"
 #endif
 
-#if defined(OS_LINUX) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_BSD)
 #include "chrome/browser/ui/webui/sandbox_internals_ui.h"
 #endif
 
@@ -299,7 +299,7 @@ bool IsAboutUI(const GURL& url) {
 #if !defined(OS_ANDROID)
           || url.host_piece() == chrome::kChromeUITermsHost
 #endif
-#if defined(OS_LINUX) || defined(OS_OPENBSD)
+#if defined(OS_LINUX) || defined(OS_BSD)
           || url.host_piece() == chrome::kChromeUILinuxProxyConfigHost
 #endif
 #if defined(OS_CHROMEOS)
@@ -541,7 +541,7 @@ WebUIFactoryFunction GetWebUIFactoryFunction(WebUI* web_ui,
   if (url.host_piece() == chrome::kChromeUINaClHost)
     return &NewWebUI<NaClUI>;
 #endif
-#if (defined(OS_LINUX) && defined(TOOLKIT_VIEWS)) || defined(USE_AURA)
+#if (defined(OS_LINUX) && defined(TOOLKIT_VIEWS)) || defined(USE_AURA) || defined(OS_BSD)
   if (url.host_piece() == chrome::kChromeUITabModalConfirmDialogHost)
     return &NewWebUI<ConstrainedWebDialogUI>;
 #endif
@@ -600,12 +600,12 @@ WebUIFactoryFunction GetWebUIFactoryFunction(WebUI* web_ui,
     return &NewWebUI<CastUI>;
   }
 #endif
-#if defined(OS_LINUX) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_BSD)
   if (url.host_piece() == chrome::kChromeUISandboxHost) {
     return &NewWebUI<SandboxInternalsUI>;
   }
 #endif
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
   if (url.host_piece() == chrome::kChromeUIDiscardsHost)
     return &NewWebUI<DiscardsUI>;
 #endif
diff --git chrome/browser/ui/webui/settings/appearance_handler.cc chrome/browser/ui/webui/settings/appearance_handler.cc
index ae92d56904..2e6d804adc 100644
--- chrome/browser/ui/webui/settings/appearance_handler.cc
+++ chrome/browser/ui/webui/settings/appearance_handler.cc
@@ -31,7 +31,7 @@ void AppearanceHandler::RegisterMessages() {
       "useDefaultTheme",
       base::BindRepeating(&AppearanceHandler::HandleUseDefaultTheme,
                           base::Unretained(this)));
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_BSD) && !defined(OS_CHROMEOS)
   web_ui()->RegisterMessageCallback(
       "useSystemTheme",
       base::BindRepeating(&AppearanceHandler::HandleUseSystemTheme,
@@ -59,7 +59,7 @@ void AppearanceHandler::HandleUseDefaultTheme(const base::ListValue* args) {
   ThemeServiceFactory::GetForProfile(profile_)->UseDefaultTheme();
 }
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(OS_LINUX) || defined(OS_BSD) && !defined(OS_CHROMEOS)
 void AppearanceHandler::HandleUseSystemTheme(const base::ListValue* args) {
   if (profile_->IsSupervised())
     NOTREACHED();
diff --git chrome/browser/ui/webui/settings/appearance_handler.h chrome/browser/ui/webui/settings/appearance_handler.h
index 3acb6d567f..62a206983f 100644
--- chrome/browser/ui/webui/settings/appearance_handler.h
+++ chrome/browser/ui/webui/settings/appearance_handler.h
@@ -36,7 +36,7 @@ class AppearanceHandler : public SettingsPageUIHandler {
   // Changes the UI theme of the browser to the default theme.
   void HandleUseDefaultTheme(const base::ListValue* args);
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
   // Changes the UI theme of the browser to the system (GTK+) theme.
   void HandleUseSystemTheme(const base::ListValue* args);
 #endif
diff --git chrome/browser/ui/webui/settings/md_settings_localized_strings_provider.cc chrome/browser/ui/webui/settings/md_settings_localized_strings_provider.cc
index 77f1c6afba..2f3504b1bc 100644
--- chrome/browser/ui/webui/settings/md_settings_localized_strings_provider.cc
+++ chrome/browser/ui/webui/settings/md_settings_localized_strings_provider.cc
@@ -432,7 +432,7 @@ void AddAppearanceStrings(content::WebUIDataSource* html_source,
     {"enterCustomWebAddress", IDS_SETTINGS_ENTER_CUSTOM_WEB_ADDRESS},
     {"homeButtonDisabled", IDS_SETTINGS_HOME_BUTTON_DISABLED},
     {"themes", IDS_SETTINGS_THEMES},
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
     {"systemTheme", IDS_SETTINGS_SYSTEM_THEME},
     {"useSystemTheme", IDS_SETTINGS_USE_SYSTEM_THEME},
     {"classicTheme", IDS_SETTINGS_CLASSIC_THEME},
@@ -450,7 +450,7 @@ void AddAppearanceStrings(content::WebUIDataSource* html_source,
     {"openWallpaperApp", IDS_SETTINGS_OPEN_WALLPAPER_APP},
     {"setWallpaper", IDS_SETTINGS_SET_WALLPAPER},
 #endif
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
     {"showWindowDecorations", IDS_SHOW_WINDOW_DECORATIONS},
 #endif
 #if defined(OS_MACOSX)
diff --git chrome/browser/web_applications/web_app.cc chrome/browser/web_applications/web_app.cc
index 9a680cc59b..e1931498d9 100644
--- chrome/browser/web_applications/web_app.cc
+++ chrome/browser/web_applications/web_app.cc
@@ -55,7 +55,7 @@ namespace {
 #if defined(OS_MACOSX)
 const int kDesiredSizes[] = {16, 32, 128, 256, 512};
 const size_t kNumDesiredSizes = arraysize(kDesiredSizes);
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
 // Linux supports icons of any size. FreeDesktop Icon Theme Specification states
 // that "Minimally you should install a 48x48 icon in the hicolor theme."
 const int kDesiredSizes[] = {16, 32, 48, 128, 256, 512};
@@ -468,7 +468,7 @@ bool IsValidUrl(const GURL& url) {
   return false;
 }
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 std::string GetWMClassFromAppName(std::string app_name) {
   base::i18n::ReplaceIllegalCharactersInPath(&app_name, '_');
   base::TrimString(app_name, "_", &app_name);
diff --git chrome/browser/web_applications/web_app.h chrome/browser/web_applications/web_app.h
index 7ca1f3b419..a847326f2c 100644
--- chrome/browser/web_applications/web_app.h
+++ chrome/browser/web_applications/web_app.h
@@ -204,7 +204,7 @@ void UpdateShortcutsForAllApps(Profile* profile,
 // Returns true if given url is a valid web app url.
 bool IsValidUrl(const GURL& url);
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
 // Windows that correspond to web apps need to have a deterministic (and
 // different) WMClass than normal chrome windows so the window manager groups
 // them as a separate application.
diff --git chrome/common/BUILD.gn chrome/common/BUILD.gn
index b45794f858..86c841dc31 100644
--- chrome/common/BUILD.gn
+++ chrome/common/BUILD.gn
@@ -292,6 +292,10 @@ static_library("common") {
     public_deps += [ "//ppapi/shared_impl" ]
   }
 
+  if (is_bsd) {
+    sources -= [ "component_flash_hint_file_linux.cc" ]
+  }
+
   if (enable_extensions) {
     sources += [
       "cast_messages.cc",
diff --git chrome/common/chrome_features.cc chrome/common/chrome_features.cc
index 903896e29b..e6a0195c38 100644
--- chrome/common/chrome_features.cc
+++ chrome/common/chrome_features.cc
@@ -85,7 +85,7 @@ const base::Feature kAutomaticTabDiscarding{"AutomaticTabDiscarding",
                                             base::FEATURE_ENABLED_BY_DEFAULT};
 #endif  // defined(OS_WIN) || defined(OS_MACOSX)
 
-#if defined(OS_WIN) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_BSD)
 // Enables the Restart background mode optimization. When all Chrome UI is
 // closed and it goes in the background, allows to restart the browser to
 // discard memory.
@@ -142,7 +142,7 @@ const base::Feature kTabMetricsLogging{"TabMetricsLogging",
                                        base::FEATURE_ENABLED_BY_DEFAULT};
 #endif
 
-#if (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_MACOSX)
+#if (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_MACOSX) || defined(OS_BSD)
 // Enables the dual certificate verification trial feature.
 // https://crbug.com/649026
 const base::Feature kCertDualVerificationTrialFeature{
@@ -367,7 +367,7 @@ const base::Feature kAcknowledgeNtpOverrideOnDeactivate{
     "AcknowledgeNtpOverrideOnDeactivate", base::FEATURE_DISABLED_BY_DEFAULT};
 #endif
 
-#if defined(OS_WIN) || (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+#if defined(OS_WIN) || ((defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS))
 const base::Feature kWarnBeforeQuitting{"WarnBeforeQuitting",
                                         base::FEATURE_DISABLED_BY_DEFAULT};
 #endif
diff --git chrome/common/chrome_features.h chrome/common/chrome_features.h
index bb41fa8647..851cbdd3bc 100644
--- chrome/common/chrome_features.h
+++ chrome/common/chrome_features.h
@@ -52,7 +52,7 @@ extern const base::Feature kAsyncDns;
 extern const base::Feature kAutomaticTabDiscarding;
 #endif  // defined(OS_WIN) || defined(OS_MACOSX)
 
-#if defined(OS_WIN) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_BSD)
 extern const base::Feature kBackgroundModeAllowRestart;
 #endif  // defined(OS_WIN) || defined(OS_LINUX)
 
@@ -76,7 +76,7 @@ extern const base::Feature kDialogTouchBar;
 extern const base::Feature kTabStripKeyboardFocus;
 #endif  // defined(OS_MACOSX)
 
-#if (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_MACOSX)
+#if (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_MACOSX) || defined(OS_BSD)
 extern const base::Feature kCertDualVerificationTrialFeature;
 #endif
 
@@ -204,7 +204,7 @@ extern const base::Feature kMaterialDesignExtensions;
 extern const base::Feature kAcknowledgeNtpOverrideOnDeactivate;
 #endif
 
-#if defined(OS_WIN) || (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+#if defined(OS_WIN) || ((defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS))
 extern const base::Feature kWarnBeforeQuitting;
 #endif
 
diff --git chrome/common/chrome_paths.cc chrome/common/chrome_paths.cc
index 49b56bdb03..84bec52aea 100644
--- chrome/common/chrome_paths.cc
+++ chrome/common/chrome_paths.cc
@@ -52,14 +52,14 @@ const base::FilePath::CharType kPepperFlashSystemBaseDirectory[] =
 const base::FilePath::CharType kInternalNaClPluginFileName[] =
     FILE_PATH_LITERAL("internal-nacl-plugin");
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 // The path to the external extension <id>.json files.
 // /usr/share seems like a good choice, see: http://www.pathname.com/fhs/
 const base::FilePath::CharType kFilepathSinglePrefExtensions[] =
 #if defined(GOOGLE_CHROME_BUILD)
     FILE_PATH_LITERAL("/usr/share/google-chrome/extensions");
 #else
-    FILE_PATH_LITERAL("/usr/share/chromium/extensions");
+    FILE_PATH_LITERAL("/usr/local/share/chromium/extensions");
 #endif  // defined(GOOGLE_CHROME_BUILD)
 
 // The path to the hint file that tells the pepper plugin loader
@@ -193,7 +193,7 @@ bool PathProvider(int key, base::FilePath* result) {
         return false;
       break;
     case chrome::DIR_DEFAULT_DOWNLOADS_SAFE:
-#if defined(OS_WIN) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_BSD)
       if (!GetUserDownloadsDirectorySafe(&cur))
         return false;
       break;
@@ -422,7 +422,7 @@ bool PathProvider(int key, base::FilePath* result) {
       break;
 #endif
 #if BUILDFLAG(ENABLE_SUPERVISED_USERS)
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     case chrome::DIR_SUPERVISED_USERS_DEFAULT_APPS:
       if (!base::PathService::Get(chrome::DIR_STANDALONE_EXTERNAL_EXTENSIONS,
                                   &cur)) {
@@ -472,10 +472,12 @@ bool PathProvider(int key, base::FilePath* result) {
       if (!base::PathExists(cur))  // We don't want to create this
         return false;
       break;
-#if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_OPENBSD)
+#if defined(OS_POSIX) && !defined(OS_MACOSX)
     case chrome::DIR_POLICY_FILES: {
 #if defined(GOOGLE_CHROME_BUILD)
       cur = base::FilePath(FILE_PATH_LITERAL("/etc/opt/chrome/policies"));
+#elif defined(OS_BSD)
+      cur = base::FilePath(FILE_PATH_LITERAL("/usr/local/etc/chrome/policies"));
 #else
       cur = base::FilePath(FILE_PATH_LITERAL("/etc/chromium/policies"));
 #endif
@@ -483,7 +485,7 @@ bool PathProvider(int key, base::FilePath* result) {
     }
 #endif
 #if defined(OS_CHROMEOS) || (defined(OS_LINUX) && defined(CHROMIUM_BUILD)) || \
-    defined(OS_MACOSX)
+    defined(OS_MACOSX) || defined(OS_BSD)
     case chrome::DIR_USER_EXTERNAL_EXTENSIONS: {
       if (!base::PathService::Get(chrome::DIR_USER_DATA, &cur))
         return false;
@@ -491,7 +493,7 @@ bool PathProvider(int key, base::FilePath* result) {
       break;
     }
 #endif
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     case chrome::DIR_STANDALONE_EXTERNAL_EXTENSIONS: {
       cur = base::FilePath(kFilepathSinglePrefExtensions);
       break;
@@ -526,7 +528,7 @@ bool PathProvider(int key, base::FilePath* result) {
 #endif
       break;
 
-#if defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
     case chrome::DIR_NATIVE_MESSAGING:
 #if defined(OS_MACOSX)
 #if defined(GOOGLE_CHROME_BUILD)
@@ -540,6 +542,9 @@ bool PathProvider(int key, base::FilePath* result) {
 #if defined(GOOGLE_CHROME_BUILD)
       cur = base::FilePath(FILE_PATH_LITERAL(
           "/etc/opt/chrome/native-messaging-hosts"));
+#elif defined(OS_BSD)
+      cur = base::FilePath(FILE_PATH_LITERAL(
+          "/usr/local/etc/chrome/native-messaging-hosts"));
 #else
       cur = base::FilePath(FILE_PATH_LITERAL(
           "/etc/chromium/native-messaging-hosts"));
@@ -552,7 +557,7 @@ bool PathProvider(int key, base::FilePath* result) {
         return false;
       cur = cur.Append(FILE_PATH_LITERAL("NativeMessagingHosts"));
       break;
-#endif  // defined(OS_LINUX) || defined(OS_MACOSX)
+#endif  // defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
 #if !defined(OS_ANDROID)
     case chrome::DIR_GLOBAL_GCM_STORE:
       if (!base::PathService::Get(chrome::DIR_USER_DATA, &cur))
diff --git chrome/common/chrome_paths.h chrome/common/chrome_paths.h
index c9c3a3fdd9..8da2b3df61 100644
--- chrome/common/chrome_paths.h
+++ chrome/common/chrome_paths.h
@@ -51,7 +51,7 @@ enum {
                                 // to set policies for chrome. This directory
                                 // contains subdirectories.
 #endif
-#if defined(OS_CHROMEOS) || (defined(OS_LINUX) && defined(CHROMIUM_BUILD)) || \
+#if defined(OS_CHROMEOS) || ((defined(OS_LINUX) || defined(OS_BSD)) && defined(CHROMIUM_BUILD)) || \
     defined(OS_MACOSX)
   DIR_USER_EXTERNAL_EXTENSIONS,  // Directory for per-user external extensions
                                  // on Chrome Mac and Chromium Linux.
@@ -60,7 +60,7 @@ enum {
                                  // create it.
 #endif
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   DIR_STANDALONE_EXTERNAL_EXTENSIONS,  // Directory for 'per-extension'
                                        // definition manifest files that
                                        // describe extensions which are to be
@@ -111,7 +111,7 @@ enum {
   DIR_SUPERVISED_USER_INSTALLED_WHITELISTS,  // Directory where sanitized
                                              // supervised user whitelists are
                                              // installed.
-#if defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_LINUX) || defined(OS_BSD) || defined(OS_MACOSX)
   DIR_NATIVE_MESSAGING,         // System directory where native messaging host
                                 // manifest files are stored.
   DIR_USER_NATIVE_MESSAGING,    // Directory with Native Messaging Hosts
diff --git chrome/common/chrome_paths_internal.h chrome/common/chrome_paths_internal.h
index ab81293542..ed84666c08 100644
--- chrome/common/chrome_paths_internal.h
+++ chrome/common/chrome_paths_internal.h
@@ -45,7 +45,7 @@ void GetUserCacheDirectory(const base::FilePath& profile_dir, base::FilePath* re
 // Get the path to the user's documents directory.
 bool GetUserDocumentsDirectory(base::FilePath* result);
 
-#if defined(OS_WIN) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_BSD)
 // Gets the path to a safe default download directory for a user.
 bool GetUserDownloadsDirectorySafe(base::FilePath* result);
 #endif
diff --git chrome/common/chrome_switches.cc chrome/common/chrome_switches.cc
index eba6dd66ae..da80cb95ca 100644
--- chrome/common/chrome_switches.cc
+++ chrome/common/chrome_switches.cc
@@ -978,12 +978,12 @@ const char kAllowNaClFileHandleAPI[]        = "allow-nacl-file-handle-api";
 const char kAllowNaClSocketAPI[]            = "allow-nacl-socket-api";
 #endif
 
-#if defined(OS_WIN) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_BSD)
 const char kDisableInputImeAPI[] = "disable-input-ime-api";
 const char kEnableInputImeAPI[] = "enable-input-ime-api";
 #endif
 
-#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN) || defined(OS_BSD)
 const char kEnableNewAppMenuIcon[] = "enable-new-app-menu-icon";
 #endif
 
diff --git chrome/common/chrome_switches.h chrome/common/chrome_switches.h
index 1eaeab0d36..7765653d4c 100644
--- chrome/common/chrome_switches.h
+++ chrome/common/chrome_switches.h
@@ -296,12 +296,12 @@ extern const char kAllowNaClFileHandleAPI[];
 extern const char kAllowNaClSocketAPI[];
 #endif
 
-#if defined(OS_WIN) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_BSD)
 extern const char kDisableInputImeAPI[];
 extern const char kEnableInputImeAPI[];
 #endif
 
-#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN) || defined(OS_BSD)
 extern const char kEnableNewAppMenuIcon[];
 #endif
 
diff --git chrome/common/extensions/api/BUILD.gn chrome/common/extensions/api/BUILD.gn
index 8cdf32f000..e3c024585c 100644
--- chrome/common/extensions/api/BUILD.gn
+++ chrome/common/extensions/api/BUILD.gn
@@ -118,7 +118,7 @@ if (is_chromeos) {
     "wallpaper.json",
     "wallpaper_private.json",
   ]
-} else if (is_linux || is_win) {
+} else if (is_linux || is_bsd || is_win) {
   schema_sources += [ "input_ime.json" ]
 }
 
diff --git chrome/common/extensions/chrome_extensions_client.cc chrome/common/extensions/chrome_extensions_client.cc
index 284a5324b0..524453d419 100644
--- chrome/common/extensions/chrome_extensions_client.cc
+++ chrome/common/extensions/chrome_extensions_client.cc
@@ -96,7 +96,10 @@ ChromeChannelForHistogram GetChromeChannelForHistogram(
 static base::LazyInstance<ChromeExtensionsClient>::Leaky g_client =
     LAZY_INSTANCE_INITIALIZER;
 
-ChromeExtensionsClient::ChromeExtensionsClient() {}
+ChromeExtensionsClient::ChromeExtensionsClient()
+    : chrome_api_permissions_(ChromeAPIPermissions()),
+      extensions_api_permissions_(ExtensionsAPIPermissions()) {
+}
 
 ChromeExtensionsClient::~ChromeExtensionsClient() {
 }
diff --git chrome/common/extensions/command.cc chrome/common/extensions/command.cc
index 1bc2d4ab99..edc68fbfdb 100644
--- chrome/common/extensions/command.cc
+++ chrome/common/extensions/command.cc
@@ -311,7 +311,7 @@ std::string Command::CommandPlatform() {
   return values::kKeybindingPlatformMac;
 #elif defined(OS_CHROMEOS)
   return values::kKeybindingPlatformChromeOs;
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   return values::kKeybindingPlatformLinux;
 #else
   return "";
diff --git chrome/common/features.gni chrome/common/features.gni
index 75b663cccc..f7233ce0bb 100644
--- chrome/common/features.gni
+++ chrome/common/features.gni
@@ -45,9 +45,9 @@ declare_args() {
                                 (is_desktop_linux && use_dbus) || is_chromeos
 
   enable_one_click_signin =
-      is_win || is_mac || (is_linux && !is_chromeos && !is_chromecast)
+      is_win || is_mac || is_bsd || (is_linux && !is_chromeos && !is_chromecast)
 
-  enable_service_discovery = enable_mdns || is_mac
+  enable_service_discovery = enable_mdns || is_mac || is_bsd
 
   # Enables use of the session service, which is enabled by default.
   # Android stores them separately on the Java side.
diff --git chrome/common/pref_names.cc chrome/common/pref_names.cc
index acb5c9d57c..cced856389 100644
--- chrome/common/pref_names.cc
+++ chrome/common/pref_names.cc
@@ -907,7 +907,7 @@ const char kForceSessionSync[] = "settings.history_recorded";
 // only using an account that belongs to one of the domains from this pref.
 const char kAllowedDomainsForApps[] = "settings.allowed_domains_for_apps";
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
 // Linux specific preference on whether we should match the system theme.
 const char kUsesSystemTheme[] = "extensions.theme.use_system";
 #endif
@@ -990,7 +990,7 @@ const char kShowUpdatePromotionInfoBar[] =
     "browser.show_update_promotion_info_bar";
 #endif
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
 // Boolean that is false if we should show window manager decorations.  If
 // true, we draw a custom chrome frame (thicker title bar and blue border).
 const char kUseCustomChromeFrame[] = "browser.custom_chrome_frame";
@@ -1345,7 +1345,7 @@ const char kDownloadDefaultDirectory[] = "download.default_directory";
 // upgrade a unsafe location to a safe location.
 const char kDownloadDirUpgraded[] = "download.directory_upgrade";
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
 const char kOpenPdfDownloadInSystemReader[] =
     "download.open_pdf_in_system_reader";
 #endif
diff --git chrome/common/pref_names.h chrome/common/pref_names.h
index 9550992285..e232c51f8d 100644
--- chrome/common/pref_names.h
+++ chrome/common/pref_names.h
@@ -294,7 +294,7 @@ extern const char kForceGoogleSafeSearch[];
 extern const char kForceYouTubeRestrict[];
 extern const char kForceSessionSync[];
 extern const char kAllowedDomainsForApps[];
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
 extern const char kUsesSystemTheme[];
 #endif
 extern const char kCurrentThemePackFilename[];
@@ -327,7 +327,7 @@ extern const char kDefaultBrowserSettingEnabled[];
 #if defined(OS_MACOSX)
 extern const char kShowUpdatePromotionInfoBar[];
 #endif
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
 extern const char kUseCustomChromeFrame[];
 #endif
 #if BUILDFLAG(ENABLE_PLUGINS)
@@ -471,7 +471,7 @@ extern const char kAppWindowPlacement[];
 extern const char kDownloadDefaultDirectory[];
 extern const char kDownloadExtensionsToOpen[];
 extern const char kDownloadDirUpgraded[];
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_BSD)
 extern const char kOpenPdfDownloadInSystemReader[];
 #endif
 #if defined(OS_ANDROID)
diff --git chrome/common/webui_url_constants.cc chrome/common/webui_url_constants.cc
index b09126020d..d72bd1c389 100644
--- chrome/common/webui_url_constants.cc
+++ chrome/common/webui_url_constants.cc
@@ -235,7 +235,7 @@ const char kChromeUICastHost[] = "cast";
 const char kChromeUICastURL[] = "chrome://cast/";
 #endif
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
 const char kChromeUIDiscardsHost[] = "discards";
 const char kChromeUIDiscardsURL[] = "chrome://discards/";
 #endif
@@ -244,11 +244,11 @@ const char kChromeUIDiscardsURL[] = "chrome://discards/";
 const char kChromeUILinuxProxyConfigHost[] = "linux-proxy-config";
 #endif
 
-#if defined(OS_LINUX) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_BSD)
 const char kChromeUISandboxHost[] = "sandbox";
 #endif
 
-#if (defined(OS_LINUX) && defined(TOOLKIT_VIEWS)) || defined(USE_AURA)
+#if ((defined(OS_BSD) || defined(OS_LINUX)) && defined(TOOLKIT_VIEWS)) || defined(USE_AURA)
 const char kChromeUITabModalConfirmDialogHost[] = "tab-modal-confirm-dialog";
 #endif
 
@@ -394,13 +394,13 @@ const char* const kChromeHostURLs[] = {
     kChromeUIInternetDetailDialogHost,
     kChromeUIAssistantOptInHost,
 #endif
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
     kChromeUIDiscardsHost,
 #endif
 #if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_ANDROID)
     kChromeUILinuxProxyConfigHost,
 #endif
-#if defined(OS_LINUX) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_BSD)
     kChromeUISandboxHost,
 #endif
 #if defined(OS_WIN)
diff --git chrome/common/webui_url_constants.h chrome/common/webui_url_constants.h
index 94e6d66a3d..434ccdc7d8 100644
--- chrome/common/webui_url_constants.h
+++ chrome/common/webui_url_constants.h
@@ -230,7 +230,7 @@ extern const char kChromeUICastHost[];
 extern const char kChromeUICastURL[];
 #endif
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
 extern const char kChromeUIDiscardsHost[];
 extern const char kChromeUIDiscardsURL[];
 #endif
@@ -239,11 +239,11 @@ extern const char kChromeUIDiscardsURL[];
 extern const char kChromeUILinuxProxyConfigHost[];
 #endif
 
-#if defined(OS_LINUX) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_BSD)
 extern const char kChromeUISandboxHost[];
 #endif
 
-#if (defined(OS_LINUX) && defined(TOOLKIT_VIEWS)) || defined(USE_AURA)
+#if ((defined(OS_BSD) || defined(OS_LINUX)) && defined(TOOLKIT_VIEWS)) || defined(USE_AURA)
 extern const char kChromeUITabModalConfirmDialogHost[];
 #endif
 
diff --git chrome/renderer/pepper/pepper_flash_font_file_host.cc chrome/renderer/pepper/pepper_flash_font_file_host.cc
index 07e5aeef17..59a45c9272 100644
--- chrome/renderer/pepper/pepper_flash_font_file_host.cc
+++ chrome/renderer/pepper/pepper_flash_font_file_host.cc
@@ -14,7 +14,7 @@
 #include "ppapi/proxy/ppapi_messages.h"
 #include "ppapi/proxy/serialized_structs.h"
 
-#if defined(OS_LINUX) || defined(OS_OPENBSD)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include "content/public/child/child_process_sandbox_support_linux.h"
 #include "content/public/common/common_sandbox_support_linux.h"
 #elif defined(OS_WIN)
@@ -28,7 +28,7 @@ PepperFlashFontFileHost::PepperFlashFontFileHost(
     const ppapi::proxy::SerializedFontDescription& description,
     PP_PrivateFontCharset charset)
     : ResourceHost(host->GetPpapiHost(), instance, resource) {
-#if defined(OS_LINUX) || defined(OS_OPENBSD)
+#if defined(OS_LINUX) || defined(OS_BSD)
   fd_.reset(content::MatchFontWithFallback(
       description.face,
       description.weight >= PP_BROWSERFONT_TRUSTED_WEIGHT_BOLD,
@@ -45,7 +45,7 @@ PepperFlashFontFileHost::PepperFlashFontFileHost(
   sk_sp<SkFontMgr> font_mgr(SkFontMgr::RefDefault());
   typeface_ = sk_sp<SkTypeface>(
       font_mgr->matchFamilyStyle(description.face.c_str(), style));
-#endif  // defined(OS_LINUX) || defined(OS_OPENBSD)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
 }
 
 PepperFlashFontFileHost::~PepperFlashFontFileHost() {}
@@ -64,7 +64,7 @@ bool PepperFlashFontFileHost::GetFontData(uint32_t table,
                                           void* buffer,
                                           size_t* length) {
   bool result = false;
-#if defined(OS_LINUX) || defined(OS_OPENBSD)
+#if defined(OS_LINUX) || defined(OS_BSD)
   int fd = fd_.get();
   if (fd != -1)
     result = content::GetFontTable(fd, table, 0 /* offset */,
diff --git chrome/renderer/pepper/pepper_flash_font_file_host.h chrome/renderer/pepper/pepper_flash_font_file_host.h
index 3e9ba7d41d..4b0c896a9f 100644
--- chrome/renderer/pepper/pepper_flash_font_file_host.h
+++ chrome/renderer/pepper/pepper_flash_font_file_host.h
@@ -14,7 +14,7 @@
 #include "ppapi/c/private/pp_private_font_charset.h"
 #include "ppapi/host/resource_host.h"
 
-#if defined(OS_LINUX) || defined(OS_OPENBSD)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include "base/files/scoped_file.h"
 #elif defined(OS_WIN)
 #include "third_party/skia/include/core/SkRefCnt.h"
@@ -50,7 +50,7 @@ class PepperFlashFontFileHost : public ppapi::host::ResourceHost {
                          uint32_t table);
   bool GetFontData(uint32_t table, void* buffer, size_t* length);
 
-#if defined(OS_LINUX) || defined(OS_OPENBSD)
+#if defined(OS_LINUX) || defined(OS_BSD)
   base::ScopedFD fd_;
 #elif defined(OS_WIN)
   sk_sp<SkTypeface> typeface_;
diff --git chrome/service/cloud_print/print_system.cc chrome/service/cloud_print/print_system.cc
index 4ceba96919..b3de289044 100644
--- chrome/service/cloud_print/print_system.cc
+++ chrome/service/cloud_print/print_system.cc
@@ -36,7 +36,7 @@ std::string PrintSystem::GenerateProxyId() {
   return base::GenerateGUID();
 }
 
-#if defined(OS_LINUX) && !defined(USE_CUPS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(USE_CUPS)
 scoped_refptr<PrintSystem> PrintSystem::CreateInstance(
     const base::DictionaryValue*) {
   return nullptr;
diff --git chrome/test/base/in_process_browser_test.cc chrome/test/base/in_process_browser_test.cc
index 97de24c9fe..d39d7cca07 100644
--- chrome/test/base/in_process_browser_test.cc
+++ chrome/test/base/in_process_browser_test.cc
@@ -69,6 +69,10 @@
 #include "chrome/test/base/scoped_bundle_swizzler_mac.h"
 #endif
 
+#if defined(OS_FREEBSD)
+#include <signal.h>
+#endif
+
 #if defined(OS_WIN)
 #include "base/win/scoped_com_initializer.h"
 #include "base/win/windows_version.h"
@@ -88,7 +92,7 @@
 #include "chrome/test/base/default_ash_event_generator_delegate.h"
 #endif  // defined(OS_CHROMEOS)
 
-#if !defined(OS_CHROMEOS) && defined(OS_LINUX)
+#if !defined(OS_CHROMEOS) && (defined(OS_LINUX) || defined(OS_BSD))
 #include "ui/views/test/test_desktop_screen_x11.h"
 #endif
 
diff --git chrome/test/base/testing_browser_process.h chrome/test/base/testing_browser_process.h
index 92bdeb2ad6..1fbe526f75 100644
--- chrome/test/base/testing_browser_process.h
+++ chrome/test/base/testing_browser_process.h
@@ -111,8 +111,8 @@ class TestingBrowserProcess : public BrowserProcess {
   DownloadStatusUpdater* download_status_updater() override;
   DownloadRequestLimiter* download_request_limiter() override;
 
-#if (defined(OS_WIN) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
-  void StartAutoupdateTimer() override {}
+#if (defined(OS_WIN) || defined(OS_LINUX) || defined(OS_FREEBSD)) && !defined(OS_CHROMEOS)
+  void StartAutoupdateTimer() /*override*/ {}
 #endif
 
   net_log::ChromeNetLog* net_log() override;
diff --git chrome/test/chromedriver/chrome/chrome_finder.cc chrome/test/chromedriver/chrome/chrome_finder.cc
index 9115579315..0a39339c23 100644
--- chrome/test/chromedriver/chrome/chrome_finder.cc
+++ chrome/test/chromedriver/chrome/chrome_finder.cc
@@ -45,7 +45,7 @@ void GetApplicationDirs(std::vector<base::FilePath>* locations) {
         installation_locations[i].Append(L"Chromium\\Application"));
   }
 }
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
 void GetApplicationDirs(std::vector<base::FilePath>* locations) {
   // TODO: Respect users' PATH variables.
   // Until then, we use an approximation of the most common defaults.
@@ -98,7 +98,7 @@ bool FindChrome(base::FilePath* browser_exe) {
 #elif defined(OS_MACOSX)
       base::FilePath("Google Chrome.app/Contents/MacOS/Google Chrome"),
       base::FilePath("Chromium.app/Contents/MacOS/Chromium")
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
       base::FilePath("google-chrome"),
       base::FilePath("chrome"),
       base::FilePath("chromium"),
diff --git chromecast/browser/cast_content_browser_client.cc chromecast/browser/cast_content_browser_client.cc
index 37d06928ad..0f90208b2b 100644
--- chromecast/browser/cast_content_browser_client.cc
+++ chromecast/browser/cast_content_browser_client.cc
@@ -432,7 +432,7 @@ void CastContentBrowserClient::AppendExtraCommandLineSwitches(
                                           switches::kAudioOutputChannels));
     }
   } else if (process_type == switches::kGpuProcess) {
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // Necessary for accelerated 2d canvas.  By default on Linux, Chromium assumes
   // GLES2 contexts can be lost to a power-save mode, which breaks GPU canvas
   // apps.
diff --git components/autofill/content/renderer/password_form_conversion_utils.cc components/autofill/content/renderer/password_form_conversion_utils.cc
index 1cd2c4e812..6f9d53189b 100644
--- components/autofill/content/renderer/password_form_conversion_utils.cc
+++ components/autofill/content/renderer/password_form_conversion_utils.cc
@@ -38,7 +38,11 @@
 #include "third_party/blink/public/web/web_form_control_element.h"
 #include "third_party/blink/public/web/web_input_element.h"
 #include "third_party/blink/public/web/web_local_frame.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 #include "url/gurl.h"
 
 using blink::WebFormControlElement;
diff --git components/autofill/core/browser/autofill_experiments.cc components/autofill/core/browser/autofill_experiments.cc
index 04b3b3afa5..db311e2030 100644
--- components/autofill/core/browser/autofill_experiments.cc
+++ components/autofill/core/browser/autofill_experiments.cc
@@ -199,7 +199,7 @@ unsigned int GetPopupMargin() {
 }
 
 bool OfferStoreUnmaskedCards() {
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
   // The checkbox can be forced on with a flag, but by default we don't store
   // on Linux due to lack of system keychain integration. See crbug.com/162735
   return base::CommandLine::ForCurrentProcess()->HasSwitch(
diff --git components/autofill_strings.grdp components/autofill_strings.grdp
index 2de9b8c9cc..113d8e79c4 100644
--- components/autofill_strings.grdp
+++ components/autofill_strings.grdp
@@ -195,7 +195,7 @@
   <message name="IDS_AUTOFILL_SAVE_CARD_PROMPT_CONFIRM" desc="Text to show for the Autofill upload save credit card prompt accept button when more information (e.g., CVC) was needed in order to save the card and was entered.">
     Confirm
   </message>
-  <if expr="is_linux and not chromeos">
+  <if expr="is_posix and not chromeos">
     <then>
       <message name="IDS_AUTOFILL_SAVE_CARD_PROMPT_TITLE_TO_CLOUD" desc="Title text for the Autofill save card prompt when the card is to be saved by uploading it to Google Payments and also saved locally. The prompt can be either a bubble or an infobar.">
         Do you want to save this card to your Google Account?
@@ -213,7 +213,7 @@
   <message name="IDS_AUTOFILL_SAVE_CARD_PROMPT_UPLOAD_EXPLANATION" desc="Explanation of the effect of the Autofill save card prompt when the card is to be saved by uploading it to Google Payments and also saved locally. The prompt can be either a bubble or an infobar.">
     Pay quickly on sites and apps across devices using cards you have saved with Google.
   </message>
-  <if expr="is_linux and not chromeos">
+  <if expr="is_posix and not chromeos">
     <then>
       <message name="IDS_AUTOFILL_SAVE_CARD_PROMPT_UPLOAD_EXPLANATION_V2" desc="Explanation of the effect of the Autofill save card prompt when the card is to be saved by uploading it to Google Payments, according to June 2017 UI guidelines. The prompt will be shown in a bubble below the omnibox.">
         To pay faster next time, save this card to your Google Account.
@@ -225,7 +225,7 @@
       </message>
     </else>
   </if>
-  <if expr="is_linux and not chromeos">
+  <if expr="is_posix and not chromeos">
     <then>
       <message name="IDS_AUTOFILL_SAVE_CARD_PROMPT_UPLOAD_EXPLANATION_V3" desc="Explanation of the effect of the Autofill save card prompt when the card is to be saved by uploading it to Google Payments, according to April 2018 UI guidelines. The prompt will be shown in a bubble below the omnibox.">
         To pay faster next time, save your card and billing address to your Google Account.
diff --git components/content_settings/core/browser/website_settings_registry.cc components/content_settings/core/browser/website_settings_registry.cc
index 5c74c36aa3..42a3c355ca 100644
--- components/content_settings/core/browser/website_settings_registry.cc
+++ components/content_settings/core/browser/website_settings_registry.cc
@@ -66,7 +66,7 @@ const WebsiteSettingsInfo* WebsiteSettingsRegistry::Register(
 #if defined(OS_WIN)
   if (!(platform & PLATFORM_WINDOWS))
     return nullptr;
-#elif defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#elif (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   if (!(platform & PLATFORM_LINUX))
     return nullptr;
 #elif defined(OS_MACOSX) && !defined(OS_IOS)
diff --git components/cookie_config/cookie_store_util.cc components/cookie_config/cookie_store_util.cc
index c1aa494335..549011ce3d 100644
--- components/cookie_config/cookie_store_util.cc
+++ components/cookie_config/cookie_store_util.cc
@@ -11,7 +11,7 @@
 
 namespace cookie_config {
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
 namespace {
 
 // Use the operating system's mechanisms to encrypt cookies before writing
@@ -63,10 +63,10 @@ base::LazyInstance<CookieOSCryptoDelegate>::DestructorAtExit
 net::CookieCryptoDelegate* GetCookieCryptoDelegate() {
   return g_cookie_crypto_delegate.Pointer();
 }
-#else   // defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#else   // defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
 net::CookieCryptoDelegate* GetCookieCryptoDelegate() {
   return NULL;
 }
-#endif  // defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#endif  // defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
 
 }  // namespace cookie_config
diff --git components/crash/content/app/BUILD.gn components/crash/content/app/BUILD.gn
index 4d9d30aa89..9610b0eeef 100644
--- components/crash/content/app/BUILD.gn
+++ components/crash/content/app/BUILD.gn
@@ -36,7 +36,7 @@ static_library("app") {
     sources += [ "crashpad.cc" ]
   }
 
-  if (is_android || is_linux) {
+  if (is_android || is_linux && !is_bsd) {
     # Want these files on both Linux and Android.
     set_sources_assignment_filter([])
     sources += [
@@ -73,7 +73,6 @@ static_library("app") {
       "//content/public/common:content_descriptors",
       "//content/public/common:result_codes",
       "//sandbox",
-      "//third_party/breakpad:client",
     ]
 
     # Clang's -mstackrealign doesn't work well with
diff --git components/crash/content/app/crashpad.cc components/crash/content/app/crashpad.cc
index c6a98292bb..97f931004b 100644
--- components/crash/content/app/crashpad.cc
+++ components/crash/content/app/crashpad.cc
@@ -101,6 +101,12 @@ void InitializeCrashpadImpl(bool initial_client,
                             const std::string& user_data_dir,
                             const base::FilePath& exe_path,
                             bool embedded_handler) {
+
+#if defined(OS_BSD)
+  NOTIMPLEMENTED();
+  return;
+#endif
+
   static bool initialized = false;
   DCHECK(!initialized);
   initialized = true;
@@ -119,7 +125,7 @@ void InitializeCrashpadImpl(bool initial_client,
     // as processed by the backend.
     DCHECK(browser_process || process_type == "Chrome Installer" ||
            process_type == "notification-helper");
-#elif defined(OS_LINUX) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_BSD)
     DCHECK(browser_process);
 #else
 #error Port.
@@ -184,7 +190,7 @@ void InitializeCrashpadImpl(bool initial_client,
   // other "main, first process" to initialize things. There is no "relauncher"
   // on Windows, so this is synonymous with initial_client.
   const bool should_initialize_database_and_set_upload_policy = initial_client;
-#elif defined(OS_LINUX) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_BSD)
   const bool should_initialize_database_and_set_upload_policy = browser_process;
 #endif
   if (should_initialize_database_and_set_upload_policy) {
@@ -253,7 +259,9 @@ bool GetUploadsEnabled() {
 }
 
 void DumpWithoutCrashing() {
+#if !defined(OS_BSD)
   CRASHPAD_SIMULATE_CRASH();
+#endif
 }
 
 void GetReports(std::vector<Report>* reports) {
diff --git components/crash/content/browser/BUILD.gn components/crash/content/browser/BUILD.gn
index 64761ead91..b70ad90c71 100644
--- components/crash/content/browser/BUILD.gn
+++ components/crash/content/browser/BUILD.gn
@@ -24,10 +24,9 @@ source_set("browser") {
     "//components/crash/content/app",
     "//content/public/browser",
     "//content/public/common",
-    "//third_party/breakpad:client",
   ]
 
-  if (is_linux || is_android) {
+  if ((is_linux && !is_bsd) || is_android) {
     set_sources_assignment_filter([])
 
     # Want this file on both Linux and Android.
@@ -43,7 +42,7 @@ source_set("browser") {
 
   # This is not in the GYP build but this target includes breakpad client
   # headers, so add the dependency here.
-  if ((is_posix && !is_ios) || is_fuchsia) {
+  if ((is_posix && !is_ios && !is_bsd) || is_fuchsia) {
     configs += [ "//third_party/breakpad:client_config" ]
     public_configs = [ "//third_party/breakpad:client_config" ]
   }
diff --git components/crash/core/common/BUILD.gn components/crash/core/common/BUILD.gn
index c8e02ebf85..b99e4dbaf9 100644
--- components/crash/core/common/BUILD.gn
+++ components/crash/core/common/BUILD.gn
@@ -6,7 +6,7 @@ import("//build/buildflag_header.gni")
 
 declare_args() {
   # If set to true, this will stub out and disable the entire crash key system.
-  use_crash_key_stubs = is_fuchsia
+  use_crash_key_stubs = is_fuchsia || is_bsd
 }
 
 group("common") {
@@ -88,7 +88,6 @@ target(crash_key_target_type, "crash_key") {
       ]
     }
 
-    deps += [ "//third_party/breakpad:client" ]
   }
 }
 
@@ -143,7 +142,7 @@ source_set("unit_tests") {
     sources += [ "objc_zombie_unittest.mm" ]
   }
 
-  if (!is_mac && !is_win && !is_fuchsia) {
+  if (!is_mac && !is_win && !is_fuchsia && !is_bsd) {
     include_dirs = [ "//third_party/breakpad/breakpad/src/" ]
     sources += [ "crash_key_breakpad_unittest.cc" ]
   }
diff --git components/download/quarantine/quarantine_linux.cc components/download/quarantine/quarantine_linux.cc
index fe932fe00b..09f1a42e3a 100644
--- components/download/quarantine/quarantine_linux.cc
+++ components/download/quarantine/quarantine_linux.cc
@@ -2,11 +2,15 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "build/build_config.h"
+
 #include "components/download/quarantine/quarantine.h"
 
 #include <stddef.h>
 #include <sys/types.h>
+#if !defined(OS_BSD)
 #include <sys/xattr.h>
+#endif
 
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
@@ -29,17 +33,20 @@ bool SetExtendedFileAttribute(const char* path,
                               size_t value_size,
                               int flags) {
   base::AssertBlockingAllowed();
+#if !defined(OS_BSD)
   int result = setxattr(path, name, value, value_size, flags);
   if (result) {
     DPLOG(ERROR) << "Could not set extended attribute " << name << " on file "
                  << path;
     return false;
   }
+#endif
   return true;
 }
 
 std::string GetExtendedFileAttribute(const char* path, const char* name) {
   base::AssertBlockingAllowed();
+#if !defined(OS_BSD)
   ssize_t len = getxattr(path, name, nullptr, 0);
   if (len <= 0)
     return std::string();
@@ -49,6 +56,9 @@ std::string GetExtendedFileAttribute(const char* path, const char* name) {
   if (len < static_cast<ssize_t>(buffer.size()))
     return std::string();
   return std::string(buffer.begin(), buffer.end());
+#else
+  return std::string();
+#endif
 }
 
 }  // namespace
diff --git components/drive/drive_api_util.cc components/drive/drive_api_util.cc
index b910ca5ba8..dfd9caba9b 100644
--- components/drive/drive_api_util.cc
+++ components/drive/drive_api_util.cc
@@ -23,7 +23,11 @@
 #include "google_apis/drive/drive_api_parser.h"
 #include "net/base/escape.h"
 #include "net/base/net_errors.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 #include "url/gurl.h"
 
 namespace drive {
diff --git components/feature_engagement/public/event_constants.cc components/feature_engagement/public/event_constants.cc
index b0e351a465..e2f3cb6dbc 100644
--- components/feature_engagement/public/event_constants.cc
+++ components/feature_engagement/public/event_constants.cc
@@ -24,9 +24,9 @@ const char kIncognitoWindowSessionTimeMet[] =
 
 #endif  // BUILDFLAG(ENABLE_DESKTOP_IN_PRODUCT_HELP)
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_IOS)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_IOS) || defined(OS_BSD)
 const char kNewTabOpened[] = "new_tab_opened";
-#endif  // defined(OS_WIN) || defined(OS_LINUX) || defined(OS_IOS)
+#endif  // defined(OS_WIN) || defined(OS_LINUX) || defined(OS_IOS) || defined(OS_BSD)
 
 #if defined(OS_IOS)
 const char kChromeOpened[] = "chrome_opened";
diff --git components/feature_engagement/public/event_constants.h components/feature_engagement/public/event_constants.h
index 1b95ad1b7a..8be3936156 100644
--- components/feature_engagement/public/event_constants.h
+++ components/feature_engagement/public/event_constants.h
@@ -42,7 +42,7 @@ extern const char kIncognitoWindowOpened[];
 extern const char kIncognitoWindowSessionTimeMet[];
 #endif  // BUILDFLAG(ENABLE_DESKTOP_IN_PRODUCT_HELP)
 
-#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_IOS)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_IOS) || defined(OS_BSD)
 // This event is included in the deferred onboarding events for the New Tab
 // described above, but it is also used on iOS, so it must be compiled
 // separately.
@@ -50,7 +50,7 @@ extern const char kIncognitoWindowSessionTimeMet[];
 // The user has explicitly opened a new tab via an entry point from inside of
 // Chrome.
 extern const char kNewTabOpened[];
-#endif  // defined(OS_WIN) || defined(OS_LINUX) || defined(OS_IOS)
+#endif  // defined(OS_WIN) || defined(OS_LINUX) || defined(OS_IOS) || defined(OS_BSD)
 
 #if defined(OS_IOS)
 // The user has opened Chrome (cold start or from background).
diff --git components/feedback/anonymizer_tool.cc components/feedback/anonymizer_tool.cc
index f9f1fd6a7d..a1dd4c927d 100644
--- components/feedback/anonymizer_tool.cc
+++ components/feedback/anonymizer_tool.cc
@@ -11,7 +11,11 @@
 #include "base/strings/string_util.h"
 #include "base/strings/stringprintf.h"
 #include "content/public/browser/browser_thread.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 
 using re2::RE2;
 
diff --git components/flags_ui/flags_state.cc components/flags_ui/flags_state.cc
index 7218bfd52c..f9ff8be7e2 100644
--- components/flags_ui/flags_state.cc
+++ components/flags_ui/flags_state.cc
@@ -653,7 +653,8 @@ int FlagsState::GetCurrentPlatform() {
   return kOsWin;
 #elif defined(OS_CHROMEOS)  // Needs to be before the OS_LINUX check.
   return kOsCrOS;
-#elif defined(OS_LINUX) || defined(OS_OPENBSD)
+#elif defined(OS_LINUX) || defined(OS_OPENBSD) || defined(OS_FREEBSD) || \
+  defined(OS_DRAGONFLY)
   return kOsLinux;
 #elif defined(OS_ANDROID)
   return kOsAndroid;
diff --git components/gcm_driver/gcm_client.h components/gcm_driver/gcm_client.h
index 2926056b28..7a6c93f9d7 100644
--- components/gcm_driver/gcm_client.h
+++ components/gcm_driver/gcm_client.h
@@ -82,6 +82,7 @@ class GCMClient {
     PLATFORM_CROS,
     PLATFORM_IOS,
     PLATFORM_ANDROID,
+    PLATFORM_BSD,
     PLATFORM_UNSPECIFIED
   };
 
diff --git components/gcm_driver/gcm_client_impl.cc components/gcm_driver/gcm_client_impl.cc
index 8306733ff8..c221a886a9 100644
--- components/gcm_driver/gcm_client_impl.cc
+++ components/gcm_driver/gcm_client_impl.cc
@@ -152,6 +152,9 @@ void ToCheckinProtoVersion(
     case GCMClient::PLATFORM_CROS:
       platform = checkin_proto::ChromeBuildProto_Platform_PLATFORM_CROS;
       break;
+    case GCMClient::PLATFORM_BSD:
+      platform = checkin_proto::ChromeBuildProto_Platform_PLATFORM_LINUX;
+      break;
     case GCMClient::PLATFORM_UNSPECIFIED:
       // For unknown platform, return as LINUX.
       platform = checkin_proto::ChromeBuildProto_Platform_PLATFORM_LINUX;
diff --git components/json_schema/json_schema_validator.cc components/json_schema/json_schema_validator.cc
index 8806e90075..78f908fcb2 100644
--- components/json_schema/json_schema_validator.cc
+++ components/json_schema/json_schema_validator.cc
@@ -21,7 +21,11 @@
 #include "base/strings/stringprintf.h"
 #include "base/values.h"
 #include "components/json_schema/json_schema_constants.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 
 namespace schema = json_schema_constants;
 
diff --git components/keyed_service/core/dependency_graph_unittest.cc components/keyed_service/core/dependency_graph_unittest.cc
index f8538a6fcd..dd525e9c2e 100644
--- components/keyed_service/core/dependency_graph_unittest.cc
+++ components/keyed_service/core/dependency_graph_unittest.cc
@@ -9,7 +9,11 @@
 #include "components/keyed_service/core/dependency_graph.h"
 #include "components/keyed_service/core/dependency_node.h"
 #include "testing/gtest/include/gtest/gtest.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 
 namespace {
 
diff --git components/metrics/BUILD.gn components/metrics/BUILD.gn
index 75d36a28d4..73c3f84ded 100644
--- components/metrics/BUILD.gn
+++ components/metrics/BUILD.gn
@@ -142,6 +142,11 @@ static_library("metrics") {
   if (is_fuchsia) {
     sources += [ "drive_metrics_provider_fuchsia.cc" ]
   }
+  
+  if (is_bsd) {
+    sources -= [ "system_memory_stats_recorder_linux.cc" ]
+  }
+
 }
 
 # The component metrics provider is a separate target because it depends upon
diff --git components/metrics/drive_metrics_provider_linux.cc components/metrics/drive_metrics_provider_linux.cc
index 149405e5f1..08ee265aa9 100644
--- components/metrics/drive_metrics_provider_linux.cc
+++ components/metrics/drive_metrics_provider_linux.cc
@@ -4,7 +4,13 @@
 
 #include "components/metrics/drive_metrics_provider.h"
 
+#if defined(OS_BSD)
+#include <sys/types.h>
+#define MAJOR(dev) major(dev)
+#define MINOR(dev) minor(dev)
+#else
 #include <linux/kdev_t.h>  // For MAJOR()/MINOR().
+#endif
 #include <sys/stat.h>
 #include <string>
 
diff --git components/metrics/system_memory_stats_recorder_linux.cc components/metrics/system_memory_stats_recorder_linux.cc
index c69dbaa046..222ed79699 100644
--- components/metrics/system_memory_stats_recorder_linux.cc
+++ components/metrics/system_memory_stats_recorder_linux.cc
@@ -30,6 +30,7 @@ namespace metrics {
   UMA_HISTOGRAM_LINEAR(name, sample, 2500, 50)
 
 void RecordMemoryStats(RecordMemoryStatsType type) {
+#if !defined(OS_FREEBSD)
   base::SystemMemoryInfoKB memory;
   if (!base::GetSystemMemoryInfo(&memory))
     return;
@@ -93,6 +94,7 @@ void RecordMemoryStats(RecordMemoryStatsType type) {
       break;
     }
   }
+#endif // !defined(OS_FREEBSD)
 }
 
 }  // namespace metrics
diff --git components/neterror/resources/neterror.js components/neterror/resources/neterror.js
index 2dd11a936e..fe7a147cae 100644
--- components/neterror/resources/neterror.js
+++ components/neterror/resources/neterror.js
@@ -153,7 +153,7 @@ function setUpCachedButton(buttonStrings) {
 }
 
 var primaryControlOnLeft = true;
-// <if expr="is_macosx or is_ios or is_linux or is_android">
+// <if expr="is_macosx or is_ios or is_linux or is_android or is_bsd">
 primaryControlOnLeft = false;
 // </if>
 
diff --git components/network_session_configurator/browser/network_session_configurator.cc components/network_session_configurator/browser/network_session_configurator.cc
index d9f2a3d0d7..d6822fd0f6 100644
--- components/network_session_configurator/browser/network_session_configurator.cc
+++ components/network_session_configurator/browser/network_session_configurator.cc
@@ -584,7 +584,7 @@ net::URLRequestContextBuilder::HttpCacheParams::Type ChooseCacheType(
   }
 #endif  // #if !defined(OS_ANDROID)
 
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_BSD)
   return net::URLRequestContextBuilder::HttpCacheParams::DISK_SIMPLE;
 #else
   return net::URLRequestContextBuilder::HttpCacheParams::DISK_BLOCKFILE;
diff --git components/new_or_sad_tab_strings.grdp components/new_or_sad_tab_strings.grdp
index 4771a59b95..e66a539627 100644
--- components/new_or_sad_tab_strings.grdp
+++ components/new_or_sad_tab_strings.grdp
@@ -51,7 +51,7 @@
           Open page in a new Incognito window (⇧⌘N)
         </message>
       </if>
-      <if expr="is_win or is_linux or chromeos">
+      <if expr="is_win or is_posix or chromeos">
         <message name="IDS_SAD_TAB_RELOAD_INCOGNITO" desc="One of the bullet points displayed on the web page if a reload failed to fix the issue, advising the user to open the web page in Chrome's Incognito mode.">
           Open page in a new Incognito window (Ctrl-Shift-N)
         </message>
@@ -66,7 +66,7 @@
           Close other tabs or apps
         </message>
       </if>
-      <if expr="is_linux and not chromeos">
+      <if expr="is_posix and not chromeos">
         <message name="IDS_SAD_TAB_RELOAD_CLOSE_TABS" desc="One of the bullet points displayed on the web page if a reload failed to fix the issue, advising the user to close other Chrome tabs or programs running on their computer.">
           Close other tabs or programs
         </message>
@@ -76,7 +76,7 @@
           Close other apps
         </message>
       </if>
-      <if expr="is_linux and not chromeos">
+      <if expr="is_posix and not chromeos">
         <message name="IDS_SAD_TAB_RELOAD_CLOSE_NOTABS" desc="One of the bullet points displayed on the web page if a reload failed to fix the issue, advising the user to close other programs running on their computer (Linux).">
           Close other programs
         </message>
@@ -91,7 +91,7 @@
           Restart Chromium
         </message>
       </if>
-      <if expr="is_win or is_linux or is_macosx or chromeos">
+      <if expr="is_win or is_posix or is_macosx or chromeos">
         <message name="IDS_SAD_TAB_RELOAD_RESTART_DEVICE" desc="One of the bullet points displayed on the web page if a reload failed to fix the issue, advising the user to restart their computer.">
           Restart your computer
         </message>
diff --git components/os_crypt/os_crypt.h components/os_crypt/os_crypt.h
index d5898bf86f..4ac6a05d2b 100644
--- components/os_crypt/os_crypt.h
+++ components/os_crypt/os_crypt.h
@@ -14,9 +14,9 @@
 #include "base/strings/string16.h"
 #include "build/build_config.h"
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS) && defined(UNIT_TEST)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS) && defined(UNIT_TEST)
 class KeyStorageLinux;
-#endif  // defined(OS_LINUX) && !defined(OS_CHROMEOS) && defined(UNIT_TEST)
+#endif  // (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS) && defined(UNIT_TEST)
 
 namespace os_crypt {
 struct Config;
@@ -28,13 +28,13 @@ struct Config;
 // true for Linux, if a password management tool is available.
 class OSCrypt {
  public:
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   // Set the configuration of OSCrypt.
   static void SetConfig(std::unique_ptr<os_crypt::Config> config);
 
   // Returns true iff the real secret key (not hardcoded one) is available.
   static bool IsEncryptionAvailable();
-#endif  // defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#endif  // (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
 
   // Encrypt a string16. The output (second argument) is really an array of
   // bytes, but we're passing it back as a std::string.
@@ -67,7 +67,7 @@ class OSCrypt {
   DISALLOW_IMPLICIT_CONSTRUCTORS(OSCrypt);
 };
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS) && defined(UNIT_TEST)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS) && defined(UNIT_TEST)
 // For unit testing purposes, inject methods to be used.
 // |get_key_storage_mock| provides the desired |KeyStorage| implementation.
 // If the provider returns |nullptr|, a hardcoded password will be used.
@@ -81,6 +81,6 @@ void UseMockKeyStorageForTesting(
 // Clears any caching and most lazy initialisations performed by the production
 // code. Should be used after any test which required a password.
 void ClearCacheForTesting();
-#endif  // defined(OS_LINUX) && !defined(OS_CHROMEOS) && defined(UNIT_TEST)
+#endif  // (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS) && defined(UNIT_TEST)
 
 #endif  // COMPONENTS_OS_CRYPT_OS_CRYPT_H_
diff --git components/os_crypt/os_crypt_unittest.cc components/os_crypt/os_crypt_unittest.cc
index f3ef01fe0e..0c8a3f92a0 100644
--- components/os_crypt/os_crypt_unittest.cc
+++ components/os_crypt/os_crypt_unittest.cc
@@ -18,7 +18,7 @@
 #include "components/os_crypt/os_crypt_mocker.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
 #include "components/os_crypt/os_crypt_mocker_linux.h"
 #endif
 
diff --git components/password_manager/core/browser/import/csv_reader.cc components/password_manager/core/browser/import/csv_reader.cc
index 957c314055..bfb0f57d4a 100644
--- components/password_manager/core/browser/import/csv_reader.cc
+++ components/password_manager/core/browser/import/csv_reader.cc
@@ -9,7 +9,11 @@
 #include "base/logging.h"
 #include "base/macros.h"
 #include "base/strings/string_util.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 
 namespace {
 
diff --git components/password_manager/core/browser/password_reuse_defines.h components/password_manager/core/browser/password_reuse_defines.h
index a45e9ff682..7e7106eec9 100644
--- components/password_manager/core/browser/password_reuse_defines.h
+++ components/password_manager/core/browser/password_reuse_defines.h
@@ -6,7 +6,7 @@
 #define COMPONENTS_PASSWORD_MANAGER_CORE_BROWSER_PASSWORD_REUSE_DEFINES_H_
 
 #if defined(OS_WIN) || (defined(OS_MACOSX) && !defined(OS_IOS)) || \
-    defined(OS_LINUX) || defined(OS_CHROMEOS)
+    defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_BSD)
 // Enable the detection when the sync password is typed not on the sync domain.
 #define SYNC_PASSWORD_REUSE_DETECTION_ENABLED
 #endif
diff --git components/plugins/renderer/plugin_placeholder.cc components/plugins/renderer/plugin_placeholder.cc
index 4e48cfc557..c71a7c10af 100644
--- components/plugins/renderer/plugin_placeholder.cc
+++ components/plugins/renderer/plugin_placeholder.cc
@@ -11,7 +11,11 @@
 #include "gin/object_template_builder.h"
 #include "third_party/blink/public/web/web_element.h"
 #include "third_party/blink/public/web/web_plugin_container.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 
 namespace plugins {
 
diff --git components/policy/core/common/schema.cc components/policy/core/common/schema.cc
index 0d41d82787..af1aa5866b 100644
--- components/policy/core/common/schema.cc
+++ components/policy/core/common/schema.cc
@@ -21,7 +21,11 @@
 #include "components/json_schema/json_schema_constants.h"
 #include "components/json_schema/json_schema_validator.h"
 #include "components/policy/core/common/schema_internal.h"
+#if defined(OS_FREEBSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 
 namespace schema = json_schema_constants;
 
diff --git components/policy/resources/policy_templates.json components/policy/resources/policy_templates.json
index 7bf6ba3a92..05c8c12510 100644
--- components/policy/resources/policy_templates.json
+++ components/policy/resources/policy_templates.json
@@ -621,7 +621,7 @@
       'name': 'HomepageLocation',
       'type': 'string',
       'schema': { 'type': 'string' },
-      'supported_on': ['chrome.*:8-', 'chrome_os:11-'],
+      'supported_on': ['chrome.*:8-', 'chrome_os:11-', 'chrome.bsd:9-'],
       'features': {
         'can_be_recommended': True,
         'dynamic_refresh': True,
@@ -649,7 +649,7 @@
       'name': 'HomepageIsNewTabPage',
       'type': 'main',
       'schema': { 'type': 'boolean' },
-      'supported_on': ['chrome.*:8-', 'chrome_os:11-'],
+      'supported_on': ['chrome.*:8-', 'chrome_os:11-', 'chrome.bsd:9-'],
       'features': {
         'can_be_recommended': True,
         'dynamic_refresh': True,
@@ -676,7 +676,7 @@
       'name': 'NewTabPageLocation',
       'type': 'string',
       'schema': { 'type': 'string' },
-      'supported_on': ['chrome.*:58-', 'chrome_os:58-'],
+      'supported_on': ['chrome.*:58-', 'chrome_os:58-', 'chrome.bsd:9-'],
       'features': {
         'can_be_recommended': True,
         'dynamic_refresh': True,
@@ -1367,7 +1367,7 @@
       'name': 'RemoteAccessHostMatchUsername',
       'type': 'main',
       'schema': { 'type': 'boolean' },
-      'supported_on': ['chrome.linux:25-', 'chrome.mac:25-', 'chrome_os:42-'],
+      'supported_on': ['chrome.linux:25-', 'chrome.mac:25-', 'chrome_os:42-', 'chrome.bsd:25-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': False,
@@ -2597,7 +2597,7 @@
       'name': 'GSSAPILibraryName',
       'type': 'string',
       'schema': { 'type': 'string' },
-      'supported_on': ['chrome.linux:9-'],
+      'supported_on': ['chrome.linux:9-', 'chrome.bsd:9-'],
       'features': {
         'dynamic_refresh': False,
         'per_profile': False,
@@ -2649,7 +2649,7 @@
       'name': 'NtlmV2Enabled',
       'type': 'main',
       'schema': { 'type': 'boolean' },
-      'supported_on': ['chrome.linux:63-','chrome.mac:63-','chrome_os:63-','android:63-','webview_android:63-'],
+      'supported_on': ['chrome.linux:63-','chrome.mac:63-','chrome_os:63-','android:63-','webview_android:63-', 'chrome.bsd:63-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': False,
@@ -5497,7 +5497,7 @@
       'name': 'RequireOnlineRevocationChecksForLocalAnchors',
       'type': 'main',
       'schema': { 'type': 'boolean' },
-      'supported_on': ['chrome_os:30-', 'chrome.linux:30-', 'chrome.win:30-'],
+      'supported_on': ['chrome_os:30-', 'chrome.linux:30-', 'chrome.win:30-', 'chrome.bsd:30-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': False,
@@ -6513,7 +6513,7 @@
       'name': 'BackgroundModeEnabled',
       'type': 'main',
       'schema': { 'type': 'boolean' },
-      'supported_on': ['chrome.win:19-', 'chrome.linux:19-'],
+      'supported_on': ['chrome.win:19-', 'chrome.linux:19-', 'chrome.bsd:19-'],
       'features': {
         'can_be_recommended': True,
         'dynamic_refresh': True,
@@ -7028,7 +7028,7 @@
       'name': 'FullscreenAllowed',
       'type': 'main',
       'schema': { 'type': 'boolean' },
-      'supported_on': ['chrome.win:31-', 'chrome.linux:31-', 'chrome_os:31-'],
+      'supported_on': ['chrome.win:31-', 'chrome.linux:31-', 'chrome_os:31-', 'chrome.bsd:31-'],
       'features': {
         'dynamic_refresh': True,
         'per_profile': True,
diff --git components/policy/tools/generate_policy_source.py components/policy/tools/generate_policy_source.py
index b83486ebb0..e9e8fd5c4d 100755
--- components/policy/tools/generate_policy_source.py
+++ components/policy/tools/generate_policy_source.py
@@ -91,7 +91,7 @@ class PolicyDetails:
         raise RuntimeError('is_device_only is only allowed for Chrome OS: "%s"'
                            % p)
       if platform not in ['chrome_frame', 'chrome_os',
-                          'android', 'webview_android',
+                          'android', 'webview_android', 'chrome.bsd',
                           'chrome.win', 'chrome.linux', 'chrome.mac',
                           'chrome.fuchsia', 'chrome.*']:
         raise RuntimeError('Platform "%s" is not supported' % platform)
@@ -111,7 +111,7 @@ class PolicyDetails:
       if platform.startswith('chrome.'):
         platform_sub = platform[7:]
         if platform_sub == '*':
-          self.platforms.extend(['win', 'mac', 'linux', 'fuchsia'])
+          self.platforms.extend(['win', 'mac', 'linux', 'fuchsia', 'bsd'])
         else:
           self.platforms.append(platform_sub)
       else:
diff --git components/services/filesystem/file_system_app.cc components/services/filesystem/file_system_app.cc
index 047645f49d..13d378c0f0 100644
--- components/services/filesystem/file_system_app.cc
+++ components/services/filesystem/file_system_app.cc
@@ -20,7 +20,7 @@
 #elif defined(OS_ANDROID)
 #include "base/base_paths_android.h"
 #include "base/path_service.h"
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
 #include "base/environment.h"
 #include "base/nix/xdg_util.h"
 #elif defined(OS_MACOSX)
@@ -75,7 +75,7 @@ base::FilePath FileSystemApp::GetUserDataDir() {
     CHECK(base::PathService::Get(base::DIR_APP_DATA, &path));
 #elif defined(OS_ANDROID)
     CHECK(base::PathService::Get(base::DIR_ANDROID_APP_DATA, &path));
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
     std::unique_ptr<base::Environment> env(base::Environment::Create());
     path = base::nix::GetXDGDirectory(
         env.get(), base::nix::kXdgConfigHomeEnvVar, base::nix::kDotConfigDir);
diff --git components/storage_monitor/BUILD.gn components/storage_monitor/BUILD.gn
index a3d2988029..de773c4d31 100644
--- components/storage_monitor/BUILD.gn
+++ components/storage_monitor/BUILD.gn
@@ -65,6 +65,17 @@ static_library("storage_monitor") {
     ]
   }
 
+  if (is_bsd) {
+    sources -= [
+      "mtab_watcher_linux.cc",
+      "mtab_watcher_linux.h",
+    ]
+    sources += [
+      "storage_monitor_freebsd.cc",
+      "storage_monitor_freebsd.h",
+    ]
+  }
+
   if (use_udev) {
     deps += [ "//device/udev_linux" ]
   } else if (is_linux) {
diff --git components/storage_monitor/storage_monitor_freebsd.cc components/storage_monitor/storage_monitor_freebsd.cc
new file mode 100644
index 0000000000..d4730eba28
--- /dev/null
+++ components/storage_monitor/storage_monitor_freebsd.cc
@@ -0,0 +1,54 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// StorageMonitorFreeBSD implementation.
+
+#include "components/storage_monitor/storage_monitor_freebsd.h"
+
+#include <stdio.h>
+
+#include <list>
+
+#include "base/bind.h"
+#include "base/metrics/histogram.h"
+#include "base/process/kill.h"
+#include "base/process/launch.h"
+#include "base/stl_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "components/storage_monitor/media_storage_util.h"
+#include "components/storage_monitor/removable_device_constants.h"
+#include "components/storage_monitor/storage_info.h"
+
+using content::BrowserThread;
+
+namespace storage_monitor {
+
+namespace {
+
+}  // namespace
+
+StorageMonitorFreeBSD::StorageMonitorFreeBSD() {
+  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
+}
+
+StorageMonitorFreeBSD::~StorageMonitorFreeBSD() {
+  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));
+}
+
+void StorageMonitorFreeBSD::Init() {
+}
+
+bool StorageMonitorFreeBSD::GetStorageInfoForPath(
+    const base::FilePath& path,
+    StorageInfo* device_info) const {
+  return false; // TODO
+}
+
+StorageMonitor* StorageMonitor::CreateInternal() {
+  return new StorageMonitorFreeBSD();
+}
+
+} // namespace storage_monitor
diff --git components/storage_monitor/storage_monitor_freebsd.h components/storage_monitor/storage_monitor_freebsd.h
new file mode 100644
index 0000000000..894c95c467
--- /dev/null
+++ components/storage_monitor/storage_monitor_freebsd.h
@@ -0,0 +1,45 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// StorageMonitorFreeBSD processes mount point change events, notifies listeners
+// about the addition and deletion of media devices, and answers queries about
+// mounted devices.
+// StorageMonitorFreeBSD lives on the UI thread, and uses ???
+// the FILE thread to get mount point change events.
+
+#ifndef COMPONENTS_STORAGE_MONITOR_STORAGE_MONITOR_FREEBSD_H_
+#define COMPONENTS_STORAGE_MONITOR_STORAGE_MONITOR_FREEBSD_H_
+
+#include <map>
+#include <string>
+
+#include "base/compiler_specific.h"
+#include "base/files/file_path.h"
+#include "base/files/file_path_watcher.h"
+#include "base/memory/weak_ptr.h"
+#include "components/storage_monitor/storage_monitor.h"
+#include "content/public/browser/browser_thread.h"
+
+namespace storage_monitor {
+
+class StorageMonitorFreeBSD : public StorageMonitor {
+ public:
+  // Should only be called by browser start up code.
+  // Use StorageMonitor::GetInstance() instead.
+  explicit StorageMonitorFreeBSD();
+  virtual ~StorageMonitorFreeBSD();
+
+  // Must be called for StorageMonitorFreeBSD to work.
+  virtual void Init() override;
+ private:
+  // StorageMonitor implementation.
+  virtual bool GetStorageInfoForPath(const base::FilePath& path,
+                                     StorageInfo* device_info) const override;
+
+  DISALLOW_COPY_AND_ASSIGN(StorageMonitorFreeBSD);
+};
+
+} // namespace storage_monitor
+
+#endif  // COMPONENTS_STORAGE_MONITOR_STORAGE_MONITOR_FREEBSD_H_
diff --git components/sync/base/get_session_name.cc components/sync/base/get_session_name.cc
index 5c809298e2..0570721f4d 100644
--- components/sync/base/get_session_name.cc
+++ components/sync/base/get_session_name.cc
@@ -17,7 +17,7 @@
 
 #if defined(OS_CHROMEOS)
 #include "chromeos/system/devicetype.h"
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
 #include "components/sync/base/get_session_name_linux.h"
 #elif defined(OS_IOS)
 #include "components/sync/base/get_session_name_ios.h"
@@ -54,7 +54,7 @@ std::string GetSessionNameSynchronously() {
       session_name = "Chromebook";
       break;
   }
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   session_name = internal::GetHostname();
 #elif defined(OS_IOS)
   session_name = internal::GetComputerName();
diff --git components/sync/base/get_session_name_linux.cc components/sync/base/get_session_name_linux.cc
index b7e0b4426c..ebbfd64441 100644
--- components/sync/base/get_session_name_linux.cc
+++ components/sync/base/get_session_name_linux.cc
@@ -13,8 +13,9 @@ namespace syncer {
 namespace internal {
 
 std::string GetHostname() {
-  char hostname[HOST_NAME_MAX];
-  if (gethostname(hostname, HOST_NAME_MAX) == 0)  // Success.
+  int len = sysconf(_SC_HOST_NAME_MAX);
+  char hostname[len];
+  if (gethostname(hostname, len) == 0)  // Success.
     return hostname;
   return base::GetLinuxDistro();
 }
diff --git components/update_client/update_query_params.cc components/update_client/update_query_params.cc
index 272016c762..17d2b80c4e 100644
--- components/update_client/update_query_params.cc
+++ components/update_client/update_query_params.cc
@@ -38,12 +38,16 @@ const char kOs[] =
     "fuchsia";
 #elif defined(OS_OPENBSD)
     "openbsd";
+#elif defined(OS_FREEBSD)
+    "freebsd";
+#elif defined(OS_DRAGONFLY)
+    "dragonfly";
 #else
 #error "unknown os"
 #endif
 
 const char kArch[] =
-#if defined(__amd64__) || defined(_WIN64)
+#if defined(__amd64__) || defined(__x86_64__) || defined(_WIN64)
     "x64";
 #elif defined(__i386__) || defined(_WIN32)
     "x86";
diff --git components/url_matcher/regex_set_matcher.cc components/url_matcher/regex_set_matcher.cc
index ce110293c8..7d0a5e613e 100644
--- components/url_matcher/regex_set_matcher.cc
+++ components/url_matcher/regex_set_matcher.cc
@@ -11,8 +11,13 @@
 #include "base/logging.h"
 #include "base/strings/string_util.h"
 #include "components/url_matcher/substring_set_matcher.h"
+#if defined(OS_BSD)
+#include <re2/filtered_re2.h>
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/filtered_re2.h"
 #include "third_party/re2/src/re2/re2.h"
+#endif
 
 namespace url_matcher {
 
diff --git components/url_matcher/url_matcher_factory.cc components/url_matcher/url_matcher_factory.cc
index 50c85e716f..8e1d037d8e 100644
--- components/url_matcher/url_matcher_factory.cc
+++ components/url_matcher/url_matcher_factory.cc
@@ -16,7 +16,11 @@
 #include "base/values.h"
 #include "components/url_matcher/url_matcher_constants.h"
 #include "components/url_matcher/url_matcher_helpers.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 
 namespace url_matcher {
 
diff --git components/webcrypto/algorithms/test_helpers.cc components/webcrypto/algorithms/test_helpers.cc
index 82b151435c..000329cc88 100644
--- components/webcrypto/algorithms/test_helpers.cc
+++ components/webcrypto/algorithms/test_helpers.cc
@@ -25,7 +25,11 @@
 #include "components/webcrypto/status.h"
 #include "third_party/blink/public/platform/web_crypto_algorithm_params.h"
 #include "third_party/blink/public/platform/web_crypto_key_algorithm.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 
 namespace webcrypto {
 
diff --git content/app/content_main_runner_impl.cc content/app/content_main_runner_impl.cc
index 83e8990edf..f55588dfe1 100644
--- content/app/content_main_runner_impl.cc
+++ content/app/content_main_runner_impl.cc
@@ -83,10 +83,10 @@
 #include "base/posix/global_descriptors.h"
 #include "content/public/common/content_descriptors.h"
 
-#if !defined(OS_MACOSX)
+#if !defined(OS_MACOSX) && !defined(OS_BSD)
 #include "services/service_manager/zygote/common/zygote_fork_delegate_linux.h"
 #endif
-#if !defined(OS_MACOSX) && !defined(OS_ANDROID)
+#if !defined(OS_MACOSX) && !defined(OS_ANDROID) && !defined(OS_BSD)
 #include "sandbox/linux/services/libc_interceptor.h"
 #include "services/service_manager/zygote/zygote_main.h"
 #endif
@@ -150,7 +150,7 @@
 namespace content {
 extern int GpuMain(const content::MainFunctionParams&);
 #if BUILDFLAG(ENABLE_PLUGINS)
-#if !defined(OS_LINUX)
+#if !defined(OS_LINUX) && !defined(OS_BSD)
 extern int PluginMain(const content::MainFunctionParams&);
 #endif
 extern int PpapiPluginMain(const MainFunctionParams&);
@@ -722,11 +722,11 @@ int ContentMainRunnerImpl::Initialize(const ContentMainParams& params) {
                    base::GlobalDescriptors::kBaseDescriptor);
 #endif  // !OS_ANDROID
 
-#if defined(OS_LINUX) || defined(OS_OPENBSD)
+#if defined(OS_LINUX)
     g_fds->Set(service_manager::kCrashDumpSignal,
                service_manager::kCrashDumpSignal +
                    base::GlobalDescriptors::kBaseDescriptor);
-#endif  // OS_LINUX || OS_OPENBSD
+#endif  // OS_LINUX
 
 #endif  // !OS_WIN
 
diff --git content/browser/BUILD.gn content/browser/BUILD.gn
index 5747496dc5..366e88d9c8 100644
--- content/browser/BUILD.gn
+++ content/browser/BUILD.gn
@@ -1802,11 +1802,6 @@ jumbo_source_set("browser") {
       "tracing/cros_tracing_agent.cc",
       "tracing/cros_tracing_agent.h",
     ]
-  } else {
-    sources += [
-      "memory/memory_monitor_linux.cc",
-      "memory/memory_monitor_linux.h",
-    ]
   }
 
   if (is_chromeos || is_android || is_chromecast) {
diff --git content/browser/background_fetch/background_fetch_context.cc content/browser/background_fetch/background_fetch_context.cc
index 0ddea26140..648e3b818c 100644
--- content/browser/background_fetch/background_fetch_context.cc
+++ content/browser/background_fetch/background_fetch_context.cc
@@ -218,7 +218,8 @@ void BackgroundFetchContext::InitializeController(
 
   scheduler_->AddJobController(controller.get());
 
-  job_controllers_.insert({unique_id, std::move(controller)});
+  auto pair = std::make_pair(unique_id, std::move(controller));
+  job_controllers_.insert(std::move(pair));
   std::move(done_closure).Run();
 }
 
diff --git content/browser/browser_main_loop.cc content/browser/browser_main_loop.cc
index 10de251acc..aba9f859d0 100644
--- content/browser/browser_main_loop.cc
+++ content/browser/browser_main_loop.cc
@@ -234,6 +234,13 @@
 #include "services/ui/common/image_cursors_set.h"
 #endif
 
+#if defined(OS_BSD)
+#include "content/browser/sandbox_host_linux.h"
+#include "services/service_manager/zygote/common/common_sandbox_support_linux.h"
+#include "content/public/common/common_sandbox_support_linux.h"
+#include "services/service_manager/sandbox/sandbox.h"
+#endif
+
 // One of the linux specific headers defines this as a macro.
 #ifdef DestroyAll
 #undef DestroyAll
@@ -546,6 +553,11 @@ int BrowserMainLoop::EarlyInitialization() {
   // by now since a thread to start the ServiceManager has been created
   // before the browser main loop starts.
   DCHECK(SandboxHostLinux::GetInstance()->IsInitialized());
+#elif defined(OS_BSD)
+  SandboxHostLinux::GetInstance()->Init();
+  base::FileHandleMappingVector fds_to_map;
+  const int sfd = SandboxHostLinux::GetInstance()->GetChildSocket();
+  fds_to_map.push_back(std::make_pair(sfd, service_manager::GetSandboxFD()));
 #endif
 
 #if defined(USE_X11)
diff --git content/browser/child_process_launcher_helper_linux.cc content/browser/child_process_launcher_helper_linux.cc
index 5db82c367a..fa6b1b2c26 100644
--- content/browser/child_process_launcher_helper_linux.cc
+++ content/browser/child_process_launcher_helper_linux.cc
@@ -18,7 +18,9 @@
 #include "gpu/config/gpu_switches.h"
 #include "services/service_manager/sandbox/linux/sandbox_linux.h"
 #include "services/service_manager/zygote/common/common_sandbox_support_linux.h"
+#if !defined(OS_BSD)
 #include "services/service_manager/zygote/common/zygote_handle.h"
+#endif
 #include "services/service_manager/zygote/host/zygote_communication_linux.h"
 #include "services/service_manager/zygote/host/zygote_host_impl_linux.h"
 
@@ -72,6 +74,7 @@ ChildProcessLauncherHelper::LaunchProcessOnLauncherThread(
     int* launch_result) {
   *is_synchronous_launch = true;
 
+#if !defined(OS_BSD)
   service_manager::ZygoteHandle zygote_handle =
       base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kNoZygote)
           ? nullptr
@@ -85,7 +88,6 @@ ChildProcessLauncherHelper::LaunchProcessOnLauncherThread(
         GetProcessType());
     *launch_result = LAUNCH_RESULT_SUCCESS;
 
-#if !defined(OS_OPENBSD)
     if (handle) {
       // This is just a starting score for a renderer or extension (the
       // only types of processes that will be started this way).  It will
@@ -96,13 +98,13 @@ ChildProcessLauncherHelper::LaunchProcessOnLauncherThread(
       service_manager::ZygoteHostImpl::GetInstance()->AdjustRendererOOMScore(
           handle, kLowestRendererOomScore);
     }
-#endif
 
     Process process;
     process.process = base::Process(handle);
     process.zygote = zygote_handle;
     return process;
   }
+#endif
 
   Process process;
   process.process = base::LaunchProcess(*command_line(), options);
@@ -120,10 +122,14 @@ ChildProcessTerminationInfo ChildProcessLauncherHelper::GetTerminationInfo(
     const ChildProcessLauncherHelper::Process& process,
     bool known_dead) {
   ChildProcessTerminationInfo info;
+#if !defined(OS_BSD)
   if (process.zygote) {
     info.status = process.zygote->GetTerminationStatus(
         process.process.Handle(), known_dead, &info.exit_code);
   } else if (known_dead) {
+#else
+  if (known_dead) {
+#endif
     info.status = base::GetKnownDeadTerminationStatus(process.process.Handle(),
                                                       &info.exit_code);
   } else {
@@ -147,13 +153,17 @@ void ChildProcessLauncherHelper::ForceNormalProcessTerminationSync(
   DCHECK(CurrentlyOnProcessLauncherTaskRunner());
   process.process.Terminate(service_manager::RESULT_CODE_NORMAL_EXIT, false);
   // On POSIX, we must additionally reap the child.
+#if !defined(OS_BSD)
   if (process.zygote) {
     // If the renderer was created via a zygote, we have to proxy the reaping
     // through the zygote process.
     process.zygote->EnsureProcessTerminated(process.process.Handle());
   } else {
+#endif
     base::EnsureProcessTerminated(std::move(process.process));
+#if !defined(OS_BSD)
   }
+#endif
 }
 
 void ChildProcessLauncherHelper::SetProcessPriorityOnLauncherThread(
diff --git content/browser/media/media_internals.cc content/browser/media/media_internals.cc
index e245a5fead..f056efe9d8 100644
--- content/browser/media/media_internals.cc
+++ content/browser/media/media_internals.cc
@@ -708,7 +708,7 @@ void MediaInternals::UpdateVideoCaptureDeviceCapabilities(
     device_dict->SetString("name", descriptor.GetNameAndModel());
     device_dict->Set("formats", std::move(format_list));
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_ANDROID)
+    defined(OS_ANDROID) || defined(OS_BSD)
     device_dict->SetString("captureApi", descriptor.GetCaptureApiTypeString());
 #endif
     video_capture_capabilities_cached_data_.Append(std::move(device_dict));
diff --git content/browser/memory/memory_monitor.cc content/browser/memory/memory_monitor.cc
index a9e168457d..54011f1d18 100644
--- content/browser/memory/memory_monitor.cc
+++ content/browser/memory/memory_monitor.cc
@@ -22,7 +22,7 @@ void MemoryMonitorDelegate::GetSystemMemoryInfo(
   base::GetSystemMemoryInfo(mem_info);
 }
 
-#if defined(OS_MACOSX)
+#if defined(OS_MACOSX) || defined(OS_BSD)
 // TODO(bashi,bcwhite): Remove when memory monitor for mac is available.
 std::unique_ptr<MemoryMonitor> CreateMemoryMonitor() {
   NOTREACHED();
diff --git content/browser/memory/swap_metrics_driver_impl_linux.cc content/browser/memory/swap_metrics_driver_impl_linux.cc
index 1b045104fd..c7867ba279 100644
--- content/browser/memory/swap_metrics_driver_impl_linux.cc
+++ content/browser/memory/swap_metrics_driver_impl_linux.cc
@@ -44,9 +44,13 @@ SwapMetricsDriverImplLinux::~SwapMetricsDriverImplLinux() = default;
 SwapMetricsDriver::SwapMetricsUpdateResult
 SwapMetricsDriverImplLinux::UpdateMetricsInternal(base::TimeDelta interval) {
   base::VmStatInfo vmstat;
+#if !defined(OS_BSD)
   if (!base::GetVmStatInfo(&vmstat)) {
     return SwapMetricsDriver::SwapMetricsUpdateResult::kSwapMetricsUpdateFailed;
   }
+#else
+    return SwapMetricsDriver::SwapMetricsUpdateResult::kSwapMetricsUpdateFailed;
+#endif
 
   uint64_t in_counts = vmstat.pswpin - last_pswpin_;
   uint64_t out_counts = vmstat.pswpout - last_pswpout_;
diff --git content/browser/renderer_host/render_message_filter.cc content/browser/renderer_host/render_message_filter.cc
index 765a466446..9f0b3eefca 100644
--- content/browser/renderer_host/render_message_filter.cc
+++ content/browser/renderer_host/render_message_filter.cc
@@ -75,7 +75,7 @@
 #if defined(OS_MACOSX)
 #include "ui/accelerated_widget_mac/window_resize_helper_mac.h"
 #endif
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include "base/linux_util.h"
 #include "base/threading/platform_thread.h"
 #endif
@@ -169,7 +169,7 @@ void RenderMessageFilter::CreateFullscreenWidget(
   std::move(callback).Run(route_id);
 }
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 void RenderMessageFilter::SetThreadPriorityOnFileThread(
     base::PlatformThreadId ns_tid,
     base::ThreadPriority priority) {
@@ -190,7 +190,7 @@ void RenderMessageFilter::SetThreadPriorityOnFileThread(
 }
 #endif
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 void RenderMessageFilter::SetThreadPriority(int32_t ns_tid,
                                             base::ThreadPriority priority) {
   constexpr base::TaskTraits kTraits = {
diff --git content/browser/renderer_host/render_message_filter.h content/browser/renderer_host/render_message_filter.h
index d22da30d12..73d764d0f9 100644
--- content/browser/renderer_host/render_message_filter.h
+++ content/browser/renderer_host/render_message_filter.h
@@ -113,14 +113,14 @@ class CONTENT_EXPORT RenderMessageFilter
       const url::Origin& cache_storage_origin,
       const std::string& cache_storage_cache_name) override;
   void HasGpuProcess(HasGpuProcessCallback callback) override;
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   void SetThreadPriority(int32_t ns_tid,
                          base::ThreadPriority priority) override;
 #endif
 
   void OnResolveProxy(const GURL& url, IPC::Message* reply_msg);
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   void SetThreadPriorityOnFileThread(base::PlatformThreadId ns_tid,
                                      base::ThreadPriority priority);
 #endif
diff --git content/browser/renderer_host/render_process_host_impl.h content/browser/renderer_host/render_process_host_impl.h
index b418b4c8a0..206cc7b78d 100644
--- content/browser/renderer_host/render_process_host_impl.h
+++ content/browser/renderer_host/render_process_host_impl.h
@@ -338,10 +338,10 @@ class CONTENT_EXPORT RenderProcessHostImpl
     is_for_guests_only_ = is_for_guests_only;
   }
 
-#if defined(OS_POSIX) && !defined(OS_ANDROID) && !defined(OS_MACOSX)
+#if defined(OS_POSIX) && !defined(OS_ANDROID) && !defined(OS_MACOSX) && !defined(OS_BSD)
   // Launch the zygote early in the browser startup.
   static void EarlyZygoteLaunch();
-#endif  // defined(OS_POSIX) && !defined(OS_ANDROID) && !defined(OS_MACOSX)
+#endif  // defined(OS_POSIX) && !defined(OS_ANDROID) && !defined(OS_MACOSX) && !defined(OS_BSD)
 
   void RecomputeAndUpdateWebKitPreferences();
 
diff --git content/browser/renderer_host/render_view_host_impl.cc content/browser/renderer_host/render_view_host_impl.cc
index e8aa2e41e8..abb08c2283 100644
--- content/browser/renderer_host/render_view_host_impl.cc
+++ content/browser/renderer_host/render_view_host_impl.cc
@@ -145,7 +145,7 @@ void GetPlatformSpecificPrefs(RendererPreferences* prefs) {
       display::win::ScreenWin::GetSystemMetricsInDIP(SM_CYVSCROLL);
   prefs->arrow_bitmap_width_horizontal_scroll_bar_in_dips =
       display::win::ScreenWin::GetSystemMetricsInDIP(SM_CXHSCROLL);
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   prefs->system_font_family_name = gfx::Font().GetFontName();
 #endif
 }
diff --git content/browser/renderer_host/render_widget_host_view_aura.cc content/browser/renderer_host/render_widget_host_view_aura.cc
index 861122e990..92558e5d75 100644
--- content/browser/renderer_host/render_widget_host_view_aura.cc
+++ content/browser/renderer_host/render_widget_host_view_aura.cc
@@ -118,7 +118,7 @@
 #include "content/browser/accessibility/browser_accessibility_auralinux.h"
 #endif
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
 #include "ui/base/ime/linux/text_edit_command_auralinux.h"
 #include "ui/base/ime/linux/text_edit_key_bindings_delegate_auralinux.h"
 #endif
@@ -2072,7 +2072,7 @@ bool RenderWidgetHostViewAura::NeedsInputGrab() {
 }
 
 bool RenderWidgetHostViewAura::NeedsMouseCapture() {
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
   return NeedsInputGrab();
 #endif
   return false;
@@ -2294,7 +2294,7 @@ void RenderWidgetHostViewAura::ForwardKeyboardEventWithLatencyInfo(
   if (!target_host)
     return;
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
   ui::TextEditKeyBindingsDelegateAuraLinux* keybinding_delegate =
       ui::GetTextEditKeyBindingsDelegate();
   std::vector<ui::TextEditCommandAuraLinux> commands;
diff --git content/browser/renderer_host/render_widget_host_view_event_handler.cc content/browser/renderer_host/render_widget_host_view_event_handler.cc
index af9912a5f0..a832464b38 100644
--- content/browser/renderer_host/render_widget_host_view_event_handler.cc
+++ content/browser/renderer_host/render_widget_host_view_event_handler.cc
@@ -617,7 +617,7 @@ bool RenderWidgetHostViewEventHandler::CanRendererHandleEvent(
   if (event->type() == ui::ET_MOUSE_EXITED) {
     if (mouse_locked || selection_popup)
       return false;
-#if defined(OS_WIN) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_BSD)
     // Don't forward the mouse leave message which is received when the context
     // menu is displayed by the page. This confuses the page and causes state
     // changes.
diff --git content/browser/webui/web_ui_data_source_impl.cc content/browser/webui/web_ui_data_source_impl.cc
index 5dad37af6f..1087e1b16b 100644
--- content/browser/webui/web_ui_data_source_impl.cc
+++ content/browser/webui/web_ui_data_source_impl.cc
@@ -120,24 +120,24 @@ WebUIDataSourceImpl::WebUIDataSourceImpl(const std::string& source_name)
 WebUIDataSourceImpl::~WebUIDataSourceImpl() {
 }
 
-void WebUIDataSourceImpl::AddString(base::StringPiece name,
+void WebUIDataSourceImpl::AddString(const std::string& name,
                                     const base::string16& value) {
   // TODO(dschuyler): Share only one copy of these strings.
   localized_strings_.SetKey(name, base::Value(value));
-  replacements_[name.as_string()] = base::UTF16ToUTF8(value);
+  replacements_[name] = base::UTF16ToUTF8(value);
 }
 
-void WebUIDataSourceImpl::AddString(base::StringPiece name,
+void WebUIDataSourceImpl::AddString(const std::string& name,
                                     const std::string& value) {
   localized_strings_.SetKey(name, base::Value(value));
-  replacements_[name.as_string()] = value;
+  replacements_[name] = value;
 }
 
-void WebUIDataSourceImpl::AddLocalizedString(base::StringPiece name, int ids) {
+void WebUIDataSourceImpl::AddLocalizedString(const std::string& name, int ids) {
   std::string utf8_str =
       base::UTF16ToUTF8(GetContentClient()->GetLocalizedString(ids));
   localized_strings_.SetKey(name, base::Value(utf8_str));
-  replacements_[name.as_string()] = utf8_str;
+  replacements_[name] = utf8_str;
 }
 
 void WebUIDataSourceImpl::AddLocalizedStrings(
@@ -147,7 +147,7 @@ void WebUIDataSourceImpl::AddLocalizedStrings(
                                               &replacements_);
 }
 
-void WebUIDataSourceImpl::AddBoolean(base::StringPiece name, bool value) {
+void WebUIDataSourceImpl::AddBoolean(const std::string& name, bool value) {
   localized_strings_.SetBoolean(name, value);
   // TODO(dschuyler): Change name of |localized_strings_| to |load_time_data_|
   // or similar. These values haven't been found as strings for
@@ -156,21 +156,21 @@ void WebUIDataSourceImpl::AddBoolean(base::StringPiece name, bool value) {
   // replacements.
 }
 
-void WebUIDataSourceImpl::AddInteger(base::StringPiece name, int32_t value) {
+void WebUIDataSourceImpl::AddInteger(const std::string& name, int32_t value) {
   localized_strings_.SetInteger(name, value);
 }
 
-void WebUIDataSourceImpl::SetJsonPath(base::StringPiece path) {
+void WebUIDataSourceImpl::SetJsonPath(const std::string& path) {
   DCHECK(json_path_.empty());
   DCHECK(!path.empty());
 
-  json_path_ = path.as_string();
+  json_path_ = path;
   excluded_paths_.insert(json_path_);
 }
 
-void WebUIDataSourceImpl::AddResourcePath(base::StringPiece path,
+void WebUIDataSourceImpl::AddResourcePath(const std::string &path,
                                           int resource_id) {
-  path_to_idr_map_[path.as_string()] = resource_id;
+  path_to_idr_map_[path] = resource_id;
 }
 
 void WebUIDataSourceImpl::SetDefaultResource(int resource_id) {
diff --git content/browser/webui/web_ui_data_source_impl.h content/browser/webui/web_ui_data_source_impl.h
index 06c1bd9af0..3b41239c31 100644
--- content/browser/webui/web_ui_data_source_impl.h
+++ content/browser/webui/web_ui_data_source_impl.h
@@ -31,15 +31,15 @@ class CONTENT_EXPORT WebUIDataSourceImpl : public URLDataSourceImpl,
                                            public WebUIDataSource {
  public:
   // WebUIDataSource implementation:
-  void AddString(base::StringPiece name, const base::string16& value) override;
-  void AddString(base::StringPiece name, const std::string& value) override;
-  void AddLocalizedString(base::StringPiece name, int ids) override;
+  void AddString(const std::string& name, const base::string16& value) override;
+  void AddString(const std::string& name, const std::string& value) override;
+  void AddLocalizedString(const std::string& name, int ids) override;
   void AddLocalizedStrings(
       const base::DictionaryValue& localized_strings) override;
-  void AddBoolean(base::StringPiece name, bool value) override;
-  void AddInteger(base::StringPiece name, int32_t value) override;
-  void SetJsonPath(base::StringPiece path) override;
-  void AddResourcePath(base::StringPiece path, int resource_id) override;
+  void AddBoolean(const std::string& name, bool value) override;
+  void AddInteger(const std::string& name, int32_t value) override;
+  void SetJsonPath(const std::string& path) override;
+  void AddResourcePath(const std::string& path, int resource_id) override;
   void SetDefaultResource(int resource_id) override;
   void SetRequestFilter(
       const WebUIDataSource::HandleRequestCallback& callback) override;
diff --git content/browser/webui/web_ui_impl.cc content/browser/webui/web_ui_impl.cc
index ceac82cbc8..d8053a32d5 100644
--- content/browser/webui/web_ui_impl.cc
+++ content/browser/webui/web_ui_impl.cc
@@ -248,9 +248,9 @@ void WebUIImpl::CallJavascriptFunctionUnsafe(
   ExecuteJavascript(GetJavascriptCall(function_name, args));
 }
 
-void WebUIImpl::RegisterMessageCallback(base::StringPiece message,
+void WebUIImpl::RegisterMessageCallback(const std::string &message,
                                         const MessageCallback& callback) {
-  message_callbacks_.emplace(message, callback);
+  message_callbacks_.insert(std::make_pair(message, callback));
 }
 
 void WebUIImpl::ProcessWebUIMessage(const GURL& source_url,
diff --git content/browser/webui/web_ui_impl.h content/browser/webui/web_ui_impl.h
index 484f918c98..669bd906cf 100644
--- content/browser/webui/web_ui_impl.h
+++ content/browser/webui/web_ui_impl.h
@@ -52,7 +52,7 @@ class CONTENT_EXPORT WebUIImpl : public WebUI,
   int GetBindings() const override;
   void SetBindings(int bindings) override;
   void AddMessageHandler(std::unique_ptr<WebUIMessageHandler> handler) override;
-  void RegisterMessageCallback(base::StringPiece message,
+  void RegisterMessageCallback(const std::string& message,
                                const MessageCallback& callback) override;
   void ProcessWebUIMessage(const GURL& source_url,
                            const std::string& message,
diff --git content/common/BUILD.gn content/common/BUILD.gn
index de4c4d2af4..f9c1b42db7 100644
--- content/common/BUILD.gn
+++ content/common/BUILD.gn
@@ -424,6 +424,12 @@ source_set("common") {
     libs += [ "android" ]
   }
 
+  if (is_bsd) {
+    sources -= [
+      "sandbox_init_linux.cc",
+    ]
+  }
+
   if (is_debug && !is_component_build && enable_plugins) {
     # Content depends on the PPAPI message logging stuff; if this isn't here,
     # some unit test binaries won't compile. This only worked in release mode
diff --git content/common/common_sandbox_support_linux.cc content/common/common_sandbox_support_linux.cc
index c80e44a6d2..c4ceb7f846 100644
--- content/common/common_sandbox_support_linux.cc
+++ content/common/common_sandbox_support_linux.cc
@@ -5,6 +5,7 @@
 #include "content/public/common/common_sandbox_support_linux.h"
 
 #include <sys/stat.h>
+#include <unistd.h>
 
 #include <limits>
 #include <memory>
diff --git content/common/user_agent.cc content/common/user_agent.cc
index e4565757f8..80fbb97ea0 100644
--- content/common/user_agent.cc
+++ content/common/user_agent.cc
@@ -125,6 +125,14 @@ std::string BuildOSCpuInfo() {
 #endif
   );  // NOLINT
 
+#if defined(OS_BSD)
+#if defined(__x86_64__)
+  base::StringAppendF(&os_cpu, "; Linux x86_64");
+#else
+  base::StringAppendF(&os_cpu, "; Linux i686");
+#endif
+#endif
+
   return os_cpu;
 }
 
diff --git content/common/view_messages.h content/common/view_messages.h
index 7411a755dd..7ec9e6d843 100644
--- content/common/view_messages.h
+++ content/common/view_messages.h
@@ -228,7 +228,7 @@ IPC_STRUCT_TRAITS_BEGIN(content::RendererPreferences)
   IPC_STRUCT_TRAITS_MEMBER(disable_client_blocked_error_page)
   IPC_STRUCT_TRAITS_MEMBER(plugin_fullscreen_allowed)
   IPC_STRUCT_TRAITS_MEMBER(network_contry_iso)
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   IPC_STRUCT_TRAITS_MEMBER(system_font_family_name)
 #endif
 #if defined(OS_WIN)
diff --git content/gpu/BUILD.gn content/gpu/BUILD.gn
index 9a8b1ca6b4..681dd723c7 100644
--- content/gpu/BUILD.gn
+++ content/gpu/BUILD.gn
@@ -131,7 +131,7 @@ target(link_target_type, "gpu_sources") {
 
   # Use DRI on desktop Linux builds.
   if (current_cpu != "s390x" && current_cpu != "ppc64" && is_desktop_linux &&
-      (!is_chromecast || is_cast_desktop_build)) {
+      (!is_chromecast || is_cast_desktop_build) && !is_bsd) {
     configs += [ "//build/config/linux/dri" ]
   }
 }
diff --git content/gpu/gpu_main.cc content/gpu/gpu_main.cc
index e6a589fb90..a03641995c 100644
--- content/gpu/gpu_main.cc
+++ content/gpu/gpu_main.cc
@@ -77,7 +77,7 @@
 #include "ui/gfx/x/x11_switches.h"    // nogncheck
 #endif
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include "content/common/font_config_ipc_linux.h"
 #include "content/gpu/gpu_sandbox_hook_linux.h"
 #include "content/public/common/sandbox_init.h"
@@ -112,7 +112,7 @@ namespace content {
 
 namespace {
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) && !defined(OS_BSD)
 bool StartSandboxLinux(gpu::GpuWatchdogThread*,
                        const gpu::GPUInfo*,
                        const gpu::GpuPreferences&);
@@ -173,7 +173,7 @@ class ContentSandboxHelper : public gpu::GpuSandboxHelper {
   bool EnsureSandboxInitialized(gpu::GpuWatchdogThread* watchdog_thread,
                                 const gpu::GPUInfo* gpu_info,
                                 const gpu::GpuPreferences& gpu_prefs) override {
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) && !defined(OS_BSD)
     return StartSandboxLinux(watchdog_thread, gpu_info, gpu_prefs);
 #elif defined(OS_WIN)
     return StartSandboxWindows(sandbox_info_);
@@ -360,7 +360,7 @@ int GpuMain(const MainFunctionParams& parameters) {
 
 namespace {
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) && !defined(OS_BSD)
 bool StartSandboxLinux(gpu::GpuWatchdogThread* watchdog_thread,
                        const gpu::GPUInfo* gpu_info,
                        const gpu::GpuPreferences& gpu_prefs) {
@@ -395,7 +395,7 @@ bool StartSandboxLinux(gpu::GpuWatchdogThread* watchdog_thread,
 
   return res;
 }
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) && !defined(OS_BSD)
 
 #if defined(OS_WIN)
 bool StartSandboxWindows(const sandbox::SandboxInterfaceInfo* sandbox_info) {
diff --git content/gpu/gpu_sandbox_hook_linux.cc content/gpu/gpu_sandbox_hook_linux.cc
index cd914e2f99..a6b47d9e49 100644
--- content/gpu/gpu_sandbox_hook_linux.cc
+++ content/gpu/gpu_sandbox_hook_linux.cc
@@ -68,7 +68,7 @@ inline bool UseLibV4L2() {
 #endif
 }
 
-constexpr int dlopen_flag = RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE;
+constexpr int dlopen_flag = RTLD_NOW | RTLD_GLOBAL;
 
 void AddV4L2GpuWhitelist(
     std::vector<BrokerFilePermission>* permissions,
diff --git content/ppapi_plugin/ppapi_plugin_main.cc content/ppapi_plugin/ppapi_plugin_main.cc
index c2cf95a216..706e984ed6 100644
--- content/ppapi_plugin/ppapi_plugin_main.cc
+++ content/ppapi_plugin/ppapi_plugin_main.cc
@@ -126,6 +126,8 @@ int PpapiPluginMain(const MainFunctionParams& parameters) {
       service_manager::SandboxTypeFromCommandLine(command_line),
       service_manager::SandboxLinux::PreSandboxHook(),
       service_manager::SandboxLinux::Options());
+#elif defined(OS_BSD)
+  NOTIMPLEMENTED();
 #endif
 
   ChildProcess ppapi_process;
diff --git content/public/browser/web_ui.h content/public/browser/web_ui.h
index 4d32080690..a95b5aada9 100644
--- content/public/browser/web_ui.h
+++ content/public/browser/web_ui.h
@@ -9,7 +9,6 @@
 
 #include "base/callback.h"
 #include "base/strings/string16.h"
-#include "base/strings/string_piece.h"
 #include "content/common/content_export.h"
 #include "ui/base/page_transition_types.h"
 
@@ -73,7 +72,7 @@ class CONTENT_EXPORT WebUI {
   // Used by WebUIMessageHandlers. If the given message is already registered,
   // the call has no effect.
   using MessageCallback = base::RepeatingCallback<void(const base::ListValue*)>;
-  virtual void RegisterMessageCallback(base::StringPiece message,
+  virtual void RegisterMessageCallback(const std::string& message,
                                        const MessageCallback& callback) = 0;
 
   // This is only needed if an embedder overrides handling of a WebUIMessage and
diff --git content/public/browser/web_ui_data_source.h content/public/browser/web_ui_data_source.h
index 4adac767d9..a1a6c97905 100644
--- content/public/browser/web_ui_data_source.h
+++ content/public/browser/web_ui_data_source.h
@@ -13,7 +13,6 @@
 
 #include "base/callback.h"
 #include "base/strings/string16.h"
-#include "base/strings/string_piece.h"
 #include "content/common/content_export.h"
 
 namespace base {
@@ -45,33 +44,33 @@ class WebUIDataSource {
       std::unique_ptr<base::DictionaryValue> update);
 
   // Adds a string keyed to its name to our dictionary.
-  virtual void AddString(base::StringPiece name,
+  virtual void AddString(const std::string& name,
                          const base::string16& value) = 0;
 
   // Adds a string keyed to its name to our dictionary.
-  virtual void AddString(base::StringPiece name, const std::string& value) = 0;
+  virtual void AddString(const std::string& name, const std::string& value) = 0;
 
   // Adds a localized string with resource |ids| keyed to its name to our
   // dictionary.
-  virtual void AddLocalizedString(base::StringPiece name, int ids) = 0;
+  virtual void AddLocalizedString(const std::string& name, int ids) = 0;
 
   // Add strings from |localized_strings| to our dictionary.
   virtual void AddLocalizedStrings(
       const base::DictionaryValue& localized_strings) = 0;
 
   // Adds a boolean keyed to its name to our dictionary.
-  virtual void AddBoolean(base::StringPiece name, bool value) = 0;
+  virtual void AddBoolean(const std::string& name, bool value) = 0;
 
   // Adds a signed 32-bit integer keyed to its name to our dictionary. Larger
   // integers may not be exactly representable in JavaScript. See
   // MAX_SAFE_INTEGER in /v8/src/globals.h.
-  virtual void AddInteger(base::StringPiece name, int32_t value) = 0;
+  virtual void AddInteger(const std::string& name, int32_t value) = 0;
 
   // Sets the path which will return the JSON strings.
-  virtual void SetJsonPath(base::StringPiece path) = 0;
+  virtual void SetJsonPath(const std::string& path) = 0;
 
   // Adds a mapping between a path name and a resource to return.
-  virtual void AddResourcePath(base::StringPiece path, int resource_id) = 0;
+  virtual void AddResourcePath(const std::string& path, int resource_id) = 0;
 
   // Sets the resource to returned when no other paths match.
   virtual void SetDefaultResource(int resource_id) = 0;
diff --git content/public/common/child_process_host.h content/public/common/child_process_host.h
index 926137f283..200441a6ff 100644
--- content/public/common/child_process_host.h
+++ content/public/common/child_process_host.h
@@ -45,7 +45,7 @@ class CONTENT_EXPORT ChildProcessHost : public IPC::Sender {
     // No special behavior requested.
     CHILD_NORMAL = 0,
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     // Indicates that the child execed after forking may be execced from
     // /proc/self/exe rather than using the "real" app path. This prevents
     // autoupdate from confusing us if it changes the file out from under us.
@@ -54,7 +54,7 @@ class CONTENT_EXPORT ChildProcessHost : public IPC::Sender {
     // gdb). In this case, you'd use GetChildPath to get the real executable
     // file name, and then prepend the GDB command to the command line.
     CHILD_ALLOW_SELF = 1 << 0,
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
   };
 
   // Returns the pathname to be used for a child process.  If a subprocess
diff --git content/public/common/content_switches.cc content/public/common/content_switches.cc
index aac63339ab..db5b979d79 100644
--- content/public/common/content_switches.cc
+++ content/public/common/content_switches.cc
@@ -960,7 +960,8 @@ const char kDisableAudioSupportForDesktopShare[] =
 const char kDisablePanelFitting[]           = "disable-panel-fitting";
 #endif
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_FREEBSD) || \
+  defined(OS_DRAGONFLY)
 // Allows sending text-to-speech requests to speech-dispatcher, a common
 // Linux speech service. Because it's buggy, the user must explicitly
 // enable it so that visiting a random webpage can't cause instability.
diff --git content/public/common/content_switches.h content/public/common/content_switches.h
index 990f172ac8..f664ede10e 100644
--- content/public/common/content_switches.h
+++ content/public/common/content_switches.h
@@ -267,7 +267,8 @@ CONTENT_EXPORT extern const char kEnableOSKOverscroll[];
 CONTENT_EXPORT extern const char kDisablePanelFitting[];
 #endif
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_FREEBSD) || \
+  defined(OS_DRAGONFLY)
 CONTENT_EXPORT extern const char kEnableSpeechDispatcher[];
 #endif
 
diff --git content/public/common/renderer_preferences.h content/public/common/renderer_preferences.h
index 688fc6b020..bb1b68819e 100644
--- content/public/common/renderer_preferences.h
+++ content/public/common/renderer_preferences.h
@@ -132,7 +132,7 @@ struct CONTENT_EXPORT RendererPreferences {
   // Country iso of the mobile network for content detection purpose.
   std::string network_contry_iso;
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   std::string system_font_family_name;
 #endif
 
diff --git content/public/test/browser_test_base.cc content/public/test/browser_test_base.cc
index aae1e6cbc6..4033f0d749 100644
--- content/public/test/browser_test_base.cc
+++ content/public/test/browser_test_base.cc
@@ -51,6 +51,10 @@
 #include "ui/gl/gl_implementation.h"
 #include "ui/gl/gl_switches.h"
 
+#if defined(OS_FREEBSD)
+#include <sys/signal.h>
+#endif
+
 #if defined(OS_POSIX)
 #include "base/process/process_handle.h"
 #endif
diff --git content/renderer/input/input_event_prediction.cc content/renderer/input/input_event_prediction.cc
index 89636c9736..b523f99820 100644
--- content/renderer/input/input_event_prediction.cc
+++ content/renderer/input/input_event_prediction.cc
@@ -119,7 +119,8 @@ void InputEventPrediction::UpdateSinglePointer(
     if (predictor != pointer_id_predictor_map_.end()) {
       predictor->second->Update(data);
     } else {
-      pointer_id_predictor_map_.insert({event.id, SetUpPredictor()});
+      auto pair = std::make_pair(event.id, SetUpPredictor());
+      pointer_id_predictor_map_.insert(std::move(pair));
       pointer_id_predictor_map_[event.id]->Update(data);
     }
   }
diff --git content/renderer/media/stream/processed_local_audio_source.cc content/renderer/media/stream/processed_local_audio_source.cc
index 9a13797562..662d7aaf54 100644
--- content/renderer/media/stream/processed_local_audio_source.cc
+++ content/renderer/media/stream/processed_local_audio_source.cc
@@ -262,7 +262,7 @@ void ProcessedLocalAudioSource::Capture(const media::AudioBus* audio_bus,
                                         bool key_pressed) {
 #if defined(OS_WIN) || defined(OS_MACOSX)
   DCHECK_LE(volume, 1.0);
-#elif (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_OPENBSD)
+#elif (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_BSD)
   // We have a special situation on Linux where the microphone volume can be
   // "higher than maximum". The input volume slider in the sound preference
   // allows the user to set a scaling that is higher than 100%. It means that
diff --git content/renderer/render_thread_impl.cc content/renderer/render_thread_impl.cc
index 06f7d44879..883d3e19f8 100644
--- content/renderer/render_thread_impl.cc
+++ content/renderer/render_thread_impl.cc
@@ -199,11 +199,20 @@
 #include "content/common/external_ipc_dumper.h"
 #endif
 
+#if !defined(OS_BSD)
 #if defined(OS_MACOSX)
 #include <malloc/malloc.h>
 #else
 #include <malloc.h>
 #endif
+#endif
+
+#if defined(OS_BSD)
+#include <stddef.h>
+#include <stdint.h>
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#endif
 
 using base::ThreadRestrictions;
 using blink::WebDocument;
@@ -1002,7 +1011,7 @@ void RenderThreadImpl::Init(
   DCHECK(parsed_num_raster_threads) << string_value;
   DCHECK_GT(num_raster_threads, 0);
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   categorized_worker_pool_->SetBackgroundingCallback(
       main_thread_scheduler_->DefaultTaskRunner(),
       base::BindOnce(
@@ -1043,7 +1052,7 @@ void RenderThreadImpl::Init(
   GetConnector()->BindInterface(mojom::kBrowserServiceName,
                                 mojo::MakeRequest(&storage_partition_service_));
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   render_message_filter()->SetThreadPriority(
       ChildProcess::current()->io_thread_id(), base::ThreadPriority::DISPLAY);
 #endif
@@ -1248,7 +1257,7 @@ void RenderThreadImpl::InitializeCompositorThread() {
                      false));
   GetContentClient()->renderer()->PostCompositorThreadCreated(
       compositor_task_runner_.get());
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   render_message_filter()->SetThreadPriority(compositor_thread_->ThreadId(),
                                              base::ThreadPriority::DISPLAY);
 #endif
@@ -1485,7 +1494,7 @@ media::GpuVideoAcceleratorFactories* RenderThreadImpl::GetGpuFactories() {
        gpu::kGpuFeatureStatusEnabled);
   const bool enable_gpu_memory_buffers =
       !is_gpu_compositing_disabled_ &&
-#if defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_WIN)
+#if defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_WIN) || defined(OS_BSD)
       !cmd_line->HasSwitch(switches::kDisableGpuMemoryBufferVideoFrames);
 #else
       cmd_line->HasSwitch(switches::kEnableGpuMemoryBufferVideoFrames);
diff --git content/renderer/renderer_blink_platform_impl.cc content/renderer/renderer_blink_platform_impl.cc
index 4205c92765..80142b21ac 100644
--- content/renderer/renderer_blink_platform_impl.cc
+++ content/renderer/renderer_blink_platform_impl.cc
@@ -131,7 +131,7 @@
 
 #if defined(OS_POSIX)
 #include "base/file_descriptor_posix.h"
-#if !defined(OS_MACOSX) && !defined(OS_ANDROID)
+#if !defined(OS_MACOSX) && !defined(OS_ANDROID) && !defined(OS_BSD)
 #include <map>
 #include <string>
 
@@ -226,7 +226,7 @@ gpu::ContextType ToGpuContextType(blink::Platform::ContextType type) {
 
 //------------------------------------------------------------------------------
 
-#if !defined(OS_ANDROID) && !defined(OS_WIN) && !defined(OS_FUCHSIA)
+#if !defined(OS_ANDROID) && !defined(OS_WIN) && !defined(OS_FUCHSIA) && !defined(OS_BSD)
 class RendererBlinkPlatformImpl::SandboxSupport
     : public blink::WebSandboxSupport {
  public:
@@ -270,7 +270,7 @@ RendererBlinkPlatformImpl::RendererBlinkPlatformImpl(
       default_task_runner_(main_thread_scheduler->DefaultTaskRunner()),
       web_scrollbar_behavior_(new WebScrollbarBehaviorImpl),
       main_thread_scheduler_(main_thread_scheduler) {
-#if !defined(OS_ANDROID) && !defined(OS_WIN) && !defined(OS_FUCHSIA)
+#if !defined(OS_ANDROID) && !defined(OS_WIN) && !defined(OS_FUCHSIA) && !defined(OS_BSD)
   if (g_sandbox_enabled && sandboxEnabled()) {
     sandbox_support_.reset(new RendererBlinkPlatformImpl::SandboxSupport);
   } else {
@@ -310,7 +310,7 @@ RendererBlinkPlatformImpl::~RendererBlinkPlatformImpl() {
 }
 
 void RendererBlinkPlatformImpl::Shutdown() {
-#if !defined(OS_ANDROID) && !defined(OS_WIN) && !defined(OS_FUCHSIA)
+#if !defined(OS_ANDROID) && !defined(OS_WIN) && !defined(OS_FUCHSIA) && !defined(OS_BSD)
   // SandboxSupport contains a map of WebFallbackFont objects, which hold
   // WebStrings and WebVectors, which become invalidated when blink is shut
   // down. Hence, we need to clear that map now, just before blink::shutdown()
@@ -397,7 +397,7 @@ blink::BlameContext* RendererBlinkPlatformImpl::GetTopLevelBlameContext() {
 }
 
 blink::WebSandboxSupport* RendererBlinkPlatformImpl::GetSandboxSupport() {
-#if defined(OS_ANDROID) || defined(OS_WIN) || defined(OS_FUCHSIA)
+#if defined(OS_ANDROID) || defined(OS_WIN) || defined(OS_FUCHSIA) || defined(OS_BSD)
   // These platforms do not require sandbox support.
   return NULL;
 #else
@@ -590,7 +590,7 @@ bool RendererBlinkPlatformImpl::SandboxSupport::LoadFont(CTFontRef src_font,
   return content::LoadFont(src_font, out, font_id);
 }
 
-#elif defined(OS_POSIX) && !defined(OS_ANDROID) && !defined(OS_FUCHSIA)
+#elif defined(OS_POSIX) && !defined(OS_ANDROID) && !defined(OS_FUCHSIA) && !defined(OS_BSD)
 
 void RendererBlinkPlatformImpl::SandboxSupport::GetFallbackFontForCharacter(
     blink::WebUChar32 character,
diff --git content/renderer/renderer_blink_platform_impl.h content/renderer/renderer_blink_platform_impl.h
index ecb5ce6d6a..0a1647ebd3 100644
--- content/renderer/renderer_blink_platform_impl.h
+++ content/renderer/renderer_blink_platform_impl.h
@@ -282,7 +282,7 @@ class CONTENT_EXPORT RendererBlinkPlatformImpl : public BlinkPlatformImpl {
   std::unique_ptr<blink::WebThread> main_thread_;
   std::unique_ptr<service_manager::Connector> connector_;
 
-#if !defined(OS_ANDROID) && !defined(OS_WIN) && !defined(OS_FUCHSIA)
+#if !defined(OS_ANDROID) && !defined(OS_WIN) && !defined(OS_FUCHSIA) && !defined(OS_BSD)
   class SandboxSupport;
   std::unique_ptr<SandboxSupport> sandbox_support_;
 #endif
diff --git content/renderer/renderer_main.cc content/renderer/renderer_main.cc
index f3664c6e0e..187cca2c90 100644
--- content/renderer/renderer_main.cc
+++ content/renderer/renderer_main.cc
@@ -218,7 +218,7 @@ int RendererMain(const MainFunctionParams& parameters) {
   InitializeWebRtcModule();
 
   {
-#if defined(OS_WIN) || defined(OS_MACOSX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_BSD)
     // TODO(markus): Check if it is OK to unconditionally move this
     // instruction down.
     auto render_process = RenderProcessImpl::Create();
@@ -228,7 +228,7 @@ int RendererMain(const MainFunctionParams& parameters) {
     bool run_loop = true;
     if (!no_sandbox)
       run_loop = platform.EnableSandbox();
-#if defined(OS_POSIX) && !defined(OS_MACOSX)
+#if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_BSD)
     auto render_process = RenderProcessImpl::Create();
     RenderThreadImpl::Create(std::move(main_message_loop),
                              std::move(main_thread_scheduler));
diff --git content/renderer/renderer_main_platform_delegate_linux.cc content/renderer/renderer_main_platform_delegate_linux.cc
index c3d7bd9e71..af73c0eb25 100644
--- content/renderer/renderer_main_platform_delegate_linux.cc
+++ content/renderer/renderer_main_platform_delegate_linux.cc
@@ -30,6 +30,7 @@ void RendererMainPlatformDelegate::PlatformUninitialize() {
 }
 
 bool RendererMainPlatformDelegate::EnableSandbox() {
+#if !defined(OS_BSD)
   // The setuid sandbox is started in the zygote process: zygote_main_linux.cc
   // https://chromium.googlesource.com/chromium/src/+/master/docs/linux_suid_sandbox.md
   //
@@ -65,7 +66,7 @@ bool RendererMainPlatformDelegate::EnableSandbox() {
     CHECK_EQ(errno, EPERM);
   }
 #endif  // __x86_64__
-
+#endif  // ! OS_BSD
   return true;
 }
 
diff --git content/renderer/webscrollbarbehavior_impl_aura.cc content/renderer/webscrollbarbehavior_impl_aura.cc
index c6c15715a9..1ff3e383af 100644
--- content/renderer/webscrollbarbehavior_impl_aura.cc
+++ content/renderer/webscrollbarbehavior_impl_aura.cc
@@ -14,7 +14,7 @@ bool WebScrollbarBehaviorImpl::ShouldCenterOnThumb(
     blink::WebPointerProperties::Button mouseButton,
     bool shiftKeyPressed,
     bool altKeyPressed) {
-#if (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   if (mouseButton == blink::WebPointerProperties::Button::kMiddle)
     return true;
 #endif
@@ -29,7 +29,7 @@ bool WebScrollbarBehaviorImpl::ShouldSnapBackToDragOrigin(
 // Disable snapback on desktop Linux to better integrate with the desktop
 // behavior.  Typically, Linux apps do not implement scrollbar snapback (this is
 // true for at least GTK and QT apps).
-#if (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   return false;
 #endif
 
diff --git content/shell/browser/shell_browser_context.cc content/shell/browser/shell_browser_context.cc
index 3281f7e6c8..0bf0ffeb20 100644
--- content/shell/browser/shell_browser_context.cc
+++ content/shell/browser/shell_browser_context.cc
@@ -26,7 +26,7 @@
 
 #if defined(OS_WIN)
 #include "base/base_paths_win.h"
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
 #include "base/nix/xdg_util.h"
 #elif defined(OS_MACOSX)
 #include "base/base_paths_mac.h"
@@ -114,7 +114,7 @@ void ShellBrowserContext::InitWhileIOAllowed() {
 #if defined(OS_WIN)
   CHECK(base::PathService::Get(base::DIR_LOCAL_APP_DATA, &path_));
   path_ = path_.Append(std::wstring(L"content_shell"));
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   std::unique_ptr<base::Environment> env(base::Environment::Create());
   base::FilePath config_dir(
       base::nix::GetXDGDirectory(env.get(),
diff --git content/shell/browser/shell_browser_main_parts.cc content/shell/browser/shell_browser_main_parts.cc
index 96337fd684..5729eae1d1 100644
--- content/shell/browser/shell_browser_main_parts.cc
+++ content/shell/browser/shell_browser_main_parts.cc
@@ -48,7 +48,7 @@
 #if defined(USE_AURA) && defined(USE_X11)
 #include "ui/events/devices/x11/touch_factory_x11.h"  // nogncheck
 #endif
-#if !defined(OS_CHROMEOS) && defined(USE_AURA) && defined(OS_LINUX)
+#if !defined(OS_CHROMEOS) && defined(USE_AURA) && (defined(OS_BSD) || defined(OS_LINUX))
 #include "ui/base/ime/input_method_initializer.h"
 #endif
 #if defined(OS_CHROMEOS)
@@ -132,7 +132,7 @@ int ShellBrowserMainParts::PreEarlyInitialization() {
 #if defined(USE_X11)
   ui::SetDefaultX11ErrorHandlers();
 #endif
-#if !defined(OS_CHROMEOS) && defined(USE_AURA) && defined(OS_LINUX)
+#if !defined(OS_CHROMEOS) && defined(USE_AURA) && (defined(OS_BSD) || defined(OS_LINUX))
   ui::InitializeInputMethodForTesting();
 #endif
 #if defined(OS_ANDROID)
diff --git content/test/content_test_suite.cc content/test/content_test_suite.cc
index 1b649e4dea..868030e259 100644
--- content/test/content_test_suite.cc
+++ content/test/content_test_suite.cc
@@ -86,6 +86,7 @@ void ContentTestSuite::Initialize() {
   // to initialize GL, so don't do it here.
   base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
   bool is_child_process = command_line->HasSwitch(switches::kTestChildProcess);
+#if !defined(OS_BSD)
   if (!is_child_process) {
     gl::GLSurfaceTestSupport::InitializeNoExtensionsOneOff();
     gpu::GPUInfo gpu_info;
@@ -102,6 +103,7 @@ void ContentTestSuite::Initialize() {
         gpu_feature_info.disabled_extensions);
     gl::init::InitializeExtensionSettingsOneOffPlatform();
   }
+#endif
   testing::TestEventListeners& listeners =
       testing::UnitTest::GetInstance()->listeners();
   listeners.Append(new TestInitializationListener);
diff --git content/utility/utility_main.cc content/utility/utility_main.cc
index 890477a27d..2bbe0182cd 100644
--- content/utility/utility_main.cc
+++ content/utility/utility_main.cc
@@ -46,7 +46,7 @@ int UtilityMain(const MainFunctionParams& parameters) {
   if (parameters.command_line.HasSwitch(switches::kUtilityStartupDialog))
     WaitForDebugger("Utility");
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) && !defined(OS_BSD)
   // Initializes the sandbox before any threads are created.
   // TODO(jorgelo): move this after GTK initialization when we enable a strict
   // Seccomp-BPF policy.
diff --git device/bluetooth/BUILD.gn device/bluetooth/BUILD.gn
index 56b36d7894..6240aeab4f 100644
--- device/bluetooth/BUILD.gn
+++ device/bluetooth/BUILD.gn
@@ -253,7 +253,7 @@ component("bluetooth") {
     ]
   }
 
-  if (is_chromeos || is_linux) {
+  if (is_chromeos || (is_linux && !is_bsd)) {
     if (use_dbus) {
       sources += [
         "bluez/bluetooth_adapter_bluez.cc",
diff --git device/gamepad/gamepad_provider.cc device/gamepad/gamepad_provider.cc
index f2d844f884..73f526a465 100644
--- device/gamepad/gamepad_provider.cc
+++ device/gamepad/gamepad_provider.cc
@@ -190,7 +190,7 @@ void GamepadProvider::Initialize(std::unique_ptr<GamepadDataFetcher> fetcher) {
     monitor->AddDevicesChangedObserver(this);
 
   polling_thread_.reset(new base::Thread("Gamepad polling thread"));
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // On Linux, the data fetcher needs to watch file descriptors, so the message
   // loop needs to be a libevent loop.
   const base::MessageLoop::Type kMessageLoopType = base::MessageLoop::TYPE_IO;
diff --git device/geolocation/location_arbitrator.cc device/geolocation/location_arbitrator.cc
index 61370c6f81..972dd47359 100644
--- device/geolocation/location_arbitrator.cc
+++ device/geolocation/location_arbitrator.cc
@@ -177,7 +177,7 @@ LocationArbitrator::NewNetworkLocationProvider(
 std::unique_ptr<LocationProvider>
 LocationArbitrator::NewSystemLocationProvider() {
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_BSD)
   return nullptr;
 #else
   return device::NewSystemLocationProvider();
diff --git device/serial/BUILD.gn device/serial/BUILD.gn
index 77132bfc86..c19d29db5f 100644
--- device/serial/BUILD.gn
+++ device/serial/BUILD.gn
@@ -6,7 +6,7 @@ import("//build/config/features.gni")
 import("//mojo/public/tools/bindings/mojom.gni")
 
 # Library works only on desktop platforms.
-if (is_win || is_linux || is_mac) {
+if (is_win || is_linux || is_mac || is_bsd) {
   config("platform_support") {
     visibility = [ ":serial" ]
     if (is_win) {
@@ -56,6 +56,13 @@ if (is_win || is_linux || is_mac) {
       "//third_party/re2",
     ]
 
+    if (is_bsd) {
+      sources -= [
+        "serial_device_enumerator_linux.cc",
+        "serial_device_enumerator_linux.h",
+      ]
+    }
+
     if (is_posix) {
       sources += [
         "serial_io_handler_posix.cc",
diff --git device/serial/serial_io_handler_posix.cc device/serial/serial_io_handler_posix.cc
index d6ed5e1f88..4b217ab3ba 100644
--- device/serial/serial_io_handler_posix.cc
+++ device/serial/serial_io_handler_posix.cc
@@ -62,7 +62,7 @@ bool BitrateToSpeedConstant(int bitrate, speed_t* speed) {
     BITRATE_TO_SPEED_CASE(9600)
     BITRATE_TO_SPEED_CASE(19200)
     BITRATE_TO_SPEED_CASE(38400)
-#if !defined(OS_MACOSX)
+#if !defined(OS_MACOSX) && !defined(OS_BSD)
     BITRATE_TO_SPEED_CASE(57600)
     BITRATE_TO_SPEED_CASE(115200)
     BITRATE_TO_SPEED_CASE(230400)
diff --git device/usb/BUILD.gn device/usb/BUILD.gn
index 5b183fcc4c..7f00b62f2f 100644
--- device/usb/BUILD.gn
+++ device/usb/BUILD.gn
@@ -109,13 +109,20 @@ static_library("usb") {
     ]
   }
 
-  if (is_android || is_chromeos || is_linux) {
+  if (is_android || is_chromeos || (is_linux && !is_bsd)) {
     sources += [
       "usb_device_handle_usbfs.cc",
       "usb_device_handle_usbfs.h",
     ]
   }
 
+  if (is_bsd) {
+    sources -= [
+      "usb_device_linux.cc",
+      "usb_device_linux.h",
+    ]
+  }
+
   if (is_chromeos) {
     deps += [
       "//chromeos",
diff --git device/usb/usb_context.cc device/usb/usb_context.cc
index 6959fab01d..60e4bfb003 100644
--- device/usb/usb_context.cc
+++ device/usb/usb_context.cc
@@ -58,7 +58,9 @@ void UsbContext::UsbEventHandler::Run() {
 
 void UsbContext::UsbEventHandler::Stop() {
   base::subtle::Release_Store(&running_, 0);
+#if !defined(OS_FREEBSD) // XXX(rene) not available in base version
   libusb_interrupt_handle_event(context_);
+#endif
 }
 
 UsbContext::UsbContext(PlatformUsbContext context) : context_(context) {
diff --git device/usb/usb_error.cc device/usb/usb_error.cc
index 9fadb162ed..20d610dc14 100644
--- device/usb/usb_error.cc
+++ device/usb/usb_error.cc
@@ -9,7 +9,7 @@
 namespace device {
 
 std::string ConvertPlatformUsbErrorToString(int errcode) {
-  return libusb_strerror(static_cast<libusb_error>(errcode));
+  return "";
 }
 
 }  // namespace device
diff --git device/usb/usb_service_impl.cc device/usb/usb_service_impl.cc
index 83e14c6f0c..697c7c3284 100644
--- device/usb/usb_service_impl.cc
+++ device/usb/usb_service_impl.cc
@@ -239,8 +239,10 @@ UsbServiceImpl::UsbServiceImpl()
 }
 
 UsbServiceImpl::~UsbServiceImpl() {
+#if !defined(OS_FREEBSD)
   if (hotplug_enabled_)
     libusb_hotplug_deregister_callback(context_->context(), hotplug_handle_);
+#endif // !defined(OS_FREEBSD)
 }
 
 void UsbServiceImpl::GetDevices(const GetDevicesCallback& callback) {
@@ -295,6 +297,7 @@ void UsbServiceImpl::OnUsbContext(scoped_refptr<UsbContext> context) {
 
   context_ = std::move(context);
 
+#if !defined(OS_FREEBSD)
   int rv = libusb_hotplug_register_callback(
       context_->context(),
       static_cast<libusb_hotplug_event>(LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED |
@@ -307,6 +310,7 @@ void UsbServiceImpl::OnUsbContext(scoped_refptr<UsbContext> context) {
 
   // This will call any enumeration callbacks queued while initializing.
   RefreshDevices();
+#endif // !defined(OS_FREEBSD)
 
 #if defined(OS_WIN)
   DeviceMonitorWin* device_monitor = DeviceMonitorWin::GetForAllInterfaces();
@@ -503,6 +507,7 @@ void UsbServiceImpl::RemoveDevice(scoped_refptr<UsbDeviceImpl> device) {
   device->OnDisconnect();
 }
 
+#if !defined(OS_FREEBSD)
 // static
 int LIBUSB_CALL UsbServiceImpl::HotplugCallback(libusb_context* context,
                                                 libusb_device* device_raw,
@@ -537,6 +542,7 @@ int LIBUSB_CALL UsbServiceImpl::HotplugCallback(libusb_context* context,
 
   return 0;
 }
+#endif // !defined(OS_FREEBSD)
 
 void UsbServiceImpl::OnPlatformDeviceAdded(
     ScopedLibusbDeviceRef platform_device) {
diff --git device/usb/usb_service_impl.h device/usb/usb_service_impl.h
index e7e89d0f54..126349ca8c 100644
--- device/usb/usb_service_impl.h
+++ device/usb/usb_service_impl.h
@@ -73,11 +73,13 @@ class UsbServiceImpl :
                  scoped_refptr<UsbDeviceImpl> device);
   void RemoveDevice(scoped_refptr<UsbDeviceImpl> device);
 
+#if !defined(OS_FREEBSD)
   // Handle hotplug events from libusb.
   static int LIBUSB_CALL HotplugCallback(libusb_context* context,
                                          libusb_device* device,
                                          libusb_hotplug_event event,
                                          void* user_data);
+#endif
   // These functions release a reference to the provided platform device.
   void OnPlatformDeviceAdded(ScopedLibusbDeviceRef platform_device);
   void OnPlatformDeviceRemoved(ScopedLibusbDeviceRef platform_device);
@@ -95,7 +97,9 @@ class UsbServiceImpl :
   // connected instead of only when a full enumeration is requested.
   // TODO(reillyg): Support this on all platforms. crbug.com/411715
   bool hotplug_enabled_ = false;
+#if !defined(OS_FREEBSD)
   libusb_hotplug_callback_handle hotplug_handle_;
+#endif
 
   // Enumeration callbacks are queued until an enumeration completes.
   bool enumeration_ready_ = false;
diff --git dfly/genpatches dfly/genpatches
new file mode 100755
index 0000000000..e52272ee5b
--- /dev/null
+++ dfly/genpatches
@@ -0,0 +1,7 @@
+#!/bin/csh
+#
+
+set nonomatch
+rm -f /usr/dports/www/chromium68/files/patch-*
+git diff --no-prefix crater/chromium-68.0.3440.106 . > /usr/dports/www/chromium68/files/patch-all
+
diff --git dfly/repatch dfly/repatch
new file mode 100755
index 0000000000..e2c4a9f1a6
--- /dev/null
+++ dfly/repatch
@@ -0,0 +1,12 @@
+#! /bin/sh
+
+OBJDIR=/usr/obj/dports/www/chromium68/chromium-68.0.3440.106/
+
+for f in $(git ls-files -m)
+do
+    if diff -q $f $OBJDIR/$f >/dev/null; then
+	echo $f does not need repatch
+    else
+	cp -fv $f $OBJDIR/$f
+    fi
+done
diff --git extensions/browser/api/declarative_webrequest/webrequest_action.cc extensions/browser/api/declarative_webrequest/webrequest_action.cc
index b6957e49d9..d718f2531b 100644
--- extensions/browser/api/declarative_webrequest/webrequest_action.cc
+++ extensions/browser/api/declarative_webrequest/webrequest_action.cc
@@ -28,7 +28,11 @@
 #include "extensions/common/extension.h"
 #include "net/base/registry_controlled_domains/registry_controlled_domain.h"
 #include "net/http/http_util.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 
 using content::ResourceRequestInfo;
 
diff --git extensions/browser/api/messaging/message_service.cc extensions/browser/api/messaging/message_service.cc
index 3d39acbf3a..b49a6b8bea 100644
--- extensions/browser/api/messaging/message_service.cc
+++ extensions/browser/api/messaging/message_service.cc
@@ -58,7 +58,7 @@ namespace extensions {
 
 const char kReceivingEndDoesntExistError[] =
     "Could not establish connection. Receiving end does not exist.";
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
 const char kMissingPermissionError[] =
     "Access to native messaging requires nativeMessaging permission.";
 const char kProhibitedByPoliciesError[] =
@@ -329,7 +329,7 @@ void MessageService::OpenChannelToNativeApp(
   if (!source)
     return;
 
-#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_BSD)
   content::WebContents* web_contents =
       content::WebContents::FromRenderFrameHost(source);
   ExtensionWebContentsObserver* extension_web_contents_observer =
diff --git extensions/browser/api/networking_private/networking_private_delegate_factory.cc extensions/browser/api/networking_private/networking_private_delegate_factory.cc
index c535981d18..706d4de4b9 100644
--- extensions/browser/api/networking_private/networking_private_delegate_factory.cc
+++ extensions/browser/api/networking_private/networking_private_delegate_factory.cc
@@ -11,7 +11,7 @@
 
 #if defined(OS_CHROMEOS)
 #include "extensions/browser/api/networking_private/networking_private_chromeos.h"
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
 #include "extensions/browser/api/networking_private/networking_private_linux.h"
 #elif defined(OS_WIN) || defined(OS_MACOSX)
 #include "components/wifi/wifi_service.h"
@@ -61,7 +61,7 @@ KeyedService* NetworkingPrivateDelegateFactory::BuildServiceInstanceFor(
   NetworkingPrivateDelegate* delegate;
 #if defined(OS_CHROMEOS)
   delegate = new NetworkingPrivateChromeOS(browser_context);
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   delegate = new NetworkingPrivateLinux();
 #elif defined(OS_WIN) || defined(OS_MACOSX)
   std::unique_ptr<wifi::WiFiService> wifi_service(wifi::WiFiService::Create());
diff --git extensions/browser/api/networking_private/networking_private_event_router_factory.cc extensions/browser/api/networking_private/networking_private_event_router_factory.cc
index 0ca9caeec7..75166b0759 100644
--- extensions/browser/api/networking_private/networking_private_event_router_factory.cc
+++ extensions/browser/api/networking_private/networking_private_event_router_factory.cc
@@ -13,6 +13,7 @@
 
 namespace extensions {
 
+#if !defined(OS_BSD)
 // static
 NetworkingPrivateEventRouter*
 NetworkingPrivateEventRouterFactory::GetForProfile(
@@ -57,5 +58,6 @@ bool NetworkingPrivateEventRouterFactory::ServiceIsCreatedWithBrowserContext()
 bool NetworkingPrivateEventRouterFactory::ServiceIsNULLWhileTesting() const {
   return true;
 }
+#endif
 
 }  // namespace extensions
diff --git extensions/browser/api/web_request/form_data_parser.cc extensions/browser/api/web_request/form_data_parser.cc
index aba2b4a6a1..0c9bf3d7ad 100644
--- extensions/browser/api/web_request/form_data_parser.cc
+++ extensions/browser/api/web_request/form_data_parser.cc
@@ -15,7 +15,11 @@
 #include "base/values.h"
 #include "net/base/escape.h"
 #include "net/http/http_request_headers.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 
 using base::DictionaryValue;
 using base::ListValue;
diff --git extensions/common/api/_permission_features.json extensions/common/api/_permission_features.json
index ac188fe8a2..b0a1d14bfe 100644
--- extensions/common/api/_permission_features.json
+++ extensions/common/api/_permission_features.json
@@ -126,7 +126,7 @@
   "bluetoothPrivate": {
     "channel": "stable",
     "extension_types": ["platform_app"],
-    "platforms": ["chromeos", "win", "mac", "linux"],
+    "platforms": ["chromeos", "win", "mac", "linux", "bsd"],
     "whitelist": [
       "1C93BD3CF875F4A73C0B2A163BB8FBDA8B8B3D80",  // http://crbug.com/387169
       "A3BC37E2148AC4E99BE4B16AF9D42DD1E592BBBE",  // http://crbug.com/387169
@@ -443,7 +443,7 @@
   }, {
     "channel": "stable",
     "extension_types": ["extension", "legacy_packaged_app", "platform_app"],
-    "platforms": ["chromeos", "mac", "win", "linux"],
+    "platforms": ["chromeos", "mac", "win", "linux", "bsd"],
     "whitelist": [
       "0DE0F05680A4A056BCEC864ED8DDA84296F82B40",  // http://crbug.com/434651
       "1C93BD3CF875F4A73C0B2A163BB8FBDA8B8B3D80",  // http://crbug.com/293683
@@ -474,7 +474,7 @@
   "networkingPrivate": {
     "channel": "stable",
     "extension_types": ["extension", "legacy_packaged_app", "platform_app"],
-    "platforms": ["chromeos", "mac", "win", "linux"],
+    "platforms": ["chromeos", "mac", "win", "linux", "bsd"],
     "whitelist": [
       // DO NOT ADD ANY MORE ENTRIES HERE.
       // networkingPrivate is being migrated to networking.onc.
diff --git extensions/common/api/runtime.json extensions/common/api/runtime.json
index ec5b97f7a5..d4eac85e88 100644
--- extensions/common/api/runtime.json
+++ extensions/common/api/runtime.json
@@ -66,7 +66,7 @@
         "id": "PlatformOs",
         "type": "string",
         "description": "The operating system chrome is running on.",
-        "enum": ["mac", "win", "android", "cros", "linux", "openbsd"]
+        "enum": ["mac", "win", "android", "cros", "linux", "freebsd", "openbsd"]
       },
       {
         "id": "PlatformArch",
diff --git extensions/common/feature_switch.cc extensions/common/feature_switch.cc
index 20b2d99a80..137cef0128 100644
--- extensions/common/feature_switch.cc
+++ extensions/common/feature_switch.cc
@@ -44,11 +44,7 @@ class CommonSwitches {
                          FeatureSwitch::DEFAULT_ENABLED),
         load_media_router_component_extension(
             kLoadMediaRouterComponentExtensionFlag,
-#if defined(GOOGLE_CHROME_BUILD)
             FeatureSwitch::DEFAULT_ENABLED)
-#else
-            FeatureSwitch::DEFAULT_DISABLED)
-#endif  // defined(GOOGLE_CHROME_BUILD)
   {
   }
 
diff --git extensions/common/features/feature.cc extensions/common/features/feature.cc
index 29c05a6dd5..dc44bc13e6 100644
--- extensions/common/features/feature.cc
+++ extensions/common/features/feature.cc
@@ -26,6 +26,8 @@ Feature::Platform Feature::GetCurrentPlatform() {
   return MACOSX_PLATFORM;
 #elif defined(OS_WIN)
   return WIN_PLATFORM;
+#elif defined(OS_BSD)
+  return LINUX_PLATFORM;
 #else
   return UNSPECIFIED_PLATFORM;
 #endif
diff --git extensions/common/image_util.cc extensions/common/image_util.cc
index 10f41a569e..6831fa6ab9 100644
--- extensions/common/image_util.cc
+++ extensions/common/image_util.cc
@@ -11,7 +11,11 @@
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/string_util.h"
 #include "base/strings/stringprintf.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 #include "third_party/skia/include/core/SkColor.h"
 #include "third_party/skia/include/utils/SkParse.h"
 #include "ui/gfx/color_utils.h"
diff --git extensions/common/stack_frame.cc extensions/common/stack_frame.cc
index 497edac45e..8dd7743f5a 100644
--- extensions/common/stack_frame.cc
+++ extensions/common/stack_frame.cc
@@ -7,7 +7,11 @@
 #include <string>
 
 #include "base/strings/utf_string_conversions.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 
 namespace extensions {
 
diff --git gpu/command_buffer/service/program_manager.cc gpu/command_buffer/service/program_manager.cc
index de1122dc98..e456e7aede 100644
--- gpu/command_buffer/service/program_manager.cc
+++ gpu/command_buffer/service/program_manager.cc
@@ -31,7 +31,11 @@
 #include "gpu/command_buffer/service/program_cache.h"
 #include "gpu/command_buffer/service/progress_reporter.h"
 #include "gpu/command_buffer/service/shader_manager.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 #include "ui/gl/gl_version_info.h"
 
 using base::TimeDelta;
diff --git gpu/config/gpu_control_list.cc gpu/config/gpu_control_list.cc
index c870ca4581..ed085a8b7e 100644
--- gpu/config/gpu_control_list.cc
+++ gpu/config/gpu_control_list.cc
@@ -16,7 +16,11 @@
 #include "base/values.h"
 #include "build/build_config.h"
 #include "gpu/config/gpu_info.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 
 namespace gpu {
 namespace {
@@ -213,7 +217,7 @@ bool GpuControlList::More::GLVersionInfoMismatch(
 GpuControlList::GLType GpuControlList::More::GetDefaultGLType() {
 #if defined(OS_CHROMEOS)
   return kGLTypeGL;
-#elif defined(OS_LINUX) || defined(OS_OPENBSD)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   return kGLTypeGL;
 #elif defined(OS_MACOSX)
   return kGLTypeGL;
@@ -679,7 +683,7 @@ GpuControlList::OsType GpuControlList::GetOsType() {
   return kOsAndroid;
 #elif defined(OS_FUCHSIA)
   return kOsFuchsia;
-#elif defined(OS_LINUX) || defined(OS_OPENBSD)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   return kOsLinux;
 #elif defined(OS_MACOSX)
   return kOsMacosx;
diff --git gpu/config/gpu_test_config.cc gpu/config/gpu_test_config.cc
index 6d4fd89423..1f82c95948 100644
--- gpu/config/gpu_test_config.cc
+++ gpu/config/gpu_test_config.cc
@@ -25,7 +25,7 @@ namespace {
 GPUTestConfig::OS GetCurrentOS() {
 #if defined(OS_CHROMEOS)
   return GPUTestConfig::kOsChromeOS;
-#elif defined(OS_LINUX) || defined(OS_OPENBSD)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   return GPUTestConfig::kOsLinux;
 #elif defined(OS_WIN)
   int32_t major_version = 0;
diff --git gpu/ipc/common/gpu_memory_buffer_support.cc gpu/ipc/common/gpu_memory_buffer_support.cc
index 3f5850d311..04d28faeca 100644
--- gpu/ipc/common/gpu_memory_buffer_support.cc
+++ gpu/ipc/common/gpu_memory_buffer_support.cc
@@ -12,7 +12,7 @@
 #include "gpu/ipc/common/gpu_memory_buffer_impl_io_surface.h"
 #endif
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include "gpu/ipc/common/gpu_memory_buffer_impl_native_pixmap.h"
 #include "ui/gfx/client_native_pixmap_factory.h"
 #include "ui/gfx/linux/client_native_pixmap_factory_dmabuf.h"
@@ -36,13 +36,13 @@ namespace gpu {
 GpuMemoryBufferSupport::GpuMemoryBufferSupport() {
 #if defined(USE_OZONE)
   client_native_pixmap_factory_ = ui::CreateClientNativePixmapFactoryOzone();
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   client_native_pixmap_factory_.reset(
       gfx::CreateClientNativePixmapFactoryDmabuf());
 #endif
 }
 
-#if defined(OS_LINUX) || defined(USE_OZONE)
+#if defined(OS_LINUX) || defined(USE_OZONE) || defined(OS_BSD)
 GpuMemoryBufferSupport::GpuMemoryBufferSupport(
     std::unique_ptr<gfx::ClientNativePixmapFactory>
         client_native_pixmap_factory)
@@ -57,7 +57,7 @@ GpuMemoryBufferSupport::GetNativeGpuMemoryBufferType() {
   return gfx::IO_SURFACE_BUFFER;
 #elif defined(OS_ANDROID)
   return gfx::ANDROID_HARDWARE_BUFFER;
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   return gfx::NATIVE_PIXMAP;
 #elif defined(OS_WIN)
   return gfx::DXGI_SHARED_HANDLE;
@@ -114,7 +114,7 @@ bool GpuMemoryBufferSupport::IsNativeGpuMemoryBufferConfigurationSupported(
   return false;
 #elif defined(USE_OZONE)
   return client_native_pixmap_factory_->IsConfigurationSupported(format, usage);
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   return false;  // TODO(julian.isorce): Add linux support.
 #elif defined(OS_WIN)
   switch (usage) {
@@ -171,7 +171,7 @@ GpuMemoryBufferSupport::CreateGpuMemoryBufferImplFromHandle(
       return GpuMemoryBufferImplIOSurface::CreateFromHandle(
           handle, size, format, usage, callback);
 #endif
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     case gfx::NATIVE_PIXMAP:
       return GpuMemoryBufferImplNativePixmap::CreateFromHandle(
           client_native_pixmap_factory(), handle, size, format, usage,
diff --git gpu/ipc/common/gpu_memory_buffer_support.h gpu/ipc/common/gpu_memory_buffer_support.h
index 885208bc90..ec20a94a15 100644
--- gpu/ipc/common/gpu_memory_buffer_support.h
+++ gpu/ipc/common/gpu_memory_buffer_support.h
@@ -17,7 +17,7 @@
 #include "ui/gfx/geometry/size.h"
 #include "ui/gfx/gpu_memory_buffer.h"
 
-#if defined(OS_LINUX) || defined(USE_OZONE)
+#if defined(OS_LINUX) || defined(OS_BSD) || defined(USE_OZONE)
 namespace gfx {
 class ClientNativePixmapFactory;
 }
@@ -29,7 +29,7 @@ namespace gpu {
 class GPU_EXPORT GpuMemoryBufferSupport {
  public:
   GpuMemoryBufferSupport();
-#if defined(OS_LINUX) || defined(USE_OZONE)
+#if defined(OS_LINUX) || defined(OS_BSD) || defined(USE_OZONE)
   GpuMemoryBufferSupport(std::unique_ptr<gfx::ClientNativePixmapFactory>
                              client_native_pixmap_factory);
 #endif
@@ -43,7 +43,7 @@ class GPU_EXPORT GpuMemoryBufferSupport {
   bool IsNativeGpuMemoryBufferConfigurationSupported(gfx::BufferFormat format,
                                                      gfx::BufferUsage usage);
 
-#if defined(OS_LINUX) || defined(USE_OZONE)
+#if defined(OS_LINUX) || defined(OS_BSD) || defined(USE_OZONE)
   gfx::ClientNativePixmapFactory* client_native_pixmap_factory() {
     return client_native_pixmap_factory_.get();
   }
@@ -66,7 +66,7 @@ class GPU_EXPORT GpuMemoryBufferSupport {
       const GpuMemoryBufferImpl::DestructionCallback& callback);
 
  private:
-#if defined(OS_LINUX) || defined(USE_OZONE)
+#if defined(OS_LINUX) || defined(OS_BSD) || defined(USE_OZONE)
   std::unique_ptr<gfx::ClientNativePixmapFactory> client_native_pixmap_factory_;
 #endif
 
diff --git gpu/ipc/service/gpu_init.cc gpu/ipc/service/gpu_init.cc
index 63a5d345d2..d6347124b3 100644
--- gpu/ipc/service/gpu_init.cc
+++ gpu/ipc/service/gpu_init.cc
@@ -69,7 +69,7 @@ bool CollectGraphicsInfo(GPUInfo* gpu_info) {
 }
 #endif  // defined(OS_MACOSX)
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(IS_CHROMECAST)
+#if defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(IS_CHROMECAST) && !defined(OS_BSD)
 bool CanAccessNvidiaDeviceFile() {
   bool res = true;
   base::AssertBlockingAllowed();
@@ -105,7 +105,7 @@ bool GpuInit::InitializeAndStartSandbox(base::CommandLine* command_line,
   // crash during feature collection.
   gpu::SetKeysForCrashLogging(gpu_info_);
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(OS_BSD)
   if (gpu_info_.gpu.vendor_id == 0x10de &&  // NVIDIA
       gpu_info_.driver_vendor == "NVIDIA" && !CanAccessNvidiaDeviceFile())
     return false;
@@ -177,7 +177,7 @@ bool GpuInit::InitializeAndStartSandbox(base::CommandLine* command_line,
   sandbox_helper_->PreSandboxStartup();
 
   bool attempted_startsandbox = false;
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) && !defined(OS_BSD)
   // On Chrome OS ARM Mali, GPU driver userspace creates threads when
   // initializing a GL context, so start the sandbox early.
   // TODO(zmo): Need to collect OS version before this.
diff --git gpu/ipc/service/gpu_memory_buffer_factory.cc gpu/ipc/service/gpu_memory_buffer_factory.cc
index 5a70a0221a..c2e43bafc7 100644
--- gpu/ipc/service/gpu_memory_buffer_factory.cc
+++ gpu/ipc/service/gpu_memory_buffer_factory.cc
@@ -12,7 +12,7 @@
 #include "gpu/ipc/service/gpu_memory_buffer_factory_io_surface.h"
 #endif
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include "gpu/ipc/service/gpu_memory_buffer_factory_native_pixmap.h"
 #endif
 
@@ -33,7 +33,7 @@ GpuMemoryBufferFactory::CreateNativeType() {
   return base::WrapUnique(new GpuMemoryBufferFactoryIOSurface);
 #elif defined(OS_ANDROID)
   return base::WrapUnique(new GpuMemoryBufferFactoryAndroidHardwareBuffer);
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   return base::WrapUnique(new GpuMemoryBufferFactoryNativePixmap);
 #elif defined(OS_WIN)
   return base::WrapUnique(new GpuMemoryBufferFactoryDXGI);
diff --git headless/lib/browser/headless_content_browser_client.cc headless/lib/browser/headless_content_browser_client.cc
index 08411303c9..fa68623d68 100644
--- headless/lib/browser/headless_content_browser_client.cc
+++ headless/lib/browser/headless_content_browser_client.cc
@@ -204,7 +204,7 @@ void HeadlessContentBrowserClient::GetQuotaSettings(
       partition->GetPath(), context->IsOffTheRecord(), std::move(callback));
 }
 
-#if defined(OS_POSIX) && !defined(OS_MACOSX)
+#if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_BSD)
 void HeadlessContentBrowserClient::GetAdditionalMappedFilesForChildProcess(
     const base::CommandLine& command_line,
     int child_process_id,
@@ -215,7 +215,7 @@ void HeadlessContentBrowserClient::GetAdditionalMappedFilesForChildProcess(
     mappings->Share(service_manager::kCrashDumpSignal, crash_signal_fd);
 #endif  // defined(HEADLESS_USE_BREAKPAD)
 }
-#endif  // defined(OS_POSIX) && !defined(OS_MACOSX)
+#endif  // defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_BSD)
 
 void HeadlessContentBrowserClient::AppendExtraCommandLineSwitches(
     base::CommandLine* command_line,
diff --git headless/lib/browser/headless_content_browser_client.h headless/lib/browser/headless_content_browser_client.h
index 6980a87948..0d3c80f230 100644
--- headless/lib/browser/headless_content_browser_client.h
+++ headless/lib/browser/headless_content_browser_client.h
@@ -32,7 +32,7 @@ class HeadlessContentBrowserClient : public content::ContentBrowserClient {
       content::BrowserContext* context,
       content::StoragePartition* partition,
       storage::OptionalQuotaSettingsCallback callback) override;
-#if defined(OS_POSIX) && !defined(OS_MACOSX)
+#if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_BSD)
   void GetAdditionalMappedFilesForChildProcess(
       const base::CommandLine& command_line,
       int child_process_id,
diff --git headless/lib/headless_macros.h headless/lib/headless_macros.h
index f0dea81eb1..2056eb6d75 100644
--- headless/lib/headless_macros.h
+++ headless/lib/headless_macros.h
@@ -7,8 +7,8 @@
 
 #include "build/build_config.h"
 
-#if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_FUCHSIA)
+#if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_FUCHSIA) && !defined(OS_BSD)
 #define HEADLESS_USE_BREAKPAD
-#endif  // defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_FUCHSIA)
+#endif  // defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_FUCHSIA) && !defined(OS_BSD)
 
 #endif  // HEADLESS_LIB_HEADLESS_MACROS_H_
diff --git ipc/ipc_channel.h ipc/ipc_channel.h
index 5b0221cb57..5928dfc1fd 100644
--- ipc/ipc_channel.h
+++ ipc/ipc_channel.h
@@ -244,7 +244,7 @@ class COMPONENT_EXPORT(IPC) Channel : public Sender {
   static std::string GenerateUniqueRandomChannelID();
 #endif
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // Sandboxed processes live in a PID namespace, so when sending the IPC hello
   // message from client to server we need to send the PID from the global
   // PID namespace.
diff --git ipc/ipc_channel_common.cc ipc/ipc_channel_common.cc
index 7afb12d9b0..2d63094073 100644
--- ipc/ipc_channel_common.cc
+++ ipc/ipc_channel_common.cc
@@ -9,7 +9,7 @@
 
 namespace IPC {
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 
 namespace {
 int g_global_pid = 0;
diff --git ipc/ipc_channel_mojo.cc ipc/ipc_channel_mojo.cc
index cb10b0915b..1458c9915b 100644
--- ipc/ipc_channel_mojo.cc
+++ ipc/ipc_channel_mojo.cc
@@ -64,7 +64,7 @@ class MojoChannelFactory : public ChannelFactory {
 };
 
 base::ProcessId GetSelfPID() {
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   if (int global_pid = Channel::GetGlobalPid())
     return global_pid;
 #endif  // OS_LINUX
diff --git ipc/ipc_message_utils.cc ipc/ipc_message_utils.cc
index 5618b5c81f..0f73b4a1bf 100644
--- ipc/ipc_message_utils.cc
+++ ipc/ipc_message_utils.cc
@@ -349,7 +349,7 @@ void ParamTraits<unsigned int>::Log(const param_type& p, std::string* l) {
 }
 
 #if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_FUCHSIA) || \
-    (defined(OS_ANDROID) && defined(ARCH_CPU_64_BITS))
+    defined(OS_BSD) || (defined(OS_ANDROID) && defined(ARCH_CPU_64_BITS))
 void ParamTraits<long>::Log(const param_type& p, std::string* l) {
   l->append(base::NumberToString(p));
 }
diff --git ipc/ipc_message_utils.h ipc/ipc_message_utils.h
index 0dbf500e2f..920e78937c 100644
--- ipc/ipc_message_utils.h
+++ ipc/ipc_message_utils.h
@@ -204,7 +204,7 @@ struct ParamTraits<unsigned int> {
 // Since we want to support Android 32<>64 bit IPC, as long as we don't have
 // these traits for 32 bit ARM then that'll catch any errors.
 #if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_FUCHSIA) || \
-    (defined(OS_ANDROID) && defined(ARCH_CPU_64_BITS))
+    defined(OS_BSD) || (defined(OS_ANDROID) && defined(ARCH_CPU_64_BITS))
 template <>
 struct ParamTraits<long> {
   typedef long param_type;
diff --git media/BUILD.gn media/BUILD.gn
index e4debbaa0e..210b0c3d15 100644
--- media/BUILD.gn
+++ media/BUILD.gn
@@ -58,6 +58,9 @@ config("media_config") {
       defines += [ "DLOPEN_PULSEAUDIO" ]
     }
   }
+  if (use_sndio) {
+    defines += [ "USE_SNDIO" ]
+  }
   if (use_cras) {
     defines += [ "USE_CRAS" ]
   }
diff --git media/audio/BUILD.gn media/audio/BUILD.gn
index 8754161b0c..e8164d6cb3 100644
--- media/audio/BUILD.gn
+++ media/audio/BUILD.gn
@@ -254,9 +254,19 @@ source_set("audio") {
     deps += [ "//media/base/android:media_jni_headers" ]
   }
 
-  if (is_linux) {
+  if (is_linux && !use_sndio) {
     sources += [ "linux/audio_manager_linux.cc" ]
   }
+  if (use_sndio) {
+    libs += [ "sndio" ]
+    sources += [
+      "openbsd/audio_manager_openbsd.cc",
+      "sndio/sndio_input.cc",
+      "sndio/sndio_input.h",
+      "sndio/sndio_output.cc",
+      "sndio/sndio_output.h"
+    ]
+  }
 
   if (use_alsa) {
     libs += [ "asound" ]
@@ -302,7 +312,6 @@ source_set("audio") {
     if (link_pulseaudio) {
       configs += [ ":libpulse" ]
     } else {
-      libs += [ "dl" ]
       deps += [ ":pulse_generate_stubs" ]
       sources += get_target_outputs(":pulse_generate_stubs")
     }
diff --git media/audio/alsa/audio_manager_alsa.cc media/audio/alsa/audio_manager_alsa.cc
index 91108f0f92..72b2511bd0 100644
--- media/audio/alsa/audio_manager_alsa.cc
+++ media/audio/alsa/audio_manager_alsa.cc
@@ -93,7 +93,9 @@ void AudioManagerAlsa::GetAlsaAudioDevices(StreamType type,
   int card = -1;
 
   // Loop through the sound cards to get ALSA device hints.
+#ifdef OS_LINUX
   while (!wrapper_->CardNext(&card) && card >= 0) {
+#endif
     void** hints = NULL;
     int error = wrapper_->DeviceNameHint(card, kPcmInterfaceName, &hints);
     if (!error) {
@@ -105,7 +107,9 @@ void AudioManagerAlsa::GetAlsaAudioDevices(StreamType type,
       DLOG(WARNING) << "GetAlsaAudioDevices: unable to get device hints: "
                     << wrapper_->StrError(error);
     }
+#ifdef OS_LINUX
   }
+#endif
 }
 
 void AudioManagerAlsa::GetAlsaDevicesInfo(AudioManagerAlsa::StreamType type,
@@ -188,7 +192,11 @@ bool AudioManagerAlsa::IsAlsaDeviceAvailable(
   // goes through software conversion if needed (e.g. incompatible
   // sample rate).
   // TODO(joi): Should we prefer "hw" instead?
+#ifdef OS_LINUX
   static const char kDeviceTypeDesired[] = "plughw";
+#else
+  static const char kDeviceTypeDesired[] = "plug";
+#endif
   return strncmp(kDeviceTypeDesired, device_name,
                  arraysize(kDeviceTypeDesired) - 1) == 0;
 }
@@ -210,7 +218,9 @@ bool AudioManagerAlsa::HasAnyAlsaAudioDevice(
   // Loop through the sound cards.
   // Don't use snd_device_name_hint(-1,..) since there is a access violation
   // inside this ALSA API with libasound.so.2.0.0.
+#ifdef OS_LINUX
   while (!wrapper_->CardNext(&card) && (card >= 0) && !has_device) {
+#endif
     int error = wrapper_->DeviceNameHint(card, kPcmInterfaceName, &hints);
     if (!error) {
       for (void** hint_iter = hints; *hint_iter != NULL; hint_iter++) {
@@ -234,7 +244,9 @@ bool AudioManagerAlsa::HasAnyAlsaAudioDevice(
       DLOG(WARNING) << "HasAnyAudioDevice: unable to get device hints: "
                     << wrapper_->StrError(error);
     }
+#ifdef OS_LINUX
   }
+#endif
 
   return has_device;
 }
diff --git media/audio/audio_manager.cc media/audio/audio_manager.cc
index ee63570992..7c923ae268 100644
--- media/audio/audio_manager.cc
+++ media/audio/audio_manager.cc
@@ -94,7 +94,7 @@ class AudioManagerHelper : public base::PowerObserver {
   }
 #endif
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   void set_app_name(const std::string& app_name) { app_name_ = app_name; }
   const std::string& app_name() const { return app_name_; }
 #endif
@@ -229,7 +229,7 @@ class AudioManagerHelper : public base::PowerObserver {
   std::unique_ptr<base::win::ScopedCOMInitializer> com_initializer_for_testing_;
 #endif
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   std::string app_name_;
 #endif
 
@@ -311,7 +311,7 @@ void AudioManager::StartHangMonitorIfNeeded(
   GetHelper()->StartHangTimer(std::move(task_runner));
 }
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 // static
 void AudioManager::SetGlobalAppName(const std::string& app_name) {
   GetHelper()->set_app_name(app_name);
diff --git media/audio/audio_manager.h media/audio/audio_manager.h
index 6376261d21..acfd7ecf74 100644
--- media/audio/audio_manager.h
+++ media/audio/audio_manager.h
@@ -70,7 +70,7 @@ class MEDIA_EXPORT AudioManager {
   static void StartHangMonitorIfNeeded(
       scoped_refptr<base::SingleThreadTaskRunner> task_runner);
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // Sets the name of the audio source as seen by external apps. Only actually
   // used with PulseAudio as of this writing.
   static void SetGlobalAppName(const std::string& app_name);
diff --git media/base/audio_latency.cc media/base/audio_latency.cc
index 5816ad071b..cb8d07c228 100644
--- media/base/audio_latency.cc
+++ media/base/audio_latency.cc
@@ -106,7 +106,7 @@ int AudioLatency::GetRtcBufferSize(int sample_rate, int hardware_buffer_size) {
     return frames_per_buffer;
   }
 
-#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_FUCHSIA) || defined(OS_BSD)
   // On Linux, MacOS and Fuchsia, the low level IO implementations on the
   // browser side supports all buffer size the clients want. We use the native
   // peer connection buffer size (10ms) to achieve best possible performance.
diff --git media/base/media_switches.cc media/base/media_switches.cc
index 8fda8274d5..c99443ee61 100644
--- media/base/media_switches.cc
+++ media/base/media_switches.cc
@@ -36,7 +36,8 @@ const char kDisableMediaSuspend[] = "disable-media-suspend";
 const char kReportVp9AsAnUnsupportedMimeType[] =
     "report-vp9-as-an-unsupported-mime-type";
 
-#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_SOLARIS)
+#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_SOLARIS) || \
+    defined(OS_DRAGONFLY)
 // The Alsa device to use when opening an audio input stream.
 const char kAlsaInputDevice[] = "alsa-input-device";
 // The Alsa device to use when opening an audio stream.
diff --git media/base/media_switches.h media/base/media_switches.h
index 257c4892c9..799dbe598e 100644
--- media/base/media_switches.h
+++ media/base/media_switches.h
@@ -36,7 +36,8 @@ MEDIA_EXPORT extern const char kDisableMediaSuspend[];
 
 MEDIA_EXPORT extern const char kReportVp9AsAnUnsupportedMimeType[];
 
-#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_SOLARIS)
+#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_SOLARIS) || \
+    defined(OS_DRAGONFLY)
 MEDIA_EXPORT extern const char kAlsaInputDevice[];
 MEDIA_EXPORT extern const char kAlsaOutputDevice[];
 #endif
diff --git media/base/video_frame.cc media/base/video_frame.cc
index b68ba405ce..0a4c4d6039 100644
--- media/base/video_frame.cc
+++ media/base/video_frame.cc
@@ -63,7 +63,7 @@ static std::string StorageTypeToString(
       return "OWNED_MEMORY";
     case VideoFrame::STORAGE_SHMEM:
       return "SHMEM";
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     case VideoFrame::STORAGE_DMABUFS:
       return "DMABUFS";
 #endif
@@ -79,7 +79,7 @@ static std::string StorageTypeToString(
 // static
 static bool IsStorageTypeMappable(VideoFrame::StorageType storage_type) {
   return
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
       // This is not strictly needed but makes explicit that, at VideoFrame
       // level, DmaBufs are not mappable from userspace.
       storage_type != VideoFrame::STORAGE_DMABUFS &&
@@ -333,7 +333,7 @@ scoped_refptr<VideoFrame> VideoFrame::WrapExternalYuvaData(
   return frame;
 }
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 // static
 scoped_refptr<VideoFrame> VideoFrame::WrapExternalDmabufs(
     VideoPixelFormat format,
@@ -445,7 +445,7 @@ scoped_refptr<VideoFrame> VideoFrame::WrapVideoFrame(
     wrapping_frame->data_[i] = frame->data(i);
   }
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // If there are any |dmabuf_fds_| plugged in, we should duplicate them.
   if (frame->storage_type() == STORAGE_DMABUFS) {
     std::vector<int> original_fds;
@@ -787,7 +787,7 @@ size_t VideoFrame::shared_memory_offset() const {
   return shared_memory_offset_;
 }
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 int VideoFrame::DmabufFd(size_t plane) const {
   DCHECK_EQ(storage_type_, STORAGE_DMABUFS);
   DCHECK(IsValidPlane(plane, format_));
diff --git media/base/video_frame.h media/base/video_frame.h
index ea98a28b73..d33bf667f0 100644
--- media/base/video_frame.h
+++ media/base/video_frame.h
@@ -66,7 +66,7 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
     STORAGE_UNOWNED_MEMORY = 2,  // External, non owned data pointers.
     STORAGE_OWNED_MEMORY = 3,  // VideoFrame has allocated its own data buffer.
     STORAGE_SHMEM = 4,         // Pixels are backed by Shared Memory.
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     // TODO(mcasas): Consider turning this type into STORAGE_NATIVE
     // based on the idea of using this same enum value for both DMA
     // buffers on Linux and CVPixelBuffers on Mac (which currently use
@@ -191,7 +191,7 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
       uint8_t* a_data,
       base::TimeDelta timestamp);
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // Wraps provided dmabufs
   // (https://www.kernel.org/doc/html/latest/driver-api/dma-buf.html) with a
   // VideoFrame. The dmabuf fds are dup()ed on creation, so that the VideoFrame
@@ -347,7 +347,7 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
   // Returns the offset into the shared memory where the frame data begins.
   size_t shared_memory_offset() const;
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // Returns backing DmaBuf file descriptor for given |plane|, if present, or
   // -1 if not.
   int DmabufFd(size_t plane) const;
@@ -540,7 +540,7 @@ class MEDIA_EXPORT VideoFrame : public base::RefCountedThreadSafe<VideoFrame> {
   base::SharedMemoryHandle shared_memory_handle_;
   size_t shared_memory_offset_;
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // Dmabufs for each plane. If set, this frame has DmaBuf backing in some way.
   base::ScopedFD dmabuf_fds_[kMaxPlanes];
 #endif
diff --git media/capture/video/fake_video_capture_device_factory.cc media/capture/video/fake_video_capture_device_factory.cc
index ded86506b8..644124cf79 100644
--- media/capture/video/fake_video_capture_device_factory.cc
+++ media/capture/video/fake_video_capture_device_factory.cc
@@ -200,7 +200,7 @@ void FakeVideoCaptureDeviceFactory::GetDeviceDescriptors(
   for (const auto& entry : devices_config_) {
     device_descriptors->emplace_back(
         base::StringPrintf("fake_device_%d", entry_index), entry.device_id,
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
         VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE
 #elif defined(OS_MACOSX)
         VideoCaptureApi::MACOSX_AVFOUNDATION
diff --git media/capture/video/file_video_capture_device_factory.cc media/capture/video/file_video_capture_device_factory.cc
index 6205b57385..470501f956 100644
--- media/capture/video/file_video_capture_device_factory.cc
+++ media/capture/video/file_video_capture_device_factory.cc
@@ -53,7 +53,7 @@ void FileVideoCaptureDeviceFactory::GetDeviceDescriptors(
 #elif defined(OS_MACOSX)
       command_line_file_path.value(), kFileVideoCaptureDeviceName,
       VideoCaptureApi::MACOSX_AVFOUNDATION
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
       command_line_file_path.value(), kFileVideoCaptureDeviceName,
       VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE
 #else
diff --git media/capture/video/linux/v4l2_capture_delegate.cc media/capture/video/linux/v4l2_capture_delegate.cc
index ce969d7e40..2d87841d68 100644
--- media/capture/video/linux/v4l2_capture_delegate.cc
+++ media/capture/video/linux/v4l2_capture_delegate.cc
@@ -4,8 +4,10 @@
 
 #include "media/capture/video/linux/v4l2_capture_delegate.h"
 
+#if !defined(OS_BSD)
 #include <linux/version.h>
 #include <linux/videodev2.h>
+#endif
 #include <poll.h>
 #include <sys/fcntl.h>
 #include <sys/ioctl.h>
@@ -23,10 +25,10 @@
 
 using media::mojom::MeteringMode;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
+// #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
 // 16 bit depth, Realsense F200.
 #define V4L2_PIX_FMT_Z16 v4l2_fourcc('Z', '1', '6', ' ')
-#endif
+// #endif
 
 // TODO(aleksandar.stojiljkovic): Wrap this with kernel version check once the
 // format is introduced to kernel.
diff --git media/capture/video/linux/video_capture_device_linux.cc media/capture/video/linux/video_capture_device_linux.cc
index 594596a07d..d27b99b8b4 100644
--- media/capture/video/linux/video_capture_device_linux.cc
+++ media/capture/video/linux/video_capture_device_linux.cc
@@ -22,6 +22,7 @@
 
 namespace media {
 
+#if !defined(OS_FREEBSD)
 // Translates Video4Linux pixel formats to Chromium pixel formats.
 // static
 VideoPixelFormat VideoCaptureDeviceLinux::V4l2FourCcToChromiumPixelFormat(
@@ -35,6 +36,7 @@ std::list<uint32_t> VideoCaptureDeviceLinux::GetListOfUsableFourCCs(
     bool favour_mjpeg) {
   return V4L2CaptureDelegate::GetListOfUsableFourCcs(favour_mjpeg);
 }
+#endif // !defined(OS_FREEBSD)
 
 VideoCaptureDeviceLinux::VideoCaptureDeviceLinux(
     const VideoCaptureDeviceDescriptor& device_descriptor)
@@ -48,6 +50,7 @@ VideoCaptureDeviceLinux::~VideoCaptureDeviceLinux() {
   v4l2_thread_.Stop();
 }
 
+#if !defined(OS_FREEBSD)
 void VideoCaptureDeviceLinux::AllocateAndStart(
     const VideoCaptureParams& params,
     std::unique_ptr<VideoCaptureDevice::Client> client) {
@@ -76,7 +79,13 @@ void VideoCaptureDeviceLinux::AllocateAndStart(
     v4l2_thread_.task_runner()->PostTask(FROM_HERE, request);
   photo_requests_queue_.clear();
 }
+#else // !defined(OS_FREEBSD)
+void VideoCaptureDeviceLinux::AllocateAndStart(
+    const VideoCaptureParams& params,
+    std::unique_ptr<VideoCaptureDevice::Client> client) {}
+#endif // !defined(OS_FREEBSD)
 
+#if !defined(OS_FREEBSD)
 void VideoCaptureDeviceLinux::StopAndDeAllocate() {
   if (!v4l2_thread_.IsRunning())
     return;  // Wrong state.
@@ -127,7 +136,11 @@ void VideoCaptureDeviceLinux::SetPhotoOptions(
   }
   v4l2_thread_.task_runner()->PostTask(FROM_HERE, std::move(functor));
 }
+#else // !defined(OS_FREEBSD)
+void VideoCaptureDeviceLinux::StopAndDeAllocate() {}
+#endif // !defined(OS_FREEBSD)
 
+#if !defined(OS_FREEBSD)
 void VideoCaptureDeviceLinux::SetRotation(int rotation) {
   if (v4l2_thread_.IsRunning()) {
     v4l2_thread_.task_runner()->PostTask(
@@ -135,6 +148,9 @@ void VideoCaptureDeviceLinux::SetRotation(int rotation) {
                               capture_impl_->GetWeakPtr(), rotation));
   }
 }
+#else // !defined(OS_FREEBSD)
+void VideoCaptureDeviceLinux::SetRotation(int rotation) {}
+#endif // !defined(OS_FREEBSD)
 
 // static
 int VideoCaptureDeviceLinux::TranslatePowerLineFrequencyToV4L2(
diff --git media/capture/video/video_capture_device_client.cc media/capture/video/video_capture_device_client.cc
index 1a1bc937b3..7f4150988a 100644
--- media/capture/video/video_capture_device_client.cc
+++ media/capture/video/video_capture_device_client.cc
@@ -234,7 +234,7 @@ void VideoCaptureDeviceClient::OnIncomingCapturedData(
 // see http://linuxtv.org/downloads/v4l-dvb-apis/packed-rgb.html.
 // Windows RGB24 defines blue at lowest byte,
 // see https://msdn.microsoft.com/en-us/library/windows/desktop/dd407253
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
       origin_colorspace = libyuv::FOURCC_RAW;
 #elif defined(OS_WIN)
       origin_colorspace = libyuv::FOURCC_24BG;
diff --git media/capture/video/video_capture_device_factory.cc media/capture/video/video_capture_device_factory.cc
index 4dd4f7bde8..cdfb889e85 100644
--- media/capture/video/video_capture_device_factory.cc
+++ media/capture/video/video_capture_device_factory.cc
@@ -21,6 +21,10 @@ VideoCaptureDeviceFactory::CreateFactory(
     gpu::GpuMemoryBufferManager* gpu_buffer_manager,
     MojoJpegDecodeAcceleratorFactoryCB jda_factory,
     MojoJpegEncodeAcceleratorFactoryCB jea_factory) {
+#if defined(OS_BSD)
+   return std::unique_ptr<VideoCaptureDeviceFactory>(
+           new media::FakeVideoCaptureDeviceFactory());
+#else
   const base::CommandLine* command_line =
       base::CommandLine::ForCurrentProcess();
   // Use a Fake or File Video Device Factory if the command line flags are
@@ -47,6 +51,7 @@ VideoCaptureDeviceFactory::CreateFactory(
                                         std::move(jda_factory),
                                         std::move(jea_factory)));
   }
+#endif
 }
 
 VideoCaptureDeviceFactory::VideoCaptureDeviceFactory() {
@@ -56,7 +61,7 @@ VideoCaptureDeviceFactory::VideoCaptureDeviceFactory() {
 VideoCaptureDeviceFactory::~VideoCaptureDeviceFactory() = default;
 
 #if !defined(OS_MACOSX) && !defined(OS_LINUX) && !defined(OS_ANDROID) && \
-    !defined(OS_WIN)
+    !defined(OS_WIN) && !defined(OS_BSD)
 // static
 VideoCaptureDeviceFactory*
 VideoCaptureDeviceFactory::CreateVideoCaptureDeviceFactory(
diff --git media/filters/vp9_parser.h media/filters/vp9_parser.h
index 489c3c2058..ce4216c04a 100644
--- media/filters/vp9_parser.h
+++ media/filters/vp9_parser.h
@@ -14,6 +14,7 @@
 
 #include <stddef.h>
 #include <stdint.h>
+#include <unistd.h>
 #include <sys/types.h>
 
 #include <memory>
diff --git media/formats/common/offset_byte_queue.cc media/formats/common/offset_byte_queue.cc
index b355e1adf2..6fa7a9b6d5 100644
--- media/formats/common/offset_byte_queue.cc
+++ media/formats/common/offset_byte_queue.cc
@@ -46,13 +46,13 @@ void OffsetByteQueue::PeekAt(int64_t offset, const uint8_t** buf, int* size) {
   *size = tail() - offset;
 }
 
-bool OffsetByteQueue::Trim(int64_t max_offset) {
-  if (max_offset < head_) return true;
-  if (max_offset > tail()) {
+bool OffsetByteQueue::Trim(int64_t _max_offset) {
+  if (_max_offset < head_) return true;
+  if (_max_offset > tail()) {
     Pop(size_);
     return false;
   }
-  Pop(max_offset - head_);
+  Pop(_max_offset - head_);
   return true;
 }
 
diff --git media/formats/common/offset_byte_queue.h media/formats/common/offset_byte_queue.h
index eb0bd2c58e..95effd75bd 100644
--- media/formats/common/offset_byte_queue.h
+++ media/formats/common/offset_byte_queue.h
@@ -36,15 +36,15 @@ class MEDIA_EXPORT OffsetByteQueue {
   // a null |buf| and a |size| of zero.
   void PeekAt(int64_t offset, const uint8_t** buf, int* size);
 
-  // Marks the bytes up to (but not including) |max_offset| as ready for
+  // Marks the bytes up to (but not including) |_max_offset| as ready for
   // deletion. This is relatively inexpensive, but will not necessarily reduce
   // the resident buffer size right away (or ever).
   //
   // Returns true if the full range of bytes were successfully trimmed,
-  // including the case where |max_offset| is less than the current head.
-  // Returns false if |max_offset| > tail() (although all bytes currently
+  // including the case where |_max_offset| is less than the current head.
+  // Returns false if |_max_offset| > tail() (although all bytes currently
   // buffered are still cleared).
-  bool Trim(int64_t max_offset);
+  bool Trim(int64_t _max_offset);
 
   // The head and tail positions, in terms of the file's absolute offsets.
   // tail() is an exclusive bound.
diff --git media/formats/mp2t/es_parser_adts.cc media/formats/mp2t/es_parser_adts.cc
index 7a2dbb5c46..95fedea983 100644
--- media/formats/mp2t/es_parser_adts.cc
+++ media/formats/mp2t/es_parser_adts.cc
@@ -63,11 +63,11 @@ bool EsParserAdts::LookForAdtsFrame(AdtsFrame* adts_frame) {
   const uint8_t* es;
   es_queue_->Peek(&es, &es_size);
 
-  int max_offset = es_size - kADTSHeaderMinSize;
-  if (max_offset <= 0)
+  int _max_offset = es_size - kADTSHeaderMinSize;
+  if (_max_offset <= 0)
     return false;
 
-  for (int offset = 0; offset < max_offset; offset++) {
+  for (int offset = 0; offset < _max_offset; offset++) {
     const uint8_t* cur_buf = &es[offset];
     if (!isAdtsSyncWord(cur_buf))
       continue;
@@ -107,7 +107,7 @@ bool EsParserAdts::LookForAdtsFrame(AdtsFrame* adts_frame) {
     return true;
   }
 
-  es_queue_->Pop(max_offset);
+  es_queue_->Pop(_max_offset);
   return false;
 }
 
diff --git media/formats/mp2t/es_parser_mpeg1audio.cc media/formats/mp2t/es_parser_mpeg1audio.cc
index 1e1cb060f1..f9c408fb28 100644
--- media/formats/mp2t/es_parser_mpeg1audio.cc
+++ media/formats/mp2t/es_parser_mpeg1audio.cc
@@ -108,11 +108,11 @@ bool EsParserMpeg1Audio::LookForMpeg1AudioFrame(
   const uint8_t* es;
   es_queue_->Peek(&es, &es_size);
 
-  int max_offset = es_size - MPEG1AudioStreamParser::kHeaderSize;
-  if (max_offset <= 0)
+  int _max_offset = es_size - MPEG1AudioStreamParser::kHeaderSize;
+  if (_max_offset <= 0)
     return false;
 
-  for (int offset = 0; offset < max_offset; offset++) {
+  for (int offset = 0; offset < _max_offset; offset++) {
     const uint8_t* cur_buf = &es[offset];
     if (cur_buf[0] != 0xff)
       continue;
@@ -153,7 +153,7 @@ bool EsParserMpeg1Audio::LookForMpeg1AudioFrame(
     return true;
   }
 
-  es_queue_->Pop(max_offset);
+  es_queue_->Pop(_max_offset);
   return false;
 }
 
diff --git media/media_options.gni media/media_options.gni
index 0279aa5c0e..2b8c077122 100644
--- media/media_options.gni
+++ media/media_options.gni
@@ -95,6 +95,9 @@ declare_args() {
   # Enables runtime selection of ALSA library for audio.
   use_alsa = false
 
+  # Enable runtime selection of sndio(7)
+  use_sndio = false
+
   # Alsa should be used on non-Android, non-Mac POSIX systems.
   # Alsa should be used on desktop Chromecast and audio-only Chromecast builds.
   if (is_posix && !is_android && !is_mac &&
diff --git mojo/edk/embedder/platform_channel_utils_posix.cc mojo/edk/embedder/platform_channel_utils_posix.cc
index 8ac67dc2bc..7b7afffe9f 100644
--- mojo/edk/embedder/platform_channel_utils_posix.cc
+++ mojo/edk/embedder/platform_channel_utils_posix.cc
@@ -37,7 +37,7 @@ bool IsRecoverableError() {
 
 bool GetPeerEuid(InternalPlatformHandle handle, uid_t* peer_euid) {
   DCHECK(peer_euid);
-#if defined(OS_MACOSX) || defined(OS_OPENBSD) || defined(OS_FREEBSD)
+#if defined(OS_MACOSX) || defined(OS_BSD)
   uid_t socket_euid;
   gid_t socket_gid;
   if (getpeereid(handle.handle, &socket_euid, &socket_gid) < 0) {
diff --git net/BUILD.gn net/BUILD.gn
index 9d59189d80..94fc5c3eed 100644
--- net/BUILD.gn
+++ net/BUILD.gn
@@ -85,7 +85,7 @@ net_configs = [
   "//build/config/compiler:wexit_time_destructors",
 ]
 
-if (is_linux) {
+if (is_linux && !is_bsd) {
   net_configs += [ "//build/config/linux:libresolv" ]
 }
 
@@ -2009,6 +2009,17 @@ component("net") {
       sources -= [ "disk_cache/blockfile/file_posix.cc" ]
     }
 
+    if (is_bsd) {
+      sources -= [
+         "base/address_tracker_linux.cc",
+         "base/address_tracker_linux.h",
+         "base/network_change_notifier_linux.cc",
+         "base/network_change_notifier_linux.h",
+         "base/network_interfaces_linux.cc",
+      ]
+      sources += [ "base/network_interfaces_freebsd.cc" ]
+    }
+
     if (is_ios || is_mac) {
       sources += [
         "base/mac/url_conversions.h",
diff --git net/base/address_tracker_linux.cc net/base/address_tracker_linux.cc
index 2848b56959..17a618a9a5 100644
--- net/base/address_tracker_linux.cc
+++ net/base/address_tracker_linux.cc
@@ -20,96 +20,10 @@
 namespace net {
 namespace internal {
 
-namespace {
-
-// Some kernel functions such as wireless_send_event and rtnetlink_ifinfo_prep
-// may send spurious messages over rtnetlink. RTM_NEWLINK messages where
-// ifi_change == 0 and rta_type == IFLA_WIRELESS should be ignored.
-bool IgnoreWirelessChange(const struct nlmsghdr* header,
-                          const struct ifinfomsg* msg) {
-  size_t length = IFLA_PAYLOAD(header);
-  for (const struct rtattr* attr = IFLA_RTA(msg); RTA_OK(attr, length);
-       attr = RTA_NEXT(attr, length)) {
-    if (attr->rta_type == IFLA_WIRELESS && msg->ifi_change == 0)
-      return true;
-  }
-  return false;
-}
-
-// Retrieves address from NETLINK address message.
-// Sets |really_deprecated| for IPv6 addresses with preferred lifetimes of 0.
-bool GetAddress(const struct nlmsghdr* header,
-                IPAddress* out,
-                bool* really_deprecated) {
-  if (really_deprecated)
-    *really_deprecated = false;
-  const struct ifaddrmsg* msg =
-      reinterpret_cast<struct ifaddrmsg*>(NLMSG_DATA(header));
-  size_t address_length = 0;
-  switch (msg->ifa_family) {
-    case AF_INET:
-      address_length = IPAddress::kIPv4AddressSize;
-      break;
-    case AF_INET6:
-      address_length = IPAddress::kIPv6AddressSize;
-      break;
-    default:
-      // Unknown family.
-      return false;
-  }
-  // Use IFA_ADDRESS unless IFA_LOCAL is present. This behavior here is based on
-  // getaddrinfo in glibc (check_pf.c). Judging from kernel implementation of
-  // NETLINK, IPv4 addresses have only the IFA_ADDRESS attribute, while IPv6
-  // have the IFA_LOCAL attribute.
-  uint8_t* address = NULL;
-  uint8_t* local = NULL;
-  size_t length = IFA_PAYLOAD(header);
-  for (const struct rtattr* attr =
-           reinterpret_cast<const struct rtattr*>(IFA_RTA(msg));
-       RTA_OK(attr, length);
-       attr = RTA_NEXT(attr, length)) {
-    switch (attr->rta_type) {
-      case IFA_ADDRESS:
-        DCHECK_GE(RTA_PAYLOAD(attr), address_length);
-        address = reinterpret_cast<uint8_t*>(RTA_DATA(attr));
-        break;
-      case IFA_LOCAL:
-        DCHECK_GE(RTA_PAYLOAD(attr), address_length);
-        local = reinterpret_cast<uint8_t*>(RTA_DATA(attr));
-        break;
-      case IFA_CACHEINFO: {
-        const struct ifa_cacheinfo *cache_info =
-            reinterpret_cast<const struct ifa_cacheinfo*>(RTA_DATA(attr));
-        if (really_deprecated)
-          *really_deprecated = (cache_info->ifa_prefered == 0);
-      } break;
-      default:
-        break;
-    }
-  }
-  if (local)
-    address = local;
-  if (!address)
-    return false;
-  *out = IPAddress(address, address_length);
-  return true;
-}
-
-}  // namespace
-
 // static
 char* AddressTrackerLinux::GetInterfaceName(int interface_index, char* buf) {
-  memset(buf, 0, IFNAMSIZ);
-  base::ScopedFD ioctl_socket = GetSocketForIoctl();
-  if (!ioctl_socket.is_valid())
-    return buf;
-
-  struct ifreq ifr = {};
-  ifr.ifr_ifindex = interface_index;
-
-  if (ioctl(ioctl_socket.get(), SIOCGIFNAME, &ifr) == 0)
-    strncpy(buf, ifr.ifr_name, IFNAMSIZ - 1);
-  return buf;
+  NOTIMPLEMENTED();
+  return NULL;
 }
 
 AddressTrackerLinux::AddressTrackerLinux()
@@ -152,93 +66,8 @@ AddressTrackerLinux::~AddressTrackerLinux() {
 }
 
 void AddressTrackerLinux::Init() {
-  netlink_fd_ = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
-  if (netlink_fd_ < 0) {
-    PLOG(ERROR) << "Could not create NETLINK socket";
-    AbortAndForceOnline();
-    return;
-  }
-
-  int rv;
-
-  if (tracking_) {
-    // Request notifications.
-    struct sockaddr_nl addr = {};
-    addr.nl_family = AF_NETLINK;
-    addr.nl_pid = getpid();
-    // TODO(szym): Track RTMGRP_LINK as well for ifi_type,
-    // http://crbug.com/113993
-    addr.nl_groups =
-        RTMGRP_IPV4_IFADDR | RTMGRP_IPV6_IFADDR | RTMGRP_NOTIFY | RTMGRP_LINK;
-    rv = bind(
-        netlink_fd_, reinterpret_cast<struct sockaddr*>(&addr), sizeof(addr));
-    if (rv < 0) {
-      PLOG(ERROR) << "Could not bind NETLINK socket";
-      AbortAndForceOnline();
-      return;
-    }
-  }
-
-  // Request dump of addresses.
-  struct sockaddr_nl peer = {};
-  peer.nl_family = AF_NETLINK;
-
-  struct {
-    struct nlmsghdr header;
-    struct rtgenmsg msg;
-  } request = {};
-
-  request.header.nlmsg_len = NLMSG_LENGTH(sizeof(request.msg));
-  request.header.nlmsg_type = RTM_GETADDR;
-  request.header.nlmsg_flags = NLM_F_REQUEST | NLM_F_DUMP;
-  request.header.nlmsg_pid = getpid();
-  request.msg.rtgen_family = AF_UNSPEC;
-
-  rv = HANDLE_EINTR(sendto(netlink_fd_, &request, request.header.nlmsg_len,
-                           0, reinterpret_cast<struct sockaddr*>(&peer),
-                           sizeof(peer)));
-  if (rv < 0) {
-    PLOG(ERROR) << "Could not send NETLINK request";
-    AbortAndForceOnline();
-    return;
-  }
-
-  // Consume pending message to populate the AddressMap, but don't notify.
-  // Sending another request without first reading responses results in EBUSY.
-  bool address_changed;
-  bool link_changed;
-  bool tunnel_changed;
-  ReadMessages(&address_changed, &link_changed, &tunnel_changed);
-
-  // Request dump of link state
-  request.header.nlmsg_type = RTM_GETLINK;
-
-  rv = HANDLE_EINTR(sendto(netlink_fd_, &request, request.header.nlmsg_len, 0,
-                           reinterpret_cast<struct sockaddr*>(&peer),
-                           sizeof(peer)));
-  if (rv < 0) {
-    PLOG(ERROR) << "Could not send NETLINK request";
-    AbortAndForceOnline();
-    return;
-  }
-
-  // Consume pending message to populate links_online_, but don't notify.
-  ReadMessages(&address_changed, &link_changed, &tunnel_changed);
-  {
-    AddressTrackerAutoLock lock(*this, connection_type_lock_);
-    connection_type_initialized_ = true;
-    connection_type_initialized_cv_.Broadcast();
-  }
-
-  if (tracking_) {
-    rv = base::MessageLoopCurrentForIO::Get()->WatchFileDescriptor(
-        netlink_fd_, true, base::MessagePumpForIO::WATCH_READ, &watcher_, this);
-    if (rv < 0) {
-      PLOG(ERROR) << "Could not watch NETLINK socket";
-      AbortAndForceOnline();
-      return;
-    }
-  }
+NOTIMPLEMENTED();
+AbortAndForceOnline();
 }
 
 void AddressTrackerLinux::AbortAndForceOnline() {
@@ -249,25 +78,6 @@ void AddressTrackerLinux::AbortAndForceOnline() {
   connection_type_initialized_cv_.Broadcast();
 }
 
-AddressTrackerLinux::AddressMap AddressTrackerLinux::GetAddressMap() const {
-  AddressTrackerAutoLock lock(*this, address_map_lock_);
-  return address_map_;
-}
-
-std::unordered_set<int> AddressTrackerLinux::GetOnlineLinks() const {
-  AddressTrackerAutoLock lock(*this, online_links_lock_);
-  return online_links_;
-}
-
-bool AddressTrackerLinux::IsInterfaceIgnored(int interface_index) const {
-  if (ignored_interfaces_.empty())
-    return false;
-
-  char buf[IFNAMSIZ] = {0};
-  const char* interface_name = get_interface_name_(interface_index, buf);
-  return ignored_interfaces_.find(interface_name) != ignored_interfaces_.end();
-}
-
 NetworkChangeNotifier::ConnectionType
 AddressTrackerLinux::GetCurrentConnectionType() {
   // http://crbug.com/125097
@@ -318,102 +128,7 @@ void AddressTrackerLinux::HandleMessage(char* buffer,
                                         bool* address_changed,
                                         bool* link_changed,
                                         bool* tunnel_changed) {
-  DCHECK(buffer);
-  for (struct nlmsghdr* header = reinterpret_cast<struct nlmsghdr*>(buffer);
-       NLMSG_OK(header, length);
-       header = NLMSG_NEXT(header, length)) {
-    switch (header->nlmsg_type) {
-      case NLMSG_DONE:
-        return;
-      case NLMSG_ERROR: {
-        const struct nlmsgerr* msg =
-            reinterpret_cast<struct nlmsgerr*>(NLMSG_DATA(header));
-        LOG(ERROR) << "Unexpected netlink error " << msg->error << ".";
-      } return;
-      case RTM_NEWADDR: {
-        IPAddress address;
-        bool really_deprecated;
-        struct ifaddrmsg* msg =
-            reinterpret_cast<struct ifaddrmsg*>(NLMSG_DATA(header));
-        if (IsInterfaceIgnored(msg->ifa_index))
-          break;
-        if (GetAddress(header, &address, &really_deprecated)) {
-          AddressTrackerAutoLock lock(*this, address_map_lock_);
-          // Routers may frequently (every few seconds) output the IPv6 ULA
-          // prefix which can cause the linux kernel to frequently output two
-          // back-to-back messages, one without the deprecated flag and one with
-          // the deprecated flag but both with preferred lifetimes of 0. Avoid
-          // interpretting this as an actual change by canonicalizing the two
-          // messages by setting the deprecated flag based on the preferred
-          // lifetime also.  http://crbug.com/268042
-          if (really_deprecated)
-            msg->ifa_flags |= IFA_F_DEPRECATED;
-          // Only indicate change if the address is new or ifaddrmsg info has
-          // changed.
-          AddressMap::iterator it = address_map_.find(address);
-          if (it == address_map_.end()) {
-            address_map_.insert(it, std::make_pair(address, *msg));
-            *address_changed = true;
-          } else if (memcmp(&it->second, msg, sizeof(*msg))) {
-            it->second = *msg;
-            *address_changed = true;
-          }
-        }
-      } break;
-      case RTM_DELADDR: {
-        IPAddress address;
-        const struct ifaddrmsg* msg =
-            reinterpret_cast<struct ifaddrmsg*>(NLMSG_DATA(header));
-        if (IsInterfaceIgnored(msg->ifa_index))
-          break;
-        if (GetAddress(header, &address, NULL)) {
-          AddressTrackerAutoLock lock(*this, address_map_lock_);
-          if (address_map_.erase(address))
-            *address_changed = true;
-        }
-      } break;
-      case RTM_NEWLINK: {
-        const struct ifinfomsg* msg =
-            reinterpret_cast<struct ifinfomsg*>(NLMSG_DATA(header));
-        if (IsInterfaceIgnored(msg->ifi_index))
-          break;
-        if (IgnoreWirelessChange(header, msg)) {
-          VLOG(2) << "Ignoring RTM_NEWLINK message";
-          break;
-        }
-        if (!(msg->ifi_flags & IFF_LOOPBACK) && (msg->ifi_flags & IFF_UP) &&
-            (msg->ifi_flags & IFF_LOWER_UP) && (msg->ifi_flags & IFF_RUNNING)) {
-          AddressTrackerAutoLock lock(*this, online_links_lock_);
-          if (online_links_.insert(msg->ifi_index).second) {
-            *link_changed = true;
-            if (IsTunnelInterface(msg->ifi_index))
-              *tunnel_changed = true;
-          }
-        } else {
-          AddressTrackerAutoLock lock(*this, online_links_lock_);
-          if (online_links_.erase(msg->ifi_index)) {
-            *link_changed = true;
-            if (IsTunnelInterface(msg->ifi_index))
-              *tunnel_changed = true;
-          }
-        }
-      } break;
-      case RTM_DELLINK: {
-        const struct ifinfomsg* msg =
-            reinterpret_cast<struct ifinfomsg*>(NLMSG_DATA(header));
-        if (IsInterfaceIgnored(msg->ifi_index))
-          break;
-        AddressTrackerAutoLock lock(*this, online_links_lock_);
-        if (online_links_.erase(msg->ifi_index)) {
-          *link_changed = true;
-          if (IsTunnelInterface(msg->ifi_index))
-            *tunnel_changed = true;
-        }
-      } break;
-      default:
-        break;
-    }
-  }
+  NOTIMPLEMENTED();
 }
 
 void AddressTrackerLinux::OnFileCanReadWithoutBlocking(int fd) {
@@ -450,34 +165,7 @@ bool AddressTrackerLinux::IsTunnelInterfaceName(const char* name) {
 }
 
 void AddressTrackerLinux::UpdateCurrentConnectionType() {
-  AddressTrackerLinux::AddressMap address_map = GetAddressMap();
-  std::unordered_set<int> online_links = GetOnlineLinks();
-
-  // Strip out tunnel interfaces from online_links
-  for (std::unordered_set<int>::const_iterator it = online_links.begin();
-       it != online_links.end();) {
-    if (IsTunnelInterface(*it)) {
-      std::unordered_set<int>::const_iterator tunnel_it = it;
-      ++it;
-      online_links.erase(*tunnel_it);
-    } else {
-      ++it;
-    }
-  }
-
-  NetworkInterfaceList networks;
-  NetworkChangeNotifier::ConnectionType type =
-      NetworkChangeNotifier::CONNECTION_NONE;
-  if (GetNetworkListImpl(&networks, 0, online_links, address_map,
-                         get_interface_name_)) {
-    type = NetworkChangeNotifier::ConnectionTypeFromInterfaceList(networks);
-  } else {
-    type = online_links.empty() ? NetworkChangeNotifier::CONNECTION_NONE
-                                : NetworkChangeNotifier::CONNECTION_UNKNOWN;
-  }
-
-  AddressTrackerAutoLock lock(*this, connection_type_lock_);
-  current_connection_type_ = type;
+  NOTIMPLEMENTED();
 }
 
 int AddressTrackerLinux::GetThreadsWaitingForConnectionTypeInitForTesting()
diff --git net/base/address_tracker_linux.h net/base/address_tracker_linux.h
index 66e82a6c4c..01816f3b45 100644
--- net/base/address_tracker_linux.h
+++ net/base/address_tracker_linux.h
@@ -7,9 +7,6 @@
 
 #include <sys/socket.h>  // Needed to include netlink.
 // Mask superfluous definition of |struct net|. This is fixed in Linux 2.6.38.
-#define net net_kernel
-#include <linux/rtnetlink.h>
-#undef net
 #include <stddef.h>
 
 #include <map>
diff --git net/base/address_tracker_linux_unittest.cc net/base/address_tracker_linux_unittest.cc
index 28739b12d7..8cc4d8fd9e 100644
--- net/base/address_tracker_linux_unittest.cc
+++ net/base/address_tracker_linux_unittest.cc
@@ -4,7 +4,11 @@
 
 #include "net/base/address_tracker_linux.h"
 
+#if defined(__linux__)
 #include <linux/if.h>
+#else
+#include <net/if.h>
+#endif
 
 #include <memory>
 #include <unordered_set>
diff --git net/base/network_change_notifier.cc net/base/network_change_notifier.cc
index d0e8b6dc3b..4254a819a2 100644
--- net/base/network_change_notifier.cc
+++ net/base/network_change_notifier.cc
@@ -544,7 +544,6 @@ NetworkChangeNotifier* NetworkChangeNotifier::Create() {
 #elif defined(OS_MACOSX)
   return new NetworkChangeNotifierMac();
 #else
-  NOTIMPLEMENTED();
   return NULL;
 #endif
 }
diff --git net/base/network_interfaces_freebsd.cc net/base/network_interfaces_freebsd.cc
new file mode 100644
index 0000000000..3242eb420c
--- /dev/null
+++ net/base/network_interfaces_freebsd.cc
@@ -0,0 +1,240 @@
+// Copyright (c) 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "net/base/network_interfaces_freebsd.h"
+
+#include <ifaddrs.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <sys/types.h>
+#include <net/if_media.h>
+#include <net/if_var.h>
+#include <netinet/in_var.h>
+#include <netinet6/in6_var.h>
+#include <sys/ioctl.h>
+
+#include <memory>
+#include <set>
+
+#include "base/files/file_path.h"
+#include "base/logging.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_tokenizer.h"
+#include "base/strings/string_util.h"
+#include "base/threading/thread_restrictions.h"
+#include "net/base/escape.h"
+#include "net/base/ip_endpoint.h"
+#include "net/base/net_errors.h"
+#include "net/base/network_interfaces_posix.h"
+#include "url/gurl.h"
+
+namespace net {
+
+namespace {
+
+// FreeBSD implementation of IPAttributesGetterFreeBSD which calls ioctl on socket to
+// retrieve IP attributes.
+class IPAttributesGetterFreeBSDImpl : public internal::IPAttributesGetterFreeBSD {
+ public:
+  IPAttributesGetterFreeBSDImpl();
+  ~IPAttributesGetterFreeBSDImpl() override;
+  bool IsInitialized() const override;
+  bool GetIPAttributes(const char* ifname,
+                       const sockaddr* sock_addr,
+                       int* native_attributes) override;
+
+ private:
+  int ioctl_socket_;
+};
+
+IPAttributesGetterFreeBSDImpl::IPAttributesGetterFreeBSDImpl()
+    : ioctl_socket_(socket(AF_INET6, SOCK_DGRAM, 0)) {
+  DCHECK_GE(ioctl_socket_, 0);
+}
+
+bool IPAttributesGetterFreeBSDImpl::IsInitialized() const {
+  return ioctl_socket_ >= 0;
+}
+
+IPAttributesGetterFreeBSDImpl::~IPAttributesGetterFreeBSDImpl() {
+  if (ioctl_socket_ >= 0) {
+    close(ioctl_socket_);
+  }
+}
+
+bool IPAttributesGetterFreeBSDImpl::GetIPAttributes(const char* ifname,
+                                                const sockaddr* sock_addr,
+                                                int* native_attributes) {
+  struct in6_ifreq ifr = {};
+  strncpy(ifr.ifr_name, ifname, sizeof(ifr.ifr_name) - 1);
+  memcpy(&ifr.ifr_ifru.ifru_addr, sock_addr, sock_addr->sa_len);
+  int rv = ioctl(ioctl_socket_, SIOCGIFAFLAG_IN6, &ifr);
+  if (rv >= 0) {
+    *native_attributes = ifr.ifr_ifru.ifru_flags;
+  }
+  return (rv >= 0);
+}
+
+// When returning true, the platform native IPv6 address attributes were
+// successfully converted to net IP address attributes. Otherwise, returning
+// false and the caller should drop the IP address which can't be used by the
+// application layer.
+bool TryConvertNativeToNetIPAttributes(int native_attributes,
+                                       int* net_attributes) {
+  // For FreeBSD, we disallow addresses with attributes IN6_IFF_ANYCASE,
+  // IN6_IFF_DUPLICATED, IN6_IFF_TENTATIVE, and IN6_IFF_DETACHED as these are
+  // still progressing through duplicated address detection (DAD) or are not
+  // suitable to be used in an one-to-one communication and shouldn't be used
+  // by the application layer.
+  if (native_attributes & (IN6_IFF_ANYCAST | IN6_IFF_DUPLICATED |
+                           IN6_IFF_TENTATIVE | IN6_IFF_DETACHED)) {
+    return false;
+  }
+
+  if (native_attributes & IN6_IFF_DEPRECATED) {
+    *net_attributes |= IP_ADDRESS_ATTRIBUTE_DEPRECATED;
+  }
+
+  return true;
+}
+
+NetworkChangeNotifier::ConnectionType GetNetworkInterfaceType(
+    int addr_family,
+    const std::string& interface_name) {
+  NetworkChangeNotifier::ConnectionType type =
+      NetworkChangeNotifier::CONNECTION_UNKNOWN;
+
+  struct ifmediareq ifmr = {};
+  strncpy(ifmr.ifm_name, interface_name.c_str(), sizeof(ifmr.ifm_name) - 1);
+
+  int s = socket(addr_family, SOCK_DGRAM, 0);
+  if (s == -1) {
+    return type;
+  }
+
+  if (ioctl(s, SIOCGIFMEDIA, &ifmr) != -1) {
+    if (ifmr.ifm_current & IFM_IEEE80211) {
+      type = NetworkChangeNotifier::CONNECTION_WIFI;
+    } else if (ifmr.ifm_current & IFM_ETHER) {
+      type = NetworkChangeNotifier::CONNECTION_ETHERNET;
+    }
+  }
+  close(s);
+  return type;
+}
+
+}  // namespace
+
+namespace internal {
+
+bool GetNetworkListImpl(NetworkInterfaceList* networks,
+                        int policy,
+                        const ifaddrs* interfaces,
+                        IPAttributesGetterFreeBSD* ip_attributes_getter) {
+  // Enumerate the addresses assigned to network interfaces which are up.
+  for (const ifaddrs* interface = interfaces; interface != NULL;
+       interface = interface->ifa_next) {
+    // Skip loopback interfaces, and ones which are down.
+    if (!(IFF_RUNNING & interface->ifa_flags))
+      continue;
+    if (IFF_LOOPBACK & interface->ifa_flags)
+      continue;
+    // Skip interfaces with no address configured.
+    struct sockaddr* addr = interface->ifa_addr;
+    if (!addr)
+      continue;
+
+    // Skip unspecified addresses (i.e. made of zeroes) and loopback addresses
+    // configured on non-loopback interfaces.
+    if (IsLoopbackOrUnspecifiedAddress(addr))
+      continue;
+
+    const std::string& name = interface->ifa_name;
+    // Filter out VMware interfaces, typically named vmnet1 and vmnet8.
+    if (ShouldIgnoreInterface(name, policy)) {
+      continue;
+    }
+
+    NetworkChangeNotifier::ConnectionType connection_type =
+        NetworkChangeNotifier::CONNECTION_UNKNOWN;
+
+    int ip_attributes = IP_ADDRESS_ATTRIBUTE_NONE;
+
+    // Retrieve native ip attributes and convert to net version if a getter is
+    // given.
+    if (ip_attributes_getter && ip_attributes_getter->IsInitialized()) {
+      int native_attributes = 0;
+      if (addr->sa_family == AF_INET6 &&
+          ip_attributes_getter->GetIPAttributes(
+              interface->ifa_name, interface->ifa_addr, &native_attributes)) {
+        if (!TryConvertNativeToNetIPAttributes(native_attributes,
+                                               &ip_attributes)) {
+          continue;
+        }
+      }
+    }
+
+    connection_type = GetNetworkInterfaceType(addr->sa_family, name);
+
+    IPEndPoint address;
+
+    int addr_size = 0;
+    if (addr->sa_family == AF_INET6) {
+      addr_size = sizeof(sockaddr_in6);
+    } else if (addr->sa_family == AF_INET) {
+      addr_size = sizeof(sockaddr_in);
+    }
+
+    if (address.FromSockAddr(addr, addr_size)) {
+      uint8_t prefix_length = 0;
+      if (interface->ifa_netmask) {
+        // If not otherwise set, assume the same sa_family as ifa_addr.
+        if (interface->ifa_netmask->sa_family == 0) {
+          interface->ifa_netmask->sa_family = addr->sa_family;
+        }
+        IPEndPoint netmask;
+        if (netmask.FromSockAddr(interface->ifa_netmask, addr_size)) {
+          prefix_length = MaskPrefixLength(netmask.address());
+        }
+      }
+      networks->push_back(NetworkInterface(
+          name, name, if_nametoindex(name.c_str()), connection_type,
+          address.address(), prefix_length, ip_attributes));
+    }
+  }
+
+  return true;
+}
+
+}  // namespace internal
+
+bool GetNetworkList(NetworkInterfaceList* networks, int policy) {
+  if (networks == NULL)
+    return false;
+
+  // getifaddrs() may require IO operations.
+  base::AssertBlockingAllowed();
+
+  ifaddrs* interfaces;
+  if (getifaddrs(&interfaces) < 0) {
+    PLOG(ERROR) << "getifaddrs";
+    return false;
+  }
+
+  std::unique_ptr<internal::IPAttributesGetterFreeBSD> ip_attributes_getter;
+
+  ip_attributes_getter.reset(new IPAttributesGetterFreeBSDImpl());
+
+  bool result = internal::GetNetworkListImpl(networks, policy, interfaces,
+                                             ip_attributes_getter.get());
+  freeifaddrs(interfaces);
+  return result;
+}
+
+std::string GetWifiSSID() {
+  NOTIMPLEMENTED();
+  return "";
+}
+
+}  // namespace net
diff --git net/base/network_interfaces_freebsd.h net/base/network_interfaces_freebsd.h
new file mode 100644
index 0000000000..ce9f5ddcb2
--- /dev/null
+++ net/base/network_interfaces_freebsd.h
@@ -0,0 +1,44 @@
+// Copyright (c) 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef NET_BASE_NETWORK_INTERFACES_FREEBSD_H_
+#define NET_BASE_NETWORK_INTERFACES_FREEBSD_H_
+
+// This file is only used to expose some of the internals
+// of network_interfaces_mac.cc to tests.
+
+#include <sys/socket.h>
+
+#include "base/macros.h"
+#include "net/base/net_export.h"
+#include "net/base/network_interfaces.h"
+
+struct ifaddrs;
+struct sockaddr;
+
+namespace net {
+namespace internal {
+
+class NET_EXPORT IPAttributesGetterFreeBSD {
+ public:
+  IPAttributesGetterFreeBSD() {}
+  virtual ~IPAttributesGetterFreeBSD() {}
+  virtual bool IsInitialized() const = 0;
+  virtual bool GetIPAttributes(const char* ifname,
+                               const sockaddr* sock_addr,
+                               int* native_attributes) = 0;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(IPAttributesGetterFreeBSD);
+};
+
+NET_EXPORT bool GetNetworkListImpl(NetworkInterfaceList* networks,
+                                   int policy,
+                                   const ifaddrs* interfaces,
+                                   IPAttributesGetterFreeBSD* ip_attributes_getter);
+
+}  // namespace internal
+}  // namespace net
+
+#endif  // NET_BASE_NETWORK_INTERFACES_FREEBSD_H_
diff --git net/base/network_interfaces_posix.h net/base/network_interfaces_posix.h
index 9a2bc40019..116e077278 100644
--- net/base/network_interfaces_posix.h
+++ net/base/network_interfaces_posix.h
@@ -8,6 +8,8 @@
 // This file provides some basic functionality shared between
 // network_interfaces_linux.cc and network_interfaces_getifaddrs.cc.
 
+#include <sys/socket.h>
+
 #include <string>
 
 struct sockaddr;
diff --git net/disk_cache/blockfile/disk_format.h net/disk_cache/blockfile/disk_format.h
index a621ec17c5..f230e7b6a8 100644
--- net/disk_cache/blockfile/disk_format.h
+++ net/disk_cache/blockfile/disk_format.h
@@ -149,7 +149,9 @@ struct RankingsNode {
 };
 #pragma pack(pop)
 
+#if !defined(OS_BSD)
 static_assert(sizeof(RankingsNode) == 36, "bad RankingsNode");
+#endif
 
 }  // namespace disk_cache
 
diff --git net/dns/address_sorter_posix.cc net/dns/address_sorter_posix.cc
index 37af8da106..cee3568b24 100644
--- net/dns/address_sorter_posix.cc
+++ net/dns/address_sorter_posix.cc
@@ -13,7 +13,9 @@
 #include <sys/socket.h>  // Must be included before ifaddrs.h.
 #include <ifaddrs.h>
 #include <net/if.h>
+#include <net/if_var.h>
 #include <netinet/in_var.h>
+#include <netinet6/in6_var.h>
 #include <string.h>
 #include <sys/ioctl.h>
 #endif
diff --git net/dns/dns_config_service_posix.cc net/dns/dns_config_service_posix.cc
index 06e9d7969c..76dac81cf2 100644
--- net/dns/dns_config_service_posix.cc
+++ net/dns/dns_config_service_posix.cc
@@ -165,11 +165,11 @@ ConfigParsePosixResult ReadDnsConfig(DnsConfig* dns_config) {
     result = CONFIG_PARSE_POSIX_RES_INIT_FAILED;
   }
   // Prefer res_ndestroy where available.
-#if defined(OS_MACOSX) || defined(OS_FREEBSD)
+#if defined(OS_MACOSX) || defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
   res_ndestroy(&res);
 #else
   res_nclose(&res);
-#endif  // defined(OS_MACOSX) || defined(OS_FREEBSD)
+#endif  // defined(OS_MACOSX) || defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
 #endif  // defined(OS_OPENBSD)
 
 #if defined(OS_MACOSX) && !defined(OS_IOS)
@@ -449,7 +449,7 @@ ConfigParsePosixResult ConvertResStateToDnsConfig(const struct __res_state& res,
 
   dns_config->nameservers.clear();
 
-#if defined(OS_MACOSX) || defined(OS_FREEBSD)
+#if defined(OS_MACOSX) || defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
   union res_sockaddr_union addresses[MAXNS];
   int nscount = res_getservers(const_cast<res_state>(&res), addresses, MAXNS);
   DCHECK_GE(nscount, 0);
@@ -488,7 +488,7 @@ ConfigParsePosixResult ConvertResStateToDnsConfig(const struct __res_state& res,
       return CONFIG_PARSE_POSIX_BAD_ADDRESS;
     dns_config->nameservers.push_back(ipe);
   }
-#else  // !(defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_FREEBSD))
+#else  // !(defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_FREEBSD)) || defined(OS_DRAGONFLY)
   DCHECK_LE(res.nscount, MAXNS);
   for (int i = 0; i < res.nscount; ++i) {
     IPEndPoint ipe;
@@ -499,7 +499,7 @@ ConfigParsePosixResult ConvertResStateToDnsConfig(const struct __res_state& res,
     }
     dns_config->nameservers.push_back(ipe);
   }
-#endif  // defined(OS_MACOSX) || defined(OS_FREEBSD)
+#endif  // defined(OS_MACOSX) || defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
 
   dns_config->search.clear();
   for (int i = 0; (i < MAXDNSRCH) && res.dnsrch[i]; ++i) {
diff --git net/dns/dns_config_service_posix_unittest.cc net/dns/dns_config_service_posix_unittest.cc
index 241663f054..bd3401c34e 100644
--- net/dns/dns_config_service_posix_unittest.cc
+++ net/dns/dns_config_service_posix_unittest.cc
@@ -2,8 +2,6 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include <resolv.h>
-
 #include <memory>
 
 #include "base/cancelable_callback.h"
diff --git net/dns/dns_reloader.cc net/dns/dns_reloader.cc
index ad96f681cc..d2f8e5ac82 100644
--- net/dns/dns_reloader.cc
+++ net/dns/dns_reloader.cc
@@ -7,6 +7,13 @@
 #if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_OPENBSD) && \
     !defined(OS_ANDROID) && !defined(OS_FUCHSIA)
 
+#if defined(OS_FREEBSD)
+#include <netinet/in.h>
+#endif
+
+#if defined(OS_DRAGONFLY)
+#include <netinet/in.h>
+#endif
 #include <resolv.h>
 
 #include "base/lazy_instance.h"
diff --git net/dns/dns_util.cc net/dns/dns_util.cc
index 6c45fe98d4..88f9a61c90 100644
--- net/dns/dns_util.cc
+++ net/dns/dns_util.cc
@@ -28,6 +28,8 @@ const int kMaxLabelLength = 63;
 
 }  // namespace
 
+#include <sys/socket.h>
+
 #if defined(OS_POSIX)
 #include <netinet/in.h>
 #if !defined(OS_NACL)
diff --git net/dns/host_resolver_proc.cc net/dns/host_resolver_proc.cc
index 4ced225bb5..64b38e5cf1 100644
--- net/dns/host_resolver_proc.cc
+++ net/dns/host_resolver_proc.cc
@@ -195,7 +195,7 @@ int SystemHostResolverCall(const std::string& host,
   // current process during that time.
   base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::WILL_BLOCK);
 
-#if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_OPENBSD) && \
+#if defined(OS_POSIX) && !defined(OS_MACOSX) && !defined(OS_BSD) && \
     !defined(OS_ANDROID) && !defined(OS_FUCHSIA)
   DnsReloaderMaybeReload();
 #endif
diff --git net/features.gni net/features.gni
index aaac9aab20..2498cedea6 100644
--- net/features.gni
+++ net/features.gni
@@ -27,7 +27,7 @@ declare_args() {
   disable_brotli_filter = false
 
   # Multicast DNS.
-  enable_mdns = is_win || is_linux
+  enable_mdns = is_win || is_linux || is_bsd
 
   # Reporting not used on iOS.
   enable_reporting = !is_ios
diff --git net/http/http_auth_gssapi_posix.cc net/http/http_auth_gssapi_posix.cc
index 2ca0859a0d..e55e15963b 100644
--- net/http/http_auth_gssapi_posix.cc
+++ net/http/http_auth_gssapi_posix.cc
@@ -431,8 +431,9 @@ base::NativeLibrary GSSAPISharedLibrary::LoadSharedLibrary() {
     static const char* const kDefaultLibraryNames[] = {
 #if defined(OS_MACOSX)
       "/System/Library/Frameworks/GSS.framework/GSS"
-#elif defined(OS_OPENBSD)
-      "libgssapi.so"          // Heimdal - OpenBSD
+#elif defined(OS_BSD)
+      "libgssapi_krb5.so.2",  // MIT Kerberos - FreeBSD
+      "libgssapi.so"          // Heimdal - OpenBSD, FreeBSD
 #else
       "libgssapi_krb5.so.2",  // MIT Kerberos - FC, Suse10, Debian
       "libgssapi.so.4",       // Heimdal - Suse10, MDK
diff --git net/http/http_network_session.cc net/http/http_network_session.cc
index 2e96c763d8..6e131fb7fb 100644
--- net/http/http_network_session.cc
+++ net/http/http_network_session.cc
@@ -20,7 +20,9 @@
 #include "base/trace_event/memory_dump_request_args.h"
 #include "base/trace_event/process_memory_dump.h"
 #include "base/values.h"
+#if defined(USE_KERBEROS)
 #include "net/http/http_auth_handler_factory.h"
+#endif
 #include "net/http/http_response_body_drainer.h"
 #include "net/http/http_stream_factory.h"
 #include "net/http/url_security_manager.h"
diff --git net/proxy_resolution/proxy_config_service_linux.cc net/proxy_resolution/proxy_config_service_linux.cc
index 86a195d5bb..45f79c8b37 100644
--- net/proxy_resolution/proxy_config_service_linux.cc
+++ net/proxy_resolution/proxy_config_service_linux.cc
@@ -6,7 +6,9 @@
 
 #include <errno.h>
 #include <limits.h>
+#if !defined(OS_BSD)
 #include <sys/inotify.h>
+#endif
 #include <unistd.h>
 
 #include <map>
@@ -493,6 +495,7 @@ int StringToIntOrDefault(base::StringPiece value, int default_value) {
   return default_value;
 }
 
+#if !defined(OS_BSD)
 // This is the KDE version that reads kioslaverc and simulates gsettings.
 // Doing this allows the main Delegate code, as well as the unit tests
 // for it, to stay the same - and the settings map fairly well besides.
@@ -982,6 +985,7 @@ class SettingGetterImplKDE : public ProxyConfigServiceLinux::SettingGetter {
 
   DISALLOW_COPY_AND_ASSIGN(SettingGetterImplKDE);
 };
+#endif
 
 }  // namespace
 
@@ -1197,8 +1201,10 @@ ProxyConfigServiceLinux::Delegate::Delegate(
     case base::nix::DESKTOP_ENVIRONMENT_KDE3:
     case base::nix::DESKTOP_ENVIRONMENT_KDE4:
     case base::nix::DESKTOP_ENVIRONMENT_KDE5:
+#if !defined(OS_BSD)
       setting_getter_.reset(new SettingGetterImplKDE(env_var_getter_.get()));
       break;
+#endif
     case base::nix::DESKTOP_ENVIRONMENT_XFCE:
     case base::nix::DESKTOP_ENVIRONMENT_OTHER:
       break;
diff --git net/proxy_resolution/proxy_resolution_service.cc net/proxy_resolution/proxy_resolution_service.cc
index 10a2d92cc8..717525d217 100644
--- net/proxy_resolution/proxy_resolution_service.cc
+++ net/proxy_resolution/proxy_resolution_service.cc
@@ -48,7 +48,7 @@
 #elif defined(OS_MACOSX)
 #include "net/proxy_resolution/proxy_config_service_mac.h"
 #include "net/proxy_resolution/proxy_resolver_mac.h"
-#elif defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#elif (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
 #include "net/proxy_resolution/proxy_config_service_linux.h"
 #elif defined(OS_ANDROID)
 #include "net/proxy_resolution/proxy_config_service_android.h"
@@ -62,7 +62,7 @@ namespace net {
 namespace {
 
 #if defined(OS_WIN) || defined(OS_IOS) || defined(OS_MACOSX) || \
-    (defined(OS_LINUX) && !defined(OS_CHROMEOS))
+    ((defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS))
 constexpr net::NetworkTrafficAnnotationTag kSystemProxyConfigTrafficAnnotation =
     net::DefineNetworkTrafficAnnotation("proxy_config_system", R"(
       semantics {
@@ -1536,7 +1536,7 @@ ProxyResolutionService::CreateSystemProxyConfigService(
              << "profile_io_data.cc::CreateProxyConfigService and this should "
              << "be used only for examples.";
   return std::make_unique<UnsetProxyConfigService>();
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   std::unique_ptr<ProxyConfigServiceLinux> linux_config_service(
       new ProxyConfigServiceLinux());
 
diff --git net/socket/socks5_client_socket.cc net/socket/socks5_client_socket.cc
index 784bcef533..e696ccf086 100644
--- net/socket/socks5_client_socket.cc
+++ net/socket/socks5_client_socket.cc
@@ -4,6 +4,10 @@
 
 #include "net/socket/socks5_client_socket.h"
 
+#if defined(OS_BSD)
+#include <netinet/in.h>
+#endif
+
 #include <utility>
 
 #include "base/callback_helpers.h"
diff --git net/socket/udp_socket_posix.cc net/socket/udp_socket_posix.cc
index 703a70057e..d72eb7eeb7 100644
--- net/socket/udp_socket_posix.cc
+++ net/socket/udp_socket_posix.cc
@@ -72,7 +72,7 @@ const int kActivityMonitorMinimumSamplesForThroughputEstimate = 2;
 const base::TimeDelta kActivityMonitorMsThreshold =
     base::TimeDelta::FromMilliseconds(100);
 
-#if defined(OS_MACOSX) || defined(OS_FUCHSIA)
+#if defined(OS_MACOSX) || defined(OS_FUCHSIA) || defined(OS_BSD)
 
 // When enabling multicast using setsockopt(IP_MULTICAST_IF) MacOS and Fuchsia
 // require passing IPv4 address instead of interface index. This function
@@ -656,7 +656,7 @@ int UDPSocketPosix::SetDoNotFragment() {
 }
 
 void UDPSocketPosix::SetMsgConfirm(bool confirm) {
-#if !defined(OS_MACOSX) && !defined(OS_IOS)
+#if !defined(OS_MACOSX) && !defined(OS_IOS) && !defined(OS_BSD)
   if (confirm) {
     sendto_flags_ |= MSG_CONFIRM;
   } else {
@@ -677,13 +677,16 @@ int UDPSocketPosix::SetBroadcast(bool broadcast) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   int value = broadcast ? 1 : 0;
   int rv;
-#if defined(OS_MACOSX)
+#if defined(OS_MACOSX) || defined(OS_BSD)
   // SO_REUSEPORT on OSX permits multiple processes to each receive
   // UDP multicast or broadcast datagrams destined for the bound
   // port.
   // This is only being set on OSX because its behavior is platform dependent
   // and we are playing it safe by only setting it on platforms where things
   // break.
+  rv = setsockopt(socket_, SOL_SOCKET, SO_REUSEADDR, &value, sizeof(value));
+  if (rv != 0)
+    return MapSystemError(errno);
   rv = setsockopt(socket_, SOL_SOCKET, SO_REUSEPORT, &value, sizeof(value));
   if (rv != 0)
     return MapSystemError(errno);
@@ -925,19 +928,24 @@ int UDPSocketPosix::SetMulticastOptions() {
   if (multicast_interface_ != 0) {
     switch (addr_family_) {
       case AF_INET: {
-#if defined(OS_MACOSX) || defined(OS_FUCHSIA)
+#if defined(OS_MACOSX) || defined(OS_FUCHSIA) || defined(OS_BSD)
         ip_mreq mreq;
         int error = GetIPv4AddressFromIndex(socket_, multicast_interface_,
                                             &mreq.imr_interface.s_addr);
         if (error != OK)
           return error;
-#else   //  defined(OS_MACOSX) || defined(OS_FUCHSIA)
+#else   //  defined(OS_MACOSX) || defined(OS_FUCHSIA) || defined(OS_BSD)
         ip_mreqn mreq;
         mreq.imr_ifindex = multicast_interface_;
         mreq.imr_address.s_addr = htonl(INADDR_ANY);
 #endif  //  !defined(OS_MACOSX) && !defined(OS_FUCHSIA)
         int rv = setsockopt(socket_, IPPROTO_IP, IP_MULTICAST_IF,
+#if defined(OS_BSD)
+                            reinterpret_cast<const char*>(&mreq.imr_interface.s_addr),
+                            sizeof(mreq.imr_interface.s_addr));
+#else
                             reinterpret_cast<const char*>(&mreq), sizeof(mreq));
+#endif
         if (rv)
           return MapSystemError(errno);
         break;
@@ -999,7 +1007,7 @@ int UDPSocketPosix::JoinGroup(const IPAddress& group_address) const {
       if (addr_family_ != AF_INET)
         return ERR_ADDRESS_INVALID;
 
-#if defined(OS_MACOSX) || defined(OS_FUCHSIA)
+#if defined(OS_MACOSX) || defined(OS_FUCHSIA) || defined(OS_BSD)
       ip_mreq mreq;
       int error = GetIPv4AddressFromIndex(socket_, multicast_interface_,
                                           &mreq.imr_interface.s_addr);
diff --git net/third_party/quic/platform/impl/quic_ip_address_impl.cc net/third_party/quic/platform/impl/quic_ip_address_impl.cc
index b2bc78a44e..5f6f8ba6d3 100644
--- net/third_party/quic/platform/impl/quic_ip_address_impl.cc
+++ net/third_party/quic/platform/impl/quic_ip_address_impl.cc
@@ -13,6 +13,7 @@
 #include <ws2bth.h>
 #elif defined(OS_POSIX) || defined(OS_FUCHSIA)
 #include <netinet/in.h>
+#include <sys/socket.h>
 #endif
 
 using std::string;
diff --git net/tools/cert_verify_tool/cert_verify_tool.cc net/tools/cert_verify_tool/cert_verify_tool.cc
index 1d912d7a2b..6350497e29 100644
--- net/tools/cert_verify_tool/cert_verify_tool.cc
+++ net/tools/cert_verify_tool/cert_verify_tool.cc
@@ -26,7 +26,7 @@
 #include "net/url_request/url_request_context_builder.h"
 #include "net/url_request/url_request_context_getter.h"
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include "net/proxy_resolution/proxy_config.h"
 #include "net/proxy_resolution/proxy_config_service_fixed.h"
 #endif
@@ -45,7 +45,7 @@ void SetUpOnNetworkThread(std::unique_ptr<net::URLRequestContext>* context,
                           base::WaitableEvent* initialization_complete_event) {
   net::URLRequestContextBuilder url_request_context_builder;
   url_request_context_builder.set_user_agent(GetUserAgent());
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // On Linux, use a fixed ProxyConfigService, since the default one
   // depends on glib.
   //
diff --git net/url_request/url_request_context_builder.cc net/url_request/url_request_context_builder.cc
index 0001308c7f..9bbcaeada6 100644
--- net/url_request/url_request_context_builder.cc
+++ net/url_request/url_request_context_builder.cc
@@ -503,7 +503,7 @@ std::unique_ptr<URLRequestContext> URLRequestContextBuilder::Build() {
   }
 
   if (!proxy_resolution_service_) {
-#if !defined(OS_LINUX) && !defined(OS_ANDROID)
+#if !defined(OS_LINUX) && !defined(OS_ANDROID) && !defined(OS_BSD)
     // TODO(willchan): Switch to using this code when
     // ProxyResolutionService::CreateSystemProxyConfigService()'s signature
     // doesn't suck.
diff --git pdf/pdfium/pdfium_engine.cc pdf/pdfium/pdfium_engine.cc
index dd69e01314..a47c070276 100644
--- pdf/pdfium/pdfium_engine.cc
+++ pdf/pdfium/pdfium_engine.cc
@@ -134,7 +134,7 @@ constexpr bool kIsEditModeTracked = false;
 
 PDFiumEngine* g_engine_for_fontmapper = nullptr;
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 
 PP_Instance g_last_instance_id;
 
@@ -651,7 +651,7 @@ bool InitializeSDK() {
   config.m_v8EmbedderSlot = gin::kEmbedderPDFium;
   FPDF_InitLibraryWithConfig(&config);
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // Font loading doesn't work in the renderer sandbox in Linux.
   FPDF_SetSystemFontInfo(&g_font_info);
 #else
@@ -676,7 +676,7 @@ bool InitializeSDK() {
 
 void ShutdownSDK() {
   FPDF_DestroyLibrary();
-#if !defined(OS_LINUX)
+#if !defined(OS_LINUX) && !defined(OS_BSD)
   delete g_font_info;
 #endif
   TearDownV8();
@@ -712,7 +712,7 @@ PDFiumEngine::PDFiumEngine(PDFEngine::Client* client, bool enable_javascript)
   IFSDK_PAUSE::user = nullptr;
   IFSDK_PAUSE::NeedToPauseNow = Pause_NeedToPauseNow;
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // PreviewModeClient does not know its pp::Instance.
   pp::Instance* instance = client_->GetPluginInstance();
   if (instance)
@@ -1226,7 +1226,7 @@ pp::Buffer_Dev PDFiumEngine::PrintPagesAsRasterPDF(
 
   KillFormFocus();
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   g_last_instance_id = client_->GetPluginInstance()->pp_instance();
 #endif
 
@@ -2924,7 +2924,7 @@ bool PDFiumEngine::ContinuePaint(int progressive_index,
   DCHECK(image_data);
 
   last_progressive_start_time_ = base::Time::Now();
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   g_last_instance_id = client_->GetPluginInstance()->pp_instance();
 #endif
 
@@ -3402,7 +3402,7 @@ void PDFiumEngine::SetCurrentPage(int index) {
     FORM_DoPageAAction(old_page, form(), FPDFPAGE_AACTION_CLOSE);
   }
   most_visible_page_ = index;
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   g_last_instance_id = client_->GetPluginInstance()->pp_instance();
 #endif
   if (most_visible_page_ != -1 && called_do_document_action_) {
diff --git ppapi/proxy/file_io_resource.cc ppapi/proxy/file_io_resource.cc
index 519389e9a4..e7045a4949 100644
--- ppapi/proxy/file_io_resource.cc
+++ ppapi/proxy/file_io_resource.cc
@@ -285,17 +285,19 @@ int32_t FileIOResource::Write(int64_t offset,
 
   if (check_quota_) {
     int64_t increase = 0;
-    uint64_t max_offset = 0;
+    uint64_t _max_offset = 0;
+    // (rene) avoid name collission with /usr/include/vm/vm_map.h on FreeBSD
+    // which also defines max_offset
     bool append = (open_flags_ & PP_FILEOPENFLAG_APPEND) != 0;
     if (append) {
       increase = bytes_to_write;
     } else {
-      uint64_t max_offset = offset + bytes_to_write;
-      if (max_offset >
+      uint64_t _max_offset = offset + bytes_to_write;
+      if (_max_offset >
           static_cast<uint64_t>(std::numeric_limits<int64_t>::max())) {
         return PP_ERROR_FAILED;  // amount calculation would overflow.
       }
-      increase = static_cast<int64_t>(max_offset) - max_written_offset_;
+      increase = static_cast<int64_t>(_max_offset) - max_written_offset_;
     }
 
     if (increase > 0) {
@@ -319,7 +321,7 @@ int32_t FileIOResource::Write(int64_t offset,
       if (append)
         append_mode_write_amount_ += bytes_to_write;
       else
-        max_written_offset_ = max_offset;
+        max_written_offset_ = _max_offset;
     }
   }
   return WriteValidated(offset, buffer, bytes_to_write, callback);
@@ -597,9 +599,9 @@ void FileIOResource::OnRequestWriteQuotaComplete(
   } else {
     DCHECK_LE(offset + bytes_to_write - max_written_offset_, granted);
 
-    int64_t max_offset = offset + bytes_to_write;
-    if (max_written_offset_ < max_offset)
-      max_written_offset_ = max_offset;
+    int64_t _max_offset = offset + bytes_to_write;
+    if (max_written_offset_ < _max_offset)
+      max_written_offset_ = _max_offset;
   }
 
   if (callback->is_blocking()) {
diff --git printing/backend/print_backend_cups.h printing/backend/print_backend_cups.h
index 173258fdd4..c4b2b9c382 100644
--- printing/backend/print_backend_cups.h
+++ printing/backend/print_backend_cups.h
@@ -5,6 +5,8 @@
 #ifndef PRINTING_BACKEND_PRINT_BACKEND_CUPS_H_
 #define PRINTING_BACKEND_PRINT_BACKEND_CUPS_H_
 
+#include <cups/ppd.h>
+
 #include <string>
 
 #include "base/files/file_util.h"
diff --git printing/cups_config_helper.py printing/cups_config_helper.py
index 48cb33376e..3c7544cd73 100755
--- printing/cups_config_helper.py
+++ printing/cups_config_helper.py
@@ -65,7 +65,7 @@ def main():
   mode = sys.argv[1]
   if len(sys.argv) > 2 and sys.argv[2]:
     sysroot = sys.argv[2]
-    cups_config = os.path.join(sysroot, 'usr', 'bin', 'cups-config')
+    cups_config = os.path.join(sysroot, 'bin', 'cups-config')
     if not os.path.exists(cups_config):
       print 'cups-config not found: %s' % cups_config
       return 1
diff --git remoting/base/chromoting_event.cc remoting/base/chromoting_event.cc
index 92c1625384..0083e9dd5a 100644
--- remoting/base/chromoting_event.cc
+++ remoting/base/chromoting_event.cc
@@ -186,7 +186,7 @@ void ChromotingEvent::AddSystemInfo() {
   SetString(kCpuKey, base::SysInfo::OperatingSystemArchitecture());
   SetString(kOsVersionKey, base::SysInfo::OperatingSystemVersion());
   SetString(kWebAppVersionKey, STRINGIZE(VERSION));
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   Os os = Os::CHROMOTING_LINUX;
 #elif defined(OS_CHROMEOS)
   Os os = Os::CHROMOTING_CHROMEOS;
diff --git remoting/client/display/sys_opengl.h remoting/client/display/sys_opengl.h
index 90abd6be0b..bd345fa965 100644
--- remoting/client/display/sys_opengl.h
+++ remoting/client/display/sys_opengl.h
@@ -9,7 +9,7 @@
 
 #if defined(OS_IOS)
 #include <OpenGLES/ES3/gl.h>
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
 #define GL_GLEXT_PROTOTYPES
 #include <GL/gl.h>
 #include <GL/glext.h>
diff --git remoting/host/host_details.cc remoting/host/host_details.cc
index 43493429d8..6407f3d2ed 100644
--- remoting/host/host_details.cc
+++ remoting/host/host_details.cc
@@ -22,7 +22,7 @@ std::string GetHostOperatingSystemName() {
   return "Mac";
 #elif defined(OS_CHROMEOS)
   return "ChromeOS";
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   return "Linux";
 #elif defined(OS_ANDROID)
   return "Android";
diff --git remoting/host/it2me/it2me_native_messaging_host_main.cc remoting/host/it2me/it2me_native_messaging_host_main.cc
index 43d4f8852c..26282ad999 100644
--- remoting/host/it2me/it2me_native_messaging_host_main.cc
+++ remoting/host/it2me/it2me_native_messaging_host_main.cc
@@ -25,7 +25,7 @@
 #include "remoting/host/resources.h"
 #include "remoting/host/usage_stats_consent.h"
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include <gtk/gtk.h>
 
 #include "base/linux_util.h"
@@ -102,7 +102,7 @@ int It2MeNativeMessagingHostMain(int argc, char** argv) {
 
   remoting::LoadResources("");
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // Required in order for us to run multiple X11 threads.
   XInitThreads();
 
diff --git remoting/host/me2me_desktop_environment.cc remoting/host/me2me_desktop_environment.cc
index 5089be8e9d..62cb48c7ea 100644
--- remoting/host/me2me_desktop_environment.cc
+++ remoting/host/me2me_desktop_environment.cc
@@ -107,7 +107,7 @@ bool Me2MeDesktopEnvironment::InitializeSecurity(
 
   // Otherwise, if the session is shared with the local user start monitoring
   // the local input and create the in-session UI.
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   bool want_user_interface = false;
 #elif defined(OS_MACOSX)
   // Don't try to display any UI on top of the system's login screen as this
diff --git remoting/host/remoting_me2me_host.cc remoting/host/remoting_me2me_host.cc
index 771c4e62d9..a3f94ca51d 100644
--- remoting/host/remoting_me2me_host.cc
+++ remoting/host/remoting_me2me_host.cc
@@ -115,13 +115,13 @@
 #include "base/mac/scoped_cftyperef.h"
 #endif  // defined(OS_MACOSX)
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include <gtk/gtk.h>
 #include "base/linux_util.h"
 #include "remoting/host/audio_capturer_linux.h"
 #include "remoting/host/linux/certificate_watcher.h"
 #include "ui/gfx/x/x11.h"
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
 
 #if defined(OS_WIN)
 #include <commctrl.h>
@@ -156,11 +156,11 @@ const char kApplicationName[] = "chromoting";
 const char kStdinConfigPath[] = "-";
 #endif  // !defined(REMOTING_MULTI_PROCESS)
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 // The command line switch used to pass name of the pipe to capture audio on
 // linux.
 const char kAudioPipeSwitchName[] = "audio-pipe-name";
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
 
 #if defined(OS_POSIX)
 // The command line switch used to pass name of the unix domain socket used to
@@ -351,7 +351,7 @@ class HostProcess : public ConfigWatcher::Delegate,
 
   std::unique_ptr<ChromotingHostContext> context_;
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // Watch for certificate changes and kill the host when changes occur
   std::unique_ptr<CertificateWatcher> cert_watcher_;
 #endif
@@ -565,10 +565,10 @@ bool HostProcess::InitWithCommandLine(const base::CommandLine* cmd_line) {
   enable_window_capture_ = cmd_line->HasSwitch(kWindowIdSwitchName);
   if (enable_window_capture_) {
 
-#if defined(OS_LINUX) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_WIN) || defined(OS_BSD)
     LOG(WARNING) << "Window capturing is not fully supported on Linux or "
                     "Windows.";
-#endif  // defined(OS_LINUX) || defined(OS_WIN)
+#endif  // defined(OS_LINUX) || defined(OS_WIN) || defined(OS_BSD)
 
     // uint32_t is large enough to hold window IDs on all platforms.
     uint32_t window_id;
@@ -761,7 +761,7 @@ void HostProcess::CreateAuthenticatorFactory() {
     DCHECK(third_party_auth_config_.token_url.is_valid());
     DCHECK(third_party_auth_config_.token_validation_url.is_valid());
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     if (!cert_watcher_) {
       cert_watcher_.reset(new CertificateWatcher(
           base::Bind(&HostProcess::ShutdownHost, this, kSuccessExitCode),
@@ -847,7 +847,7 @@ void HostProcess::StartOnUiThread() {
       base::Bind(&HostProcess::OnPolicyUpdate, base::Unretained(this)),
       base::Bind(&HostProcess::OnPolicyError, base::Unretained(this)));
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // If an audio pipe is specific on the command-line then initialize
   // AudioCapturerLinux to capture from it.
   base::FilePath audio_pipe_name = base::CommandLine::ForCurrentProcess()->
@@ -856,7 +856,7 @@ void HostProcess::StartOnUiThread() {
     remoting::AudioCapturerLinux::InitializePipeReader(
         context_->audio_task_runner(), audio_pipe_name);
   }
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
 
 #if defined(OS_POSIX)
   base::FilePath security_key_socket_name =
@@ -914,7 +914,7 @@ void HostProcess::ShutdownOnUiThread() {
   // It is now safe for the HostProcess to be deleted.
   self_ = nullptr;
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // Cause the global AudioPipeReader to be freed, otherwise the audio
   // thread will remain in-use and prevent the process from exiting.
   // TODO(wez): DesktopEnvironmentFactory should own the pipe reader.
@@ -1546,7 +1546,7 @@ void HostProcess::StartHost() {
   host_->AddExtension(std::make_unique<TestEchoExtension>());
 
   // TODO(simonmorris): Get the maximum session duration from a policy.
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   host_->SetMaximumSessionDuration(base::TimeDelta::FromHours(20));
 #endif
 
@@ -1705,7 +1705,7 @@ void HostProcess::OnCrash(const std::string& function_name,
 int HostProcessMain() {
   HOST_LOG << "Starting host process: version " << STRINGIZE(VERSION);
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   if (!base::CommandLine::ForCurrentProcess()->HasSwitch(
           kReportOfflineReasonSwitchName)) {
     // Required in order for us to run multiple X11 threads.
diff --git remoting/webapp/base/js/platform.js remoting/webapp/base/js/platform.js
index 8865c099a3..d0588efb23 100644
--- remoting/webapp/base/js/platform.js
+++ remoting/webapp/base/js/platform.js
@@ -107,6 +107,14 @@ remoting.getSystemInfo = function() {
     return result;
   }
 
+  match = new RegExp('FreeBSD ([a-zA-Z0-9_]*)').exec(userAgent);
+  if (match && (match.length >= 2)) {
+    result.osName = remoting.Os.LINUX;
+    result.osVersion = '';
+    result.cpu = match[1];
+    return result;
+  }
+
   match = new RegExp('([a-zA-Z]*) Mac OS X ([0-9_]*)').exec(userAgent);
   if (match && (match.length >= 3)) {
     result.osName = remoting.Os.MAC;
diff --git sandbox/BUILD.gn sandbox/BUILD.gn
index c60d5f8222..8e105b7b22 100644
--- sandbox/BUILD.gn
+++ sandbox/BUILD.gn
@@ -26,7 +26,7 @@ group("sandbox") {
       "//sandbox/mac:seatbelt_extension",
       "//sandbox/mac/mojom",
     ]
-  } else if (is_linux || is_android) {
+  } else if ((is_linux && !is_bsd) || is_android) {
     public_deps = [
       "//sandbox/linux:sandbox",
     ]
diff --git sandbox/features.gni sandbox/features.gni
index 89693c54c4..1451b79460 100644
--- sandbox/features.gni
+++ sandbox/features.gni
@@ -12,6 +12,6 @@ use_seccomp_bpf =
     (is_linux || is_android) &&
     (current_cpu == "x86" || current_cpu == "x64" || current_cpu == "arm" ||
      current_cpu == "arm64" || current_cpu == "mipsel" ||
-     current_cpu == "mips64el")
+     current_cpu == "mips64el") && !is_bsd
 
 use_seccomp_bpf = use_seccomp_bpf || is_nacl_nonsfi
diff --git sandbox/linux/BUILD.gn sandbox/linux/BUILD.gn
index b409fd6c4d..802294dcc2 100644
--- sandbox/linux/BUILD.gn
+++ sandbox/linux/BUILD.gn
@@ -12,12 +12,12 @@ if (is_android) {
 }
 
 declare_args() {
-  compile_suid_client = is_linux
+  compile_suid_client = is_linux && !is_bsd
 
-  compile_credentials = is_linux
+  compile_credentials = is_linux && !is_bsd
 
   # On Android, use plain GTest.
-  use_base_test_suite = is_linux
+  use_base_test_suite = is_linux && !is_bsd
 }
 
 if (is_nacl_nonsfi) {
@@ -399,7 +399,7 @@ component("sandbox_services") {
     public_deps += [ ":sandbox_services_headers" ]
   }
 
-  if (is_nacl_nonsfi) {
+  if (is_nacl_nonsfi || is_bsd) {
     cflags = [ "-fgnu-inline-asm" ]
 
     sources -= [
@@ -407,6 +407,8 @@ component("sandbox_services") {
       "services/init_process_reaper.h",
       "services/scoped_process.cc",
       "services/scoped_process.h",
+      "services/syscall_wrappers.cc",
+      "services/syscall_wrappers.h",
       "services/yama.cc",
       "services/yama.h",
       "syscall_broker/broker_channel.cc",
@@ -426,6 +428,10 @@ component("sandbox_services") {
       "syscall_broker/broker_simple_message.cc",
       "syscall_broker/broker_simple_message.h",
     ]
+    sources += [
+      "services/libc_interceptor.cc",
+      "services/libc_interceptor.h",
+    ]
   } else if (!is_android) {
     sources += [
       "services/libc_interceptor.cc",
diff --git sandbox/linux/services/init_process_reaper.cc sandbox/linux/services/init_process_reaper.cc
index 112fa0a321..5409ffca04 100644
--- sandbox/linux/services/init_process_reaper.cc
+++ sandbox/linux/services/init_process_reaper.cc
@@ -1,6 +1,7 @@
 // Copyright 2013 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#if 0
 
 #include "sandbox/linux/services/init_process_reaper.h"
 
@@ -100,3 +101,4 @@ bool CreateInitProcessReaper(base::OnceClosure post_fork_parent_callback) {
 }
 
 }  // namespace sandbox.
+#endif
diff --git sandbox/linux/services/libc_interceptor.cc sandbox/linux/services/libc_interceptor.cc
index 906e1caf8a..f9ce4ffbf7 100644
--- sandbox/linux/services/libc_interceptor.cc
+++ sandbox/linux/services/libc_interceptor.cc
@@ -11,7 +11,9 @@
 #include <stddef.h>
 #include <stdint.h>
 #include <string.h>
+#if !defined(OS_BSD)
 #include <sys/prctl.h>
+#endif
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <time.h>
@@ -94,7 +96,7 @@ bool ReadTimeStruct(base::PickleIterator* iter,
   } else {
     base::AutoLock lock(g_timezones_lock.Get());
     auto ret_pair = g_timezones.Get().insert(timezone);
-    output->tm_zone = ret_pair.first->c_str();
+    output->tm_zone = (char *)ret_pair.first->c_str();
   }
 
   return true;
diff --git services/catalog/public/cpp/manifest_parsing_util.cc services/catalog/public/cpp/manifest_parsing_util.cc
index 4a19ec6fb5..17a6811c50 100644
--- services/catalog/public/cpp/manifest_parsing_util.cc
+++ services/catalog/public/cpp/manifest_parsing_util.cc
@@ -17,7 +17,8 @@ bool IsValidPlatformName(const std::string& name) {
          name == Store::kRequiredFilesKey_PlatformValue_Linux ||
          name == Store::kRequiredFilesKey_PlatformValue_MacOSX ||
          name == Store::kRequiredFilesKey_PlatformValue_Android ||
-         name == Store::kRequiredFilesKey_PlatformValue_Fuchsia;
+         name == Store::kRequiredFilesKey_PlatformValue_Fuchsia ||
+         name == Store::kRequiredFilesKey_PlatformValue_FreeBSD;
 }
 
 bool IsCurrentPlatform(const std::string& name) {
@@ -31,6 +32,8 @@ bool IsCurrentPlatform(const std::string& name) {
   return name == Store::kRequiredFilesKey_PlatformValue_Android;
 #elif defined(OS_FUCHSIA)
   return name == Store::kRequiredFilesKey_PlatformValue_Fuchsia;
+#elif defined(OS_BSD)
+  return name == Store::kRequiredFilesKey_PlatformValue_FreeBSD;
 #else
 #error This architecture is not supported.
 #endif
diff --git services/catalog/store.cc services/catalog/store.cc
index f59e6d8fbc..91f22be1f6 100644
--- services/catalog/store.cc
+++ services/catalog/store.cc
@@ -36,5 +36,7 @@ const char Store::kRequiredFilesKey_PlatformValue_MacOSX[] = "macosx";
 const char Store::kRequiredFilesKey_PlatformValue_Android[] = "android";
 // static
 const char Store::kRequiredFilesKey_PlatformValue_Fuchsia[] = "fuchsia";
+// static
+const char Store::kRequiredFilesKey_PlatformValue_FreeBSD[] = "freebsd";
 
 }  // namespace catalog
diff --git services/catalog/store.h services/catalog/store.h
index 831ee9fb91..ebc18c88ed 100644
--- services/catalog/store.h
+++ services/catalog/store.h
@@ -36,6 +36,7 @@ class Store {
   static const char kRequiredFilesKey_PlatformValue_MacOSX[];
   static const char kRequiredFilesKey_PlatformValue_Android[];
   static const char kRequiredFilesKey_PlatformValue_Fuchsia[];
+  static const char kRequiredFilesKey_PlatformValue_FreeBSD[];
 };
 
 }  // namespace catalog
diff --git services/device/hid/BUILD.gn services/device/hid/BUILD.gn
index 2725e6e84c..5abcdbaca1 100644
--- services/device/hid/BUILD.gn
+++ services/device/hid/BUILD.gn
@@ -51,6 +51,19 @@ source_set("hid") {
     deps += [ "//device/udev_linux" ]
   }
 
+  if (is_bsd) {
+    sources -= [
+      "hid_connection_linux.cc",
+      "hid_connection_linux.h",
+    ]
+    sources += [
+      "hid_connection_freebsd.cc",
+      "hid_connection_freebsd.h",
+      "hid_service_freebsd.cc",
+      "hid_service_freebsd.h",
+    ]
+  }
+
   if (is_chromeos) {
     deps += [ "//chromeos" ]
   }
diff --git services/device/hid/hid_connection_freebsd.cc services/device/hid/hid_connection_freebsd.cc
new file mode 100644
index 0000000000..7792e018f0
--- /dev/null
+++ services/device/hid/hid_connection_freebsd.cc
@@ -0,0 +1,282 @@
+// Copyright (c) 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/device/hid/hid_connection_freebsd.h"
+
+#if defined(OS_FREEBSD)
+#include <dev/usb/usbhid.h>
+#include <dev/usb/usb_ioctl.h>
+#else
+#include <bus/u4b/usbhid.h>
+#include <bus/u4b/usb_ioctl.h>
+#endif
+
+#include "base/bind.h"
+#include "base/files/file_descriptor_watcher_posix.h"
+#include "base/location.h"
+#include "base/numerics/safe_math.h"
+#include "base/posix/eintr_wrapper.h"
+#include "base/single_thread_task_runner.h"
+#include "base/strings/stringprintf.h"
+#include "base/task_scheduler/post_task.h"
+#include "base/threading/thread_restrictions.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "components/device_event_log/device_event_log.h"
+#include "services/device/hid/hid_service.h"
+
+namespace device {
+
+class HidConnectionFreeBSD::BlockingTaskHelper {
+ public:
+  BlockingTaskHelper(base::ScopedFD fd,
+                     scoped_refptr<HidDeviceInfo> device_info,
+                     base::WeakPtr<HidConnectionFreeBSD> connection)
+      : fd_(std::move(fd)),
+        connection_(connection),
+        origin_task_runner_(base::ThreadTaskRunnerHandle::Get()) {
+    DETACH_FROM_SEQUENCE(sequence_checker_);
+    // Report buffers must always have room for the report ID.
+    report_buffer_size_ = device_info->max_input_report_size() + 1;
+    has_report_id_ = device_info->has_report_id();
+  }
+
+  ~BlockingTaskHelper() { DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_); }
+
+  // Starts the FileDescriptorWatcher that reads input events from the device.
+  // Must be called on a thread that has a base::MessageLoopForIO.
+  void Start() {
+    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+    base::AssertBlockingAllowed();
+
+    file_watcher_ = base::FileDescriptorWatcher::WatchReadable(
+        fd_.get(), base::Bind(&BlockingTaskHelper::OnFileCanReadWithoutBlocking,
+                              base::Unretained(this)));
+  }
+
+  void Write(scoped_refptr<base::RefCountedBytes> buffer,
+             WriteCallback callback) {
+    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+    auto data = buffer->front();
+    size_t size = buffer->size();
+    // if report id is 0, it shouldn't be included
+    if (data[0] == 0) {
+      data++;
+      size--;
+    }
+
+    ssize_t result = HANDLE_EINTR(write(fd_.get(), data, size));
+    if (result < 0) {
+      HID_PLOG(EVENT) << "Write failed";
+      origin_task_runner_->PostTask(FROM_HERE, base::BindOnce(std::move(callback), false));
+    } else {
+      if (static_cast<size_t>(result) != size)
+        HID_LOG(EVENT) << "Incomplete HID write: " << result << " != " << size;
+      origin_task_runner_->PostTask(FROM_HERE, base::BindOnce(std::move(callback), true));
+    }
+  }
+
+  void GetFeatureReport(uint8_t report_id,
+                        scoped_refptr<base::RefCountedBytes> buffer,
+                        ReadCallback callback) {
+    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+    struct usb_gen_descriptor ugd;
+    ugd.ugd_report_type = UHID_FEATURE_REPORT;
+    ugd.ugd_data = buffer->front();
+    ugd.ugd_maxlen = buffer->size();
+    int result = HANDLE_EINTR(
+        ioctl(fd_.get(), USB_GET_REPORT, &ugd));
+    if (result < 0) {
+      HID_PLOG(EVENT) << "Failed to get feature report";
+      origin_task_runner_->PostTask(FROM_HERE,
+                                    base::BindOnce(std::move(callback), false, nullptr, 0));
+    } else if (result == 0) {
+      HID_LOG(EVENT) << "Get feature result too short.";
+      origin_task_runner_->PostTask(FROM_HERE,
+                                    base::BindOnce(std::move(callback), false, nullptr, 0));
+    } else {
+      origin_task_runner_->PostTask(FROM_HERE,
+                                    base::BindOnce(std::move(callback), true, buffer, result));
+    }
+  }
+
+  void SendFeatureReport(scoped_refptr<base::RefCountedBytes> buffer,
+                         WriteCallback callback) {
+    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+    struct usb_gen_descriptor ugd;
+    ugd.ugd_report_type = UHID_FEATURE_REPORT;
+    ugd.ugd_data = buffer->front();
+    ugd.ugd_maxlen = buffer->size();
+    // FreeBSD does not require report id if it's not used
+    if (buffer->front()[0] == 0) {
+      ugd.ugd_data = buffer->front() + 1;
+      ugd.ugd_maxlen = buffer->size() - 1;
+    } else {
+      ugd.ugd_data = buffer->front();
+      ugd.ugd_maxlen = buffer->size();
+    }
+    int result = HANDLE_EINTR(
+        ioctl(fd_.get(), USB_SET_REPORT, &ugd));
+    if (result < 0) {
+      HID_PLOG(EVENT) << "Failed to send feature report";
+      origin_task_runner_->PostTask(FROM_HERE,
+                                    base::BindOnce(std::move(callback), false));
+    } else {
+      origin_task_runner_->PostTask(FROM_HERE,
+                                    base::BindOnce(std::move(callback), true));
+    }
+  }
+
+ private:
+  void OnFileCanReadWithoutBlocking() {
+    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+
+    scoped_refptr<base::RefCountedBytes> buffer(new base::RefCountedBytes(report_buffer_size_));
+    unsigned char* data = buffer->front();
+    size_t length = report_buffer_size_;
+    if (!has_report_id_) {
+      // FreeBSD will not prefix the buffer with a report ID if report IDs are not
+      // used by the device. Prefix the buffer with 0.
+      *data++ = 0;
+      length--;
+    }
+
+    ssize_t bytes_read = HANDLE_EINTR(read(fd_.get(), data, length));
+    if (bytes_read < 0) {
+      if (errno != EAGAIN) {
+        HID_PLOG(EVENT) << "Read failed";
+        // This assumes that the error is unrecoverable and disables reading
+        // from the device until it has been re-opened.
+        // TODO(reillyg): Investigate starting and stopping the file descriptor
+        // watcher in response to pending read requests so that per-request
+        // errors can be returned to the client.
+        file_watcher_.reset();
+      }
+      return;
+    }
+    if (!has_report_id_) {
+      // Behave as if the byte prefixed above as the the report ID was read.
+      bytes_read++;
+    }
+
+    origin_task_runner_->PostTask(
+        FROM_HERE, base::BindOnce(&HidConnectionFreeBSD::ProcessInputReport,
+                              connection_, buffer, bytes_read));
+  }
+
+  SEQUENCE_CHECKER(sequence_checker_);
+  base::ScopedFD fd_;
+  size_t report_buffer_size_;
+  bool has_report_id_;
+  base::WeakPtr<HidConnectionFreeBSD> connection_;
+  const scoped_refptr<base::SequencedTaskRunner> origin_task_runner_;
+  std::unique_ptr<base::FileDescriptorWatcher::Controller> file_watcher_;
+
+  DISALLOW_COPY_AND_ASSIGN(BlockingTaskHelper);
+};
+
+HidConnectionFreeBSD::HidConnectionFreeBSD(
+    scoped_refptr<HidDeviceInfo> device_info,
+    base::ScopedFD fd,
+    scoped_refptr<base::SequencedTaskRunner> blocking_task_runner)
+    : HidConnection(device_info),
+      blocking_task_runner_(std::move(blocking_task_runner)),
+      weak_factory_(this) {
+  helper_ = std::make_unique<BlockingTaskHelper>(std::move(fd), device_info,
+                                                 weak_factory_.GetWeakPtr());
+  blocking_task_runner_->PostTask(
+      FROM_HERE, base::BindOnce(&BlockingTaskHelper::Start,
+                                base::Unretained(helper_.get())));
+}
+
+HidConnectionFreeBSD::~HidConnectionFreeBSD() {}
+
+void HidConnectionFreeBSD::PlatformClose() {
+  // By closing the device on the blocking task runner 1) the requirement that
+  // base::ScopedFD is destroyed on a thread where I/O is allowed is satisfied
+  // and 2) any tasks posted to this task runner that refer to this file will
+  // complete before it is closed.
+  blocking_task_runner_->DeleteSoon(FROM_HERE, helper_.release());
+
+  while (!pending_reads_.empty()) {
+    std::move(pending_reads_.front().callback).Run(false, NULL, 0);
+    pending_reads_.pop();
+  }
+}
+
+void HidConnectionFreeBSD::PlatformRead(ReadCallback callback) {
+  PendingHidRead pending_read;
+  pending_read.callback = std::move(callback);
+  pending_reads_.push(std::move(pending_read));
+  ProcessReadQueue();
+}
+
+void HidConnectionFreeBSD::PlatformWrite(scoped_refptr<base::RefCountedBytes> buffer,
+                                     WriteCallback callback) {
+
+  blocking_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&BlockingTaskHelper::Write, base::Unretained(helper_.get()),
+                 buffer, std::move(callback)));
+}
+
+void HidConnectionFreeBSD::PlatformGetFeatureReport(uint8_t report_id,
+                                                ReadCallback callback) {
+  // The first byte of the destination buffer is the report ID being requested
+  // and is overwritten by the feature report.
+  DCHECK_GT(device_info()->max_feature_report_size(), 0u);
+  scoped_refptr<base::RefCountedBytes> buffer(
+      new base::RefCountedBytes(device_info()->max_feature_report_size() + 1));
+  if (report_id != 0)
+    buffer->data()[0] = report_id;
+
+  blocking_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&BlockingTaskHelper::GetFeatureReport,
+                 base::Unretained(helper_.get()), report_id,
+                 buffer, std::move(callback)));
+}
+
+void HidConnectionFreeBSD::PlatformSendFeatureReport(
+    scoped_refptr<base::RefCountedBytes> buffer,
+    WriteCallback callback) {
+  blocking_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(&BlockingTaskHelper::SendFeatureReport,
+                 base::Unretained(helper_.get()), buffer, std::move(callback)));
+}
+
+void HidConnectionFreeBSD::ProcessInputReport(
+    scoped_refptr<base::RefCountedBytes> buffer,
+    size_t size) {
+  DCHECK(thread_checker().CalledOnValidThread());
+  DCHECK_GE(size, 1u);
+
+  uint8_t report_id = buffer->data()[0];
+  if (IsReportIdProtected(report_id))
+    return;
+
+  PendingHidReport report;
+  report.buffer = buffer;
+  report.size = size;
+  pending_reports_.push(report);
+  ProcessReadQueue();
+}
+
+void HidConnectionFreeBSD::ProcessReadQueue() {
+  DCHECK(thread_checker().CalledOnValidThread());
+
+  // Hold a reference to |this| to prevent a callback from freeing this object
+  // during the loop.
+  scoped_refptr<HidConnectionFreeBSD> self(this);
+  while (pending_reads_.size() && pending_reports_.size()) {
+    PendingHidRead read = std::move(pending_reads_.front());
+    PendingHidReport report = std::move(pending_reports_.front());
+
+    pending_reads_.pop();
+    pending_reports_.pop();
+    std::move(read.callback).Run(true, std::move(report.buffer), report.size);
+  }
+}
+
+}  // namespace device
diff --git services/device/hid/hid_connection_freebsd.h services/device/hid/hid_connection_freebsd.h
new file mode 100644
index 0000000000..c3efa021c7
--- /dev/null
+++ services/device/hid/hid_connection_freebsd.h
@@ -0,0 +1,77 @@
+// Copyright (c) 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef DEVICE_HID_HID_CONNECTION_FREEBSD_H_
+#define DEVICE_HID_HID_CONNECTION_FREEBSD_H_
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <queue>
+
+#include "base/files/scoped_file.h"
+#include "base/macros.h"
+#include "base/memory/ptr_util.h"
+#include "base/memory/ref_counted_memory.h"
+#include "base/memory/weak_ptr.h"
+#include "base/sequence_checker.h"
+#include "services/device/hid/hid_connection.h"
+
+namespace base {
+class SequencedTaskRunner;
+}
+
+namespace net {
+class IOBuffer;
+}
+
+namespace device {
+
+class HidConnectionFreeBSD : public HidConnection {
+ public:
+  HidConnectionFreeBSD(
+      scoped_refptr<HidDeviceInfo> device_info,
+      base::ScopedFD fd,
+      scoped_refptr<base::SequencedTaskRunner> blocking_task_runner);
+
+ private:
+  friend class base::RefCountedThreadSafe<HidConnectionFreeBSD>;
+  class BlockingTaskHelper;
+
+  ~HidConnectionFreeBSD() override;
+
+  // HidConnection implementation.
+  void PlatformClose() override;
+  void PlatformRead(ReadCallback callback) override;
+  void PlatformWrite(scoped_refptr<base::RefCountedBytes> buffer,
+                     WriteCallback callback) override;
+  void PlatformGetFeatureReport(uint8_t report_id,
+                                ReadCallback callback) override;
+  void PlatformSendFeatureReport(scoped_refptr<base::RefCountedBytes> buffer,
+                                 WriteCallback callback) override;
+  void ProcessInputReport(scoped_refptr<base::RefCountedBytes> buffer,
+                          size_t size);
+  void ProcessReadQueue();
+
+  // |helper_| lives on the sequence to which |blocking_task_runner_| posts
+  // tasks so all calls must be posted there including this object's
+  // destruction.
+  std::unique_ptr<BlockingTaskHelper> helper_;
+
+  const scoped_refptr<base::SequencedTaskRunner> blocking_task_runner_;
+
+  std::queue<PendingHidReport> pending_reports_;
+  std::queue<PendingHidRead> pending_reads_;
+  const scoped_refptr<base::SequencedTaskRunner> task_runner_;
+
+  SEQUENCE_CHECKER(sequence_checker_);
+
+  base::WeakPtrFactory<HidConnectionFreeBSD> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(HidConnectionFreeBSD);
+};
+
+}  // namespace device
+
+#endif  // DEVICE_HID_HID_CONNECTION_FREEBSD_H_
diff --git services/device/hid/hid_service.cc services/device/hid/hid_service.cc
index 5a4ad95e7e..10d8e4eb92 100644
--- services/device/hid/hid_service.cc
+++ services/device/hid/hid_service.cc
@@ -16,6 +16,8 @@
 
 #if defined(OS_LINUX) && defined(USE_UDEV)
 #include "services/device/hid/hid_service_linux.h"
+#elif defined(OS_BSD)
+#include "services/device/hid/hid_service_freebsd.h"
 #elif defined(OS_MACOSX)
 #include "services/device/hid/hid_service_mac.h"
 #elif defined(OS_WIN)
@@ -36,6 +38,8 @@ constexpr base::TaskTraits HidService::kBlockingTaskTraits;
 std::unique_ptr<HidService> HidService::Create() {
 #if defined(OS_LINUX) && defined(USE_UDEV)
   return base::WrapUnique(new HidServiceLinux());
+#elif defined(OS_BSD)
+  return base::WrapUnique(new HidServiceFreeBSD());
 #elif defined(OS_MACOSX)
   return base::WrapUnique(new HidServiceMac());
 #elif defined(OS_WIN)
diff --git services/device/hid/hid_service_freebsd.cc services/device/hid/hid_service_freebsd.cc
new file mode 100644
index 0000000000..e2def597d3
--- /dev/null
+++ services/device/hid/hid_service_freebsd.cc
@@ -0,0 +1,376 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/device/hid/hid_service_freebsd.h"
+
+#if defined(OS_FREEBSD)
+#include <dev/usb/usb_ioctl.h>
+#else
+#include <bus/u4b/usb_ioctl.h>
+#endif
+
+#include <stdint.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/bind.h"
+#include "base/files/file_descriptor_watcher_posix.h"
+#include "base/files/file_enumerator.h"
+#include "base/location.h"
+#include "base/logging.h"
+#include "base/posix/eintr_wrapper.h"
+#include "base/single_thread_task_runner.h"
+#include "base/stl_util.h"
+#include "base/strings/pattern.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/sys_string_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/strings/string_split.h"
+#include "base/task_scheduler/post_task.h"
+#include "base/threading/thread_restrictions.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "components/device_event_log/device_event_log.h"
+#include "services/device/hid/hid_connection_freebsd.h"
+
+const int kMaxPermissionChecks = 5;
+
+namespace device {
+
+struct HidServiceFreeBSD::ConnectParams {
+  ConnectParams(scoped_refptr<HidDeviceInfo> device_info,
+                const ConnectCallback& callback)
+      : device_info(std::move(device_info)),
+        callback(callback),
+        task_runner(base::ThreadTaskRunnerHandle::Get()),
+        blocking_task_runner(
+            base::CreateSequencedTaskRunnerWithTraits(kBlockingTaskTraits)) {}
+  ~ConnectParams() {}
+
+  scoped_refptr<HidDeviceInfo> device_info;
+  ConnectCallback callback;
+  scoped_refptr<base::SequencedTaskRunner> task_runner;
+  scoped_refptr<base::SequencedTaskRunner> blocking_task_runner;
+  base::ScopedFD fd;
+};
+
+class HidServiceFreeBSD::BlockingTaskHelper {
+ public:
+  BlockingTaskHelper(base::WeakPtr<HidServiceFreeBSD> service)
+      : service_(std::move(service)),
+        task_runner_(base::ThreadTaskRunnerHandle::Get()) {
+    DETACH_FROM_SEQUENCE(sequence_checker_);
+
+    timer_.reset(new base::RepeatingTimer());
+    devd_buffer_ = new net::IOBufferWithSize(1024);
+  }
+
+  ~BlockingTaskHelper() {
+  }
+
+  void Start() {
+    base::AssertBlockingAllowed();
+    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+
+    const base::FilePath kDevRoot("/dev");
+    const std::string kUHIDPattern("/dev/uhid*");
+
+    base::FileEnumerator enumerator(kDevRoot, false, base::FileEnumerator::FILES);
+    do {
+      const base::FilePath next_device_path(enumerator.Next());
+      const std::string next_device = next_device_path.value();
+      if (next_device.empty())
+        break;
+
+      if (base::MatchPattern(next_device, kUHIDPattern))
+        OnDeviceAdded(next_device.substr(5));
+    } while (true);
+
+    SetupDevdMonitor();
+
+    task_runner_->PostTask(
+        FROM_HERE,
+        base::Bind(&HidServiceFreeBSD::FirstEnumerationComplete, service_));
+  }
+
+  bool HaveReadWritePermissions(std::string device_id) {
+    std::string device_node = "/dev/" + device_id;
+    base::AssertBlockingAllowed();
+
+    base::FilePath device_path(device_node);
+    base::File device_file;
+    int flags =
+        base::File::FLAG_OPEN | base::File::FLAG_READ | base::File::FLAG_WRITE;
+    device_file.Initialize(device_path, flags);
+    if (!device_file.IsValid())
+      return false;
+
+    return true;
+  }
+
+  void OnDeviceAdded(std::string device_id) {
+    std::string device_node = "/dev/" + device_id;
+    uint16_t vendor_id = 0xffff;
+    uint16_t product_id = 0xffff;
+    std::string product_name = "";
+    std::string serial_number = "";
+
+    std::vector<uint8_t> report_descriptor;
+
+    base::AssertBlockingAllowed();
+
+    base::FilePath device_path(device_node);
+    base::File device_file;
+    int flags =
+        base::File::FLAG_OPEN | base::File::FLAG_READ | base::File::FLAG_WRITE;
+    device_file.Initialize(device_path, flags);
+    if (!device_file.IsValid()) {
+      HID_LOG(ERROR) << "Failed to open '" << device_node
+                     << "': "
+                     << base::File::ErrorToString(device_file.error_details());
+      return;
+    }
+
+    base::ScopedFD fd;
+    fd.reset(device_file.TakePlatformFile());
+
+    struct usb_gen_descriptor ugd;
+    ugd.ugd_data = NULL;
+    ugd.ugd_maxlen = 0xffff;
+    int result = HANDLE_EINTR(
+        ioctl(fd.get(), USB_GET_REPORT_DESC, &ugd));
+
+    if (result < 0) {
+      HID_LOG(ERROR) << "Failed to get report descriptor size";
+      return;
+    }
+
+    report_descriptor.resize(ugd.ugd_actlen);
+
+    ugd.ugd_data = report_descriptor.data();
+    ugd.ugd_maxlen = ugd.ugd_actlen;
+    result = HANDLE_EINTR(
+        ioctl(fd.get(), USB_GET_REPORT_DESC, &ugd));
+
+    if (result < 0) {
+      HID_LOG(ERROR) << "Failed to get report descriptor";
+      return;
+    }
+
+    scoped_refptr<HidDeviceInfo> device_info(new HidDeviceInfo(
+        device_id, vendor_id, product_id, product_name, serial_number,
+        device::mojom::HidBusType::kHIDBusTypeUSB,
+        report_descriptor, device_node));
+
+    task_runner_->PostTask(FROM_HERE, base::Bind(&HidServiceFreeBSD::AddDevice,
+                                                 service_, device_info));
+  }
+
+  void OnDeviceRemoved(std::string device_id) {
+    task_runner_->PostTask(
+        FROM_HERE, base::Bind(&HidServiceFreeBSD::RemoveDevice, service_,
+                              device_id));
+  }
+
+ private:
+
+  void CheckPendingPermissionChange() {
+    base::AssertBlockingAllowed();
+    std::map<std::string, int>::iterator it;
+    for (it = permissions_checks_attempts_.begin(); it != permissions_checks_attempts_.end();) {
+      std::string device_name = it->first;
+      bool keep = true;
+      if (HaveReadWritePermissions(device_name)) {
+        OnDeviceAdded(device_name);
+        keep = false;
+      }
+      else if (it->second-- <= 0) {
+        HID_LOG(ERROR) << "Still don't have write permissions to '" << device_name
+                       << "' after " << kMaxPermissionChecks << " attempts";
+        keep = false;
+      }
+
+      if (keep)
+        ++it;
+      else
+        permissions_checks_attempts_.erase(it++);
+    }
+
+    if (permissions_checks_attempts_.empty())
+      timer_->Stop();
+  }
+
+  void SetupDevdMonitor() {
+    base::AssertBlockingAllowed();
+
+    int devd_fd = socket(AF_UNIX, SOCK_SEQPACKET, 0);
+    if (devd_fd < 0)
+      return;
+
+    struct sockaddr_un sa;
+
+    sa.sun_family = AF_UNIX;
+    strlcpy(sa.sun_path, "/var/run/devd.seqpacket.pipe", sizeof(sa.sun_path));
+    if (connect(devd_fd, (struct sockaddr *) &sa, sizeof(sa)) < 0) {
+      close(devd_fd);
+      return;
+    } 
+
+    devd_fd_.reset(devd_fd);
+    file_watcher_ = base::FileDescriptorWatcher::WatchReadable(
+        devd_fd_.get(), base::Bind(&BlockingTaskHelper::OnDevdMessageCanBeRead,
+                                   base::Unretained(this)));
+  }
+
+  void OnDevdMessageCanBeRead() {
+    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+    ssize_t bytes_read = HANDLE_EINTR(recv(devd_fd_.get(), devd_buffer_->data(),
+                                      devd_buffer_->size() - 1, MSG_WAITALL));
+    if (bytes_read < 0) {
+      if (errno != EAGAIN) {
+        HID_LOG(ERROR) << "Read failed";
+        file_watcher_.reset();
+      }
+      return;
+    }
+
+    devd_buffer_->data()[bytes_read] = 0;
+    char *data = devd_buffer_->data();
+    // It may take some time for devd to change permissions
+    // on /dev/uhidX node. So do not fail immediately if
+    // open fail. Retry each second for kMaxPermissionChecks
+    // times before giving up entirely
+    if (base::StartsWith(data, "+uhid", base::CompareCase::SENSITIVE)) {
+      std::vector<std::string> parts = base::SplitString(
+        data, " ", base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL);
+      if (!parts.empty()) {
+        std::string device_name = parts[0].substr(1); // skip '+'
+        if (HaveReadWritePermissions(device_name))
+          OnDeviceAdded(parts[0].substr(1));
+        else {
+          // Do not re-add to checks
+          if (permissions_checks_attempts_.find(device_name) == permissions_checks_attempts_.end()) {
+            permissions_checks_attempts_.insert(std::pair<std::string, int>(device_name, kMaxPermissionChecks));
+            timer_->Start(FROM_HERE, base::TimeDelta::FromSeconds(1),
+                          this, &BlockingTaskHelper::CheckPendingPermissionChange);
+          }
+        }
+      }
+    }
+
+    if (base::StartsWith(data, "-uhid", base::CompareCase::SENSITIVE)) {
+      std::vector<std::string> parts = base::SplitString(
+        data, " ", base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL);
+      if (!parts.empty()) {
+        std::string device_name = parts[0].substr(1); // skip '-'
+        auto it = permissions_checks_attempts_.find(device_name);
+        if (it != permissions_checks_attempts_.end()) {
+          permissions_checks_attempts_.erase(it);
+          if (permissions_checks_attempts_.empty())
+            timer_->Stop();
+        }
+        OnDeviceRemoved(parts[0].substr(1));
+      }
+    }
+  }
+
+  SEQUENCE_CHECKER(sequence_checker_);
+
+  // This weak pointer is only valid when checked on this task runner.
+  base::WeakPtr<HidServiceFreeBSD> service_;
+  scoped_refptr<base::SequencedTaskRunner> task_runner_;
+  std::unique_ptr<base::FileDescriptorWatcher::Controller> file_watcher_;
+  std::unique_ptr<base::RepeatingTimer> timer_;
+  base::ScopedFD devd_fd_;
+  scoped_refptr<net::IOBufferWithSize> devd_buffer_;
+  std::map<std::string, int> permissions_checks_attempts_;
+
+  DISALLOW_COPY_AND_ASSIGN(BlockingTaskHelper);
+};
+
+HidServiceFreeBSD::HidServiceFreeBSD()
+    : task_runner_(base::ThreadTaskRunnerHandle::Get()),
+      blocking_task_runner_(
+          base::CreateSequencedTaskRunnerWithTraits(kBlockingTaskTraits)),
+      weak_factory_(this) {
+  helper_ = std::make_unique<BlockingTaskHelper>(weak_factory_.GetWeakPtr());
+  blocking_task_runner_->PostTask(
+      FROM_HERE,
+      base::Bind(&BlockingTaskHelper::Start, base::Unretained(helper_.get())));
+}
+
+HidServiceFreeBSD::~HidServiceFreeBSD() {
+  blocking_task_runner_->DeleteSoon(FROM_HERE, helper_.release());
+}
+
+base::WeakPtr<HidService> HidServiceFreeBSD::GetWeakPtr() {
+  return weak_factory_.GetWeakPtr();
+}
+
+// static
+void HidServiceFreeBSD::OpenOnBlockingThread(
+    std::unique_ptr<ConnectParams> params) {
+  base::AssertBlockingAllowed();
+  scoped_refptr<base::SequencedTaskRunner> task_runner = params->task_runner;
+
+  base::FilePath device_path(params->device_info->device_node());
+  base::File device_file;
+  int flags =
+      base::File::FLAG_OPEN | base::File::FLAG_READ | base::File::FLAG_WRITE;
+  device_file.Initialize(device_path, flags);
+  if (!device_file.IsValid()) {
+    HID_LOG(EVENT) << "Failed to open '" << params->device_info->device_node()
+                   << "': "
+                   << base::File::ErrorToString(device_file.error_details());
+    task_runner->PostTask(FROM_HERE, base::Bind(params->callback, nullptr));
+    return;
+  }
+  params->fd.reset(device_file.TakePlatformFile());
+  FinishOpen(std::move(params));
+}
+
+void HidServiceFreeBSD::Connect(const std::string& device_guid,
+                            const ConnectCallback& callback) {
+  DCHECK(thread_checker_.CalledOnValidThread());
+
+  const auto& map_entry = devices().find(device_guid);
+  if (map_entry == devices().end()) {
+    base::ThreadTaskRunnerHandle::Get()->PostTask(
+        FROM_HERE, base::Bind(callback, nullptr));
+    return;
+  }
+
+  scoped_refptr<HidDeviceInfo> device_info = map_entry->second;
+
+  auto params = std::make_unique<ConnectParams>(device_info, callback);
+
+  scoped_refptr<base::SequencedTaskRunner> blocking_task_runner =
+      params->blocking_task_runner;
+  blocking_task_runner->PostTask(
+      FROM_HERE, base::Bind(&HidServiceFreeBSD::OpenOnBlockingThread,
+                            base::Passed(&params)));
+}
+
+// static
+void HidServiceFreeBSD::FinishOpen(std::unique_ptr<ConnectParams> params) {
+  base::AssertBlockingAllowed();
+  scoped_refptr<base::SequencedTaskRunner> task_runner = params->task_runner;
+
+  task_runner->PostTask(
+      FROM_HERE,
+      base::Bind(&HidServiceFreeBSD::CreateConnection, base::Passed(&params)));
+}
+
+// static
+void HidServiceFreeBSD::CreateConnection(std::unique_ptr<ConnectParams> params) {
+  DCHECK(params->fd.is_valid());
+  params->callback.Run(base::MakeRefCounted<HidConnectionFreeBSD>(
+      std::move(params->device_info), std::move(params->fd),
+      std::move(params->blocking_task_runner)));
+}
+
+}  // namespace device
diff --git services/device/hid/hid_service_freebsd.h services/device/hid/hid_service_freebsd.h
new file mode 100644
index 0000000000..caf99003f5
--- /dev/null
+++ services/device/hid/hid_service_freebsd.h
@@ -0,0 +1,48 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef DEVICE_HID_HID_SERVICE_FREEBSD_H_
+#define DEVICE_HID_HID_SERVICE_FREEBSD_H_
+
+#include <string>
+
+#include "base/macros.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "base/timer/timer.h"
+#include "services/device/hid/hid_service.h"
+#include "net/base/io_buffer.h"
+
+namespace device {
+
+class HidServiceFreeBSD : public HidService {
+ public:
+  HidServiceFreeBSD();
+  ~HidServiceFreeBSD() override;
+
+  void Connect(const std::string& device_guid,
+               const ConnectCallback& connect) override;
+  base::WeakPtr<HidService> GetWeakPtr() override;
+
+ private:
+  struct ConnectParams;
+  class BlockingTaskHelper;
+
+  static void OpenOnBlockingThread(std::unique_ptr<ConnectParams> params);
+  static void FinishOpen(std::unique_ptr<ConnectParams> params);
+  static void CreateConnection(std::unique_ptr<ConnectParams> params);
+
+  const scoped_refptr<base::SequencedTaskRunner> task_runner_;
+  const scoped_refptr<base::SequencedTaskRunner> blocking_task_runner_;
+  // |helper_| lives on the sequence |blocking_task_runner_| posts to and holds
+  // a weak reference back to the service that owns it.
+  std::unique_ptr<BlockingTaskHelper> helper_;
+  base::WeakPtrFactory<HidServiceFreeBSD> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(HidServiceFreeBSD);
+};
+
+}  // namespace device
+
+#endif  // DEVICE_HID_HID_SERVICE_FREEBSD_H_
diff --git services/device/time_zone_monitor/time_zone_monitor.cc services/device/time_zone_monitor/time_zone_monitor.cc
index 5065336f8d..790c351e1b 100644
--- services/device/time_zone_monitor/time_zone_monitor.cc
+++ services/device/time_zone_monitor/time_zone_monitor.cc
@@ -41,7 +41,7 @@ void TimeZoneMonitor::NotifyClients() {
 #else
   std::unique_ptr<icu::TimeZone> new_zone(icu::TimeZone::detectHostTimeZone());
 #endif
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // We get here multiple times on Linux per a single tz change, but
   // want to update the ICU default zone and notify renderer only once.
   std::unique_ptr<icu::TimeZone> current_zone(icu::TimeZone::createDefault());
diff --git services/network/BUILD.gn services/network/BUILD.gn
index 3f02910e24..73e053931b 100644
--- services/network/BUILD.gn
+++ services/network/BUILD.gn
@@ -138,7 +138,6 @@ component("network_service") {
 
   if (is_linux) {
     deps += [
-      "//sandbox/linux:sandbox_services",
       "//services/service_manager/sandbox:sandbox",
     ]
   }
diff --git services/network/network_sandbox_hook_linux.cc services/network/network_sandbox_hook_linux.cc
index 983a6dac49..a86310acd8 100644
--- services/network/network_sandbox_hook_linux.cc
+++ services/network/network_sandbox_hook_linux.cc
@@ -14,6 +14,7 @@ using sandbox::syscall_broker::MakeBrokerCommandSet;
 namespace network {
 
 bool NetworkPreSandboxHook(service_manager::SandboxLinux::Options options) {
+#if !defined(OS_BSD)
   auto* instance = service_manager::SandboxLinux::GetInstance();
 
   // TODO(tsepez): remove universal permission under filesytem root.
@@ -32,6 +33,7 @@ bool NetworkPreSandboxHook(service_manager::SandboxLinux::Options options) {
       service_manager::SandboxLinux::PreSandboxHook(), options);
 
   instance->EngageNamespaceSandbox(false /* from_zygote */);
+#endif
   return true;
 }
 
diff --git services/network/public/cpp/cors/cors_legacy.cc services/network/public/cpp/cors/cors_legacy.cc
index 8f32ac3be6..f01af63619 100644
--- services/network/public/cpp/cors/cors_legacy.cc
+++ services/network/public/cpp/cors/cors_legacy.cc
@@ -5,8 +5,6 @@
 #include "services/network/public/cpp/cors/cors_legacy.h"
 
 #include <algorithm>
-#include <string>
-#include <vector>
 
 #include "url/gurl.h"
 #include "url/url_util.h"
diff --git services/network/public/cpp/cors/cors_legacy.h services/network/public/cpp/cors/cors_legacy.h
index d2cdf026ca..dc9295a92c 100644
--- services/network/public/cpp/cors/cors_legacy.h
+++ services/network/public/cpp/cors/cors_legacy.h
@@ -5,6 +5,7 @@
 #ifndef SERVICES_NETWORK_PUBLIC_CPP_CORS_CORS_LEGACY_H_
 #define SERVICES_NETWORK_PUBLIC_CPP_CORS_CORS_LEGACY_H_
 
+#include <string>
 #include <vector>
 
 #include "base/component_export.h"
diff --git services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics.h services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics.h
index 7eaec00f28..05bbcb5354 100644
--- services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics.h
+++ services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics.h
@@ -36,7 +36,7 @@ class SERVICES_RESOURCE_COORDINATOR_PUBLIC_CPP_EXPORT OSMetrics {
   static std::vector<mojom::VmRegionPtr> GetProcessModules(base::ProcessId);
 #endif
 
-#if defined(OS_LINUX) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_BSD)
   static void SetProcSmapsForTesting(FILE*);
 #endif  // defined(OS_LINUX)
 };
diff --git services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics_linux.cc services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics_linux.cc
index 3c8ccb9c08..4b3aedfb13 100644
--- services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics_linux.cc
+++ services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics_linux.cc
@@ -16,8 +16,10 @@
 #include "build/build_config.h"
 #include "services/resource_coordinator/public/cpp/memory_instrumentation/os_metrics.h"
 
+#if !defined(OS_BSD)
 // Symbol with virtual address of the start of ELF header of the current binary.
 extern char __ehdr_start;
+#endif
 
 namespace memory_instrumentation {
 
@@ -101,7 +103,7 @@ bool ParseSmapsHeader(const char* header_line, VmRegion* region) {
   // Build ID is needed to symbolize heap profiles, and is generated only on
   // official builds. Build ID is only added for the current library (chrome)
   // since it is racy to read other libraries which can be unmapped any time.
-#if defined(OFFICIAL_BUILD)
+#if defined(OFFICIAL_BUILD) && !defined(OS_BSD)
   uintptr_t addr = reinterpret_cast<uintptr_t>(&ParseSmapsHeader);
   if (addr >= region->start_address && addr < end_addr) {
     base::Optional<std::string> buildid =
@@ -196,6 +198,9 @@ void OSMetrics::SetProcSmapsForTesting(FILE* f) {
 // static
 bool OSMetrics::FillOSMemoryDump(base::ProcessId pid,
                                  mojom::RawOSMemDump* dump) {
+#if defined(OS_BSD)
+  return false;
+#else
   base::ScopedFD autoclose = OpenStatm(pid);
   int statm_fd = autoclose.get();
 
@@ -221,6 +226,7 @@ bool OSMetrics::FillOSMemoryDump(base::ProcessId pid,
   dump->resident_set_kb = process_metrics->GetResidentSetSize() / 1024;
 
   return true;
+#endif
 }
 
 // static
diff --git services/service_manager/embedder/set_process_title_linux.cc services/service_manager/embedder/set_process_title_linux.cc
index e0a5f3b799..6ae00a2497 100644
--- services/service_manager/embedder/set_process_title_linux.cc
+++ services/service_manager/embedder/set_process_title_linux.cc
@@ -49,6 +49,8 @@
 extern char** environ;
 
 static char** g_main_argv = NULL;
+
+#if !defined(OS_FREEBSD) && !defined(OS_DRAGONFLY)
 static char* g_orig_argv0 = NULL;
 
 void setproctitle(const char* fmt, ...) {
@@ -101,6 +103,7 @@ void setproctitle(const char* fmt, ...) {
   va_end(ap);
   g_main_argv[1] = NULL;
 }
+#endif
 
 // A version of this built into glibc would not need this function, since
 // it could stash the argv pointer in __libc_start_main(). But we need it.
diff --git services/service_manager/embedder/set_process_title_linux.h services/service_manager/embedder/set_process_title_linux.h
index 690c9270b6..be55631471 100644
--- services/service_manager/embedder/set_process_title_linux.h
+++ services/service_manager/embedder/set_process_title_linux.h
@@ -5,6 +5,9 @@
 #ifndef SERVICES_SERVICE_MANAGER_EMBEDDER_SET_PROCESS_TITLE_LINUX_H_
 #define SERVICES_SERVICE_MANAGER_EMBEDDER_SET_PROCESS_TITLE_LINUX_H_
 
+#include "build/build_config.h"
+
+#if !defined(OS_FREEBSD) && !defined(OS_DRAGONFLY)
 // Set the process title that will show in "ps" and similar tools. Takes
 // printf-style format string and arguments. After calling setproctitle()
 // the original main() argv[] array should not be used. By default, the
@@ -14,6 +17,7 @@
 // This signature and naming is to be compatible with most other Unix
 // implementations of setproctitle().
 void setproctitle(const char* fmt, ...);
+#endif
 
 // Initialize state needed for setproctitle() on Linux. Pass the argv pointer
 // from main() to setproctitle_init() before calling setproctitle().
diff --git services/service_manager/public/cpp/standalone_service/BUILD.gn services/service_manager/public/cpp/standalone_service/BUILD.gn
index 707611a8a4..126bc17dd3 100644
--- services/service_manager/public/cpp/standalone_service/BUILD.gn
+++ services/service_manager/public/cpp/standalone_service/BUILD.gn
@@ -24,7 +24,7 @@ source_set("standalone_service") {
     "//services/service_manager/public/mojom",
   ]
 
-  if (is_linux && !is_android) {
+  if (is_linux && !is_android && !is_bsd) {
     deps += [
       "//sandbox/linux:sandbox",
       "//sandbox/linux:sandbox_services",
diff --git services/service_manager/public/cpp/standalone_service/standalone_service.cc services/service_manager/public/cpp/standalone_service/standalone_service.cc
index 91493f22f8..463cc868f2 100644
--- services/service_manager/public/cpp/standalone_service/standalone_service.cc
+++ services/service_manager/public/cpp/standalone_service/standalone_service.cc
@@ -60,6 +60,8 @@ void RunStandaloneService(const StandaloneServiceCallback& callback) {
             command_line.GetSwitchValueASCII(switches::kServiceSandboxType)),
         SandboxLinux::PreSandboxHook(), sandbox_options);
   }
+#elif defined(OS_BSD)
+  NOTIMPLEMENTED();
 #endif
 
   mojo::edk::Init();
diff --git services/service_manager/runner/host/BUILD.gn services/service_manager/runner/host/BUILD.gn
index 948907856c..94820f282e 100644
--- services/service_manager/runner/host/BUILD.gn
+++ services/service_manager/runner/host/BUILD.gn
@@ -39,7 +39,7 @@ source_set("lib") {
     "//mojo/public/cpp/system",
   ]
 
-  if (is_linux && !is_android) {
+  if (is_linux && !is_android && !is_bsd) {
     deps += [ "//sandbox/linux:sandbox_services" ]
   }
 
diff --git services/service_manager/sandbox/BUILD.gn services/service_manager/sandbox/BUILD.gn
index efed0e2172..3ea202516e 100644
--- services/service_manager/sandbox/BUILD.gn
+++ services/service_manager/sandbox/BUILD.gn
@@ -27,7 +27,7 @@ component("sandbox") {
     ":sanitizer_buildflags",
     "//base",
   ]
-  if (is_linux) {
+  if (is_linux && !is_bsd) {
     sources += [
       "linux/bpf_base_policy_linux.cc",
       "linux/bpf_base_policy_linux.h",
diff --git services/service_manager/zygote/common/zygote_features.gni services/service_manager/zygote/common/zygote_features.gni
index c7580b35ff..47b5f4d134 100644
--- services/service_manager/zygote/common/zygote_features.gni
+++ services/service_manager/zygote/common/zygote_features.gni
@@ -2,4 +2,4 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-use_zygote_handle = is_posix && !is_android && !is_mac
+use_zygote_handle = is_posix && !is_android && !is_mac && !is_bsd
diff --git services/service_manager/zygote/host/zygote_host_impl_linux.cc services/service_manager/zygote/host/zygote_host_impl_linux.cc
index 3bd1f728c7..4df452cfa8 100644
--- services/service_manager/zygote/host/zygote_host_impl_linux.cc
+++ services/service_manager/zygote/host/zygote_host_impl_linux.cc
@@ -72,6 +72,7 @@ ZygoteHostImpl* ZygoteHostImpl::GetInstance() {
 }
 
 void ZygoteHostImpl::Init(const base::CommandLine& command_line) {
+#if !defined(OS_BSD)
   if (command_line.HasSwitch(service_manager::switches::kNoSandbox)) {
     return;
   }
@@ -133,6 +134,7 @@ void ZygoteHostImpl::Init(const base::CommandLine& command_line) {
            "you can try using --"
         << service_manager::switches::kNoSandbox << ".";
   }
+#endif
 }
 
 void ZygoteHostImpl::AddZygotePid(pid_t pid) {
@@ -157,6 +159,7 @@ pid_t ZygoteHostImpl::LaunchZygote(
     base::CommandLine* cmd_line,
     base::ScopedFD* control_fd,
     base::FileHandleMappingVector additional_remapped_fds) {
+#if !defined(OS_BSD)
   int fds[2];
   CHECK_EQ(0, socketpair(AF_UNIX, SOCK_SEQPACKET, 0, fds));
   CHECK(base::UnixDomainSocket::EnableReceiveProcessId(fds[0]));
@@ -221,9 +224,12 @@ pid_t ZygoteHostImpl::LaunchZygote(
 
   AddZygotePid(pid);
   return pid;
+#else
+  return 0;
+#endif
 }
 
-#if !defined(OS_OPENBSD)
+#if !defined(OS_BSD)
 void ZygoteHostImpl::AdjustRendererOOMScore(base::ProcessHandle pid,
                                             int score) {
   // 1) You can't change the oom_score_adj of a non-dumpable process
diff --git services/service_manager/zygote/host/zygote_host_impl_linux.h services/service_manager/zygote/host/zygote_host_impl_linux.h
index 7f4f822fdc..f3c4998741 100644
--- services/service_manager/zygote/host/zygote_host_impl_linux.h
+++ services/service_manager/zygote/host/zygote_host_impl_linux.h
@@ -44,8 +44,10 @@ class COMPONENT_EXPORT(SERVICE_MANAGER_ZYGOTE) ZygoteHostImpl
                      base::ScopedFD* control_fd,
                      base::FileHandleMappingVector additional_remapped_fds);
 
+#if !defined(OS_BSD)
   void AdjustRendererOOMScore(base::ProcessHandle process_handle,
                               int score) override;
+#endif
 
  private:
   friend struct base::DefaultSingletonTraits<ZygoteHostImpl>;
diff --git services/service_manager/zygote/zygote_host_linux.h services/service_manager/zygote/zygote_host_linux.h
index 2426b60a6f..d834704250 100644
--- services/service_manager/zygote/zygote_host_linux.h
+++ services/service_manager/zygote/zygote_host_linux.h
@@ -30,11 +30,13 @@ class ZygoteHost {
   // after the first render has been forked.
   virtual int GetRendererSandboxStatus() const = 0;
 
+#if !defined(OS_BSD)
   // Adjust the OOM score of the given renderer's PID.  The allowed
   // range for the score is [0, 1000], where higher values are more
   // likely to be killed by the OOM killer.
   virtual void AdjustRendererOOMScore(base::ProcessHandle process_handle,
                                       int score) = 0;
+#endif
 };
 
 }  // namespace service_manager
diff --git services/service_manager/zygote/zygote_linux.cc services/service_manager/zygote/zygote_linux.cc
index 32528188e9..0420b8142d 100644
--- services/service_manager/zygote/zygote_linux.cc
+++ services/service_manager/zygote/zygote_linux.cc
@@ -1,6 +1,7 @@
 // Copyright (c) 2012 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#if 0
 
 #include "services/service_manager/zygote/zygote_linux.h"
 
@@ -664,3 +665,4 @@ bool Zygote::HandleGetSandboxStatus(int fd, base::PickleIterator iter) {
 }
 
 }  // namespace service_manager
+#endif
diff --git services/service_manager/zygote/zygote_main_linux.cc services/service_manager/zygote/zygote_main_linux.cc
index a00717066a..52646acfac 100644
--- services/service_manager/zygote/zygote_main_linux.cc
+++ services/service_manager/zygote/zygote_main_linux.cc
@@ -11,7 +11,9 @@
 #include <stddef.h>
 #include <stdint.h>
 #include <string.h>
+#if !defined(OS_BSD)
 #include <sys/prctl.h>
+#endif
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <unistd.h>
@@ -101,6 +103,7 @@ static bool CreateInitProcessReaper(
 // created through the setuid sandbox.
 static bool EnterSuidSandbox(sandbox::SetuidSandboxClient* setuid_sandbox,
                              base::OnceClosure post_fork_parent_callback) {
+#if !defined(OS_BSD)
   DCHECK(setuid_sandbox);
   DCHECK(setuid_sandbox->IsSuidSandboxChild());
 
@@ -133,6 +136,9 @@ static bool EnterSuidSandbox(sandbox::SetuidSandboxClient* setuid_sandbox,
 
   CHECK(service_manager::SandboxDebugHandling::SetDumpableStatusAndHandlers());
   return true;
+#else
+  return false;
+#endif
 }
 
 static void DropAllCapabilities(int proc_fd) {
@@ -178,6 +184,7 @@ static void EnterLayerOneSandbox(service_manager::SandboxLinux* linux_sandbox,
 
 bool ZygoteMain(
     std::vector<std::unique_ptr<ZygoteForkDelegate>> fork_delegates) {
+#if !defined(OS_BSD)
   sandbox::SetAmZygoteOrRenderer(true, GetSandboxFD());
 
   auto* linux_sandbox = service_manager::SandboxLinux::GetInstance();
@@ -240,6 +247,9 @@ bool ZygoteMain(
 
   // This function call can return multiple times, once per fork().
   return zygote.ProcessRequests();
+#else
+  return false;
+#endif
 }
 
 }  // namespace service_manager
diff --git skia/ext/SkMemory_new_handler.cpp skia/ext/SkMemory_new_handler.cpp
index 42ce498a9c..3a323f2189 100644
--- skia/ext/SkMemory_new_handler.cpp
+++ skia/ext/SkMemory_new_handler.cpp
@@ -69,7 +69,7 @@ static void* malloc_nothrow(size_t size) {
   // TODO(b.kelemen): we should always use UncheckedMalloc but currently it
   // doesn't work as intended everywhere.
   void* result;
-#if  defined(OS_IOS)
+#if  defined(OS_IOS) || defined(OS_BSD)
     result = malloc(size);
 #else
     // It's the responsibility of the caller to check the return value.
@@ -89,7 +89,7 @@ static void* calloc_nothrow(size_t size) {
   // TODO(b.kelemen): we should always use UncheckedCalloc but currently it
   // doesn't work as intended everywhere.
   void* result;
-#if  defined(OS_IOS)
+#if  defined(OS_IOS) || defined(OS_BSD)
     result = calloc(1, size);
 #else
     // It's the responsibility of the caller to check the return value.
diff --git skia/ext/platform_canvas.h skia/ext/platform_canvas.h
index c31e7c0214..553ed7a76e 100644
--- skia/ext/platform_canvas.h
+++ skia/ext/platform_canvas.h
@@ -58,7 +58,7 @@ SK_API HDC GetNativeDrawingContext(SkCanvas* canvas);
 
 #elif defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__) || \
     defined(__sun) || defined(ANDROID) || defined(__APPLE__) ||             \
-    defined(__Fuchsia__)
+    defined(__Fuchsia__) || defined(__DragonFly__)
 // Construct a canvas from the given memory region. The memory is not cleared
 // first. @data must be, at least, @height * StrideForWidth(@width) bytes.
 SK_API std::unique_ptr<SkCanvas> CreatePlatformCanvasWithPixels(
diff --git third_party/angle/BUILD.gn third_party/angle/BUILD.gn
index 37158d76ca..e76059f887 100644
--- third_party/angle/BUILD.gn
+++ third_party/angle/BUILD.gn
@@ -271,6 +271,7 @@ static_library("angle_gpu_info_util") {
         "X11",
         "Xi",
         "Xext",
+        "GL",
       ]
     }
   }
@@ -844,10 +845,6 @@ foreach(is_shared_library,
     libs = []
     if (is_linux) {
       sources += rebase_path(util_gypi.util_linux_sources, ".", "util")
-      libs += [
-        "rt",
-        "dl",
-      ]
     }
 
     if (is_mac) {
diff --git third_party/angle/src/gpu_info_util/SystemInfo_internal.h third_party/angle/src/gpu_info_util/SystemInfo_internal.h
index d2f6124662..a9952b032d 100644
--- third_party/angle/src/gpu_info_util/SystemInfo_internal.h
+++ third_party/angle/src/gpu_info_util/SystemInfo_internal.h
@@ -14,8 +14,13 @@
 namespace angle
 {
 
+bool CollectMesaCardInfo(std::vector<GPUDeviceInfo> *devices);
+
 // Defined in SystemInfo_libpci when GPU_INFO_USE_LIBPCI is defined.
 bool GetPCIDevicesWithLibPCI(std::vector<GPUDeviceInfo> *devices);
+#if defined(__FreeBSD__)
+bool GetPCIDevicesFreeBSD(std::vector<GPUDeviceInfo> *devices);
+#endif
 // Defined in SystemInfo_x11 when GPU_INFO_USE_X11 is defined.
 bool GetNvidiaDriverVersionWithXNVCtrl(std::string *version);
 
diff --git third_party/angle/src/gpu_info_util/SystemInfo_libpci.cpp third_party/angle/src/gpu_info_util/SystemInfo_libpci.cpp
index 07c72872ad..08f08363cb 100644
--- third_party/angle/src/gpu_info_util/SystemInfo_libpci.cpp
+++ third_party/angle/src/gpu_info_util/SystemInfo_libpci.cpp
@@ -12,6 +12,11 @@
 #include <pci/pci.h>
 #include <unistd.h>
 
+#if defined(__FreeBSD__)
+#include <fcntl.h>
+#include <sys/pciio.h>
+#endif
+
 #include "common/angleutils.h"
 #include "common/debug.h"
 
@@ -83,6 +88,75 @@ struct LibPCI : private angle::NonCopyable
 
 }  // anonymous namespace
 
+#if defined(__FreeBSD__)
+// Adds an entry per PCI GPU found and fills the device and vendor ID.
+bool GetPCIDevicesFreeBSD(std::vector<GPUDeviceInfo> *devices)
+{
+    int fd;
+    struct pci_conf_io conf;
+    struct pci_conf *matches;
+    uint32_t offset = 0;
+
+    fd = open("/dev/pci", O_RDONLY);
+    if (fd < 0)
+        return false;
+
+    matches = new struct pci_conf[32];
+    conf.generation = 0;
+    do {
+        conf.pat_buf_len = 0;
+        conf.num_patterns = 0;
+        conf.patterns = NULL;
+        conf.match_buf_len = 32 * sizeof(struct pci_conf);
+        conf.num_matches = 32;
+        conf.matches = matches;
+        conf.offset = offset;
+        conf.status = PCI_GETCONF_ERROR;
+        if (ioctl(fd, PCIOCGETCONF, &conf) < 0) {
+            if (errno == ENODEV)
+                break;
+        }
+        /* PCI_GETCONF_LIST_CHANGED would require us to start over. */
+        if (conf.status == PCI_GETCONF_ERROR || conf.status == PCI_GETCONF_LIST_CHANGED) {
+            break;
+        }
+
+        for (unsigned int i = 0; i < conf.num_matches; i++) {
+            uint16_t device_class = (matches[i].pc_class << 8) |  matches[i].pc_subclass;
+
+            // Skip non-GPU devices
+            switch (device_class)
+            {
+                case PCI_CLASS_DISPLAY_VGA:
+                case PCI_CLASS_DISPLAY_XGA:
+                case PCI_CLASS_DISPLAY_3D:
+                    break;
+                default:
+                    continue;
+            }
+
+            // Skip unknown devices
+            if (matches[i].pc_vendor == 0 || matches[i].pc_device == 0) {
+                continue;
+            }
+
+            GPUDeviceInfo info;
+            info.vendorId = matches[i].pc_vendor;
+            info.deviceId = matches[i].pc_device;
+
+            devices->push_back(info);
+        }
+        offset += conf.num_matches;
+    } while (conf.status == PCI_GETCONF_MORE_DEVS);
+
+    delete[] matches;
+
+    close(fd);
+
+    return true;
+}
+#endif
+
 // Adds an entry per PCI GPU found and fills the device and vendor ID.
 bool GetPCIDevicesWithLibPCI(std::vector<GPUDeviceInfo> *devices)
 {
diff --git third_party/angle/src/gpu_info_util/SystemInfo_linux.cpp third_party/angle/src/gpu_info_util/SystemInfo_linux.cpp
index 98f000b069..cfff13b191 100644
--- third_party/angle/src/gpu_info_util/SystemInfo_linux.cpp
+++ third_party/angle/src/gpu_info_util/SystemInfo_linux.cpp
@@ -71,10 +71,18 @@ bool GetPCIDevicesWithLibPCI(std::vector<GPUDeviceInfo> *devices)
 
 bool GetSystemInfo(SystemInfo *info)
 {
+#if defined(__FreeBSD__)
+    if (!CollectMesaCardInfo(&(info->gpus)))
+    {
+        if (!GetPCIDevicesFreeBSD(&(info->gpus)))
+            return false;
+    }
+#else
     if (!GetPCIDevicesWithLibPCI(&(info->gpus)))
     {
         return false;
     }
+#endif
 
     if (info->gpus.size() == 0)
     {
diff --git third_party/angle/src/gpu_info_util/SystemInfo_x11.cpp third_party/angle/src/gpu_info_util/SystemInfo_x11.cpp
index 3513309f36..4afccabc47 100644
--- third_party/angle/src/gpu_info_util/SystemInfo_x11.cpp
+++ third_party/angle/src/gpu_info_util/SystemInfo_x11.cpp
@@ -8,6 +8,8 @@
 
 #include "gpu_info_util/SystemInfo_internal.h"
 
+#include <GL/glx.h>
+#include <GL/glxext.h>
 #include <X11/Xlib.h>
 
 #include "common/debug.h"
@@ -18,9 +20,44 @@
 #error SystemInfo_x11.cpp compiled without GPU_INFO_USE_X11
 #endif
 
+#define GLX_RENDERER_VENDOR_ID_MESA	0x8183
+#define GLX_RENDERER_DEVICE_ID_MESA	0x8184
+
 namespace angle
 {
 
+bool CollectMesaCardInfo(std::vector<GPUDeviceInfo> *devices)
+{
+
+    unsigned int vid[3], did[3];
+
+    Display *display = XOpenDisplay(NULL);
+    if (!display) {
+        return false;
+    }
+
+    PFNGLXQUERYRENDERERINTEGERMESAPROC queryInteger =
+        (PFNGLXQUERYRENDERERINTEGERMESAPROC) glXGetProcAddressARB((const GLubyte *)
+        "glXQueryRendererIntegerMESA");
+
+    if (!queryInteger)
+        return false;
+
+    bool vendor_ret =
+        queryInteger(display, 0, 0, GLX_RENDERER_VENDOR_ID_MESA, vid);
+    bool device_ret =
+        queryInteger(display, 0, 0, GLX_RENDERER_DEVICE_ID_MESA, did);
+
+    if (vendor_ret && device_ret) {
+        GPUDeviceInfo info;
+        info.vendorId = vid[0];
+        info.deviceId = did[0];
+        devices->push_back(info);
+    }
+
+    return true;
+}
+
 bool GetNvidiaDriverVersionWithXNVCtrl(std::string *version)
 {
     *version = "";
diff --git third_party/angle/src/libANGLE/Display.cpp third_party/angle/src/libANGLE/Display.cpp
index 93cfda9fde..994c886202 100644
--- third_party/angle/src/libANGLE/Display.cpp
+++ third_party/angle/src/libANGLE/Display.cpp
@@ -62,7 +62,7 @@
 #if defined(ANGLE_ENABLE_VULKAN)
 #if defined(ANGLE_PLATFORM_WINDOWS)
 #include "libANGLE/renderer/vulkan/win32/DisplayVkWin32.h"
-#elif defined(ANGLE_PLATFORM_LINUX)
+#elif defined(ANGLE_PLATFORM_POSIX)
 #include "libANGLE/renderer/vulkan/xcb/DisplayVkXcb.h"
 #elif defined(ANGLE_PLATFORM_ANDROID)
 #include "libANGLE/renderer/vulkan/android/DisplayVkAndroid.h"
@@ -210,7 +210,7 @@ rx::DisplayImpl *CreateDisplayFromAttribs(const AttributeMap &attribMap, const D
 #if defined(ANGLE_ENABLE_VULKAN)
 #if defined(ANGLE_PLATFORM_WINDOWS)
             impl = new rx::DisplayVkWin32(state);
-#elif defined(ANGLE_PLATFORM_LINUX)
+#elif defined(ANGLE_PLATFORM_POSIX)
             impl = new rx::DisplayVkXcb(state);
 #elif defined(ANGLE_PLATFORM_ANDROID)
             impl = new rx::DisplayVkAndroid(state);
diff --git third_party/angle/src/libANGLE/renderer/gl/renderergl_utils.cpp third_party/angle/src/libANGLE/renderer/gl/renderergl_utils.cpp
index 1e232e003c..89864bd1f3 100644
--- third_party/angle/src/libANGLE/renderer/gl/renderergl_utils.cpp
+++ third_party/angle/src/libANGLE/renderer/gl/renderergl_utils.cpp
@@ -1113,7 +1113,7 @@ void GenerateWorkarounds(const FunctionsGL *functions, WorkaroundsGL *workaround
     workarounds->doesSRGBClearsOnLinearFramebufferAttachments =
         functions->standard == STANDARD_GL_DESKTOP && (IsIntel(vendor) || IsAMD(vendor));
 
-#if defined(ANGLE_PLATFORM_LINUX)
+#if defined(ANGLE_PLATFORM_POSIX)
     workarounds->emulateMaxVertexAttribStride =
         functions->standard == STANDARD_GL_DESKTOP && IsAMD(vendor);
     workarounds->useUnusedBlocksWithStandardOrSharedLayout = IsAMD(vendor);
diff --git third_party/angle/third_party/vulkan-validation-layers/src/loader/loader.c third_party/angle/third_party/vulkan-validation-layers/src/loader/loader.c
index 990859578e..472d4ea445 100644
--- third_party/angle/third_party/vulkan-validation-layers/src/loader/loader.c
+++ third_party/angle/third_party/vulkan-validation-layers/src/loader/loader.c
@@ -213,7 +213,8 @@ void *loader_device_heap_realloc(const struct loader_device *device, void *pMemo
 }
 
 // Environment variables
-#if defined(__linux__) || defined(__APPLE__)
+#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || \
+  defined(__DragonFly__)
 
 static inline char *loader_getenv(const char *name, const struct loader_instance *inst) {
     // No allocation of memory necessary for Linux, but we should at least touch
diff --git third_party/angle/third_party/vulkan-validation-layers/src/loader/vk_loader_platform.h third_party/angle/third_party/vulkan-validation-layers/src/loader/vk_loader_platform.h
index 416256026d..606f5659ec 100644
--- third_party/angle/third_party/vulkan-validation-layers/src/loader/vk_loader_platform.h
+++ third_party/angle/third_party/vulkan-validation-layers/src/loader/vk_loader_platform.h
@@ -31,7 +31,8 @@
 #include "vulkan/vk_platform.h"
 #include "vulkan/vk_sdk_platform.h"
 
-#if defined(__linux__) || defined(__APPLE__)
+#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__) || \
+  defined(__DragonFly__)
 /* Linux-specific common code: */
 
 // Headers:
diff --git third_party/blink/renderer/bindings/core/v8/v8_script_runner.cc third_party/blink/renderer/bindings/core/v8/v8_script_runner.cc
index 71f4326b49..9fd3e50325 100644
--- third_party/blink/renderer/bindings/core/v8/v8_script_runner.cc
+++ third_party/blink/renderer/bindings/core/v8/v8_script_runner.cc
@@ -54,7 +54,7 @@
 
 #if defined(OS_WIN)
 #include <malloc.h>
-#else
+#elif !defined(OS_FREEBSD) && !defined(OS_DRAGONFLY)
 #include <alloca.h>
 #endif
 
diff --git third_party/blink/renderer/core/editing/editing_behavior.cc third_party/blink/renderer/core/editing/editing_behavior.cc
index dc9f9a1521..a81ff46ef5 100644
--- third_party/blink/renderer/core/editing/editing_behavior.cc
+++ third_party/blink/renderer/core/editing/editing_behavior.cc
@@ -270,7 +270,7 @@ bool EditingBehavior::ShouldInsertCharacter(const KeyboardEvent& event) const {
   // unexpected behaviour
   if (ch < ' ')
     return false;
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // According to XKB map no keyboard combinations with ctrl key are mapped to
   // printable characters, however we need the filter as the DomKey/text could
   // contain printable characters.
diff --git third_party/blink/renderer/core/html/canvas/canvas_async_blob_creator.cc third_party/blink/renderer/core/html/canvas/canvas_async_blob_creator.cc
index b6323284d2..fb1d8a95e0 100644
--- third_party/blink/renderer/core/html/canvas/canvas_async_blob_creator.cc
+++ third_party/blink/renderer/core/html/canvas/canvas_async_blob_creator.cc
@@ -31,7 +31,7 @@ const double kSlackBeforeDeadline =
     0.001;  // a small slack period between deadline and current time for safety
 
 /* The value is based on user statistics on Nov 2017. */
-#if (defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN))
+#if (defined(OS_LINUX) || defined(OS_MACOSX) || defined(OS_WIN)) || defined(OS_BSD)
 const double kIdleTaskStartTimeoutDelayMs = 1000.0;
 #else
 const double kIdleTaskStartTimeoutDelayMs = 4000.0;  // For ChromeOS, Mobile
diff --git third_party/blink/renderer/core/html/forms/internal_popup_menu.cc third_party/blink/renderer/core/html/forms/internal_popup_menu.cc
index 4e66eb0002..d6507cb85b 100644
--- third_party/blink/renderer/core/html/forms/internal_popup_menu.cc
+++ third_party/blink/renderer/core/html/forms/internal_popup_menu.cc
@@ -126,7 +126,7 @@ class InternalPopupMenu::ItemIterationContext {
         is_in_group_(false),
         buffer_(buffer) {
     DCHECK(buffer_);
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     // On other platforms, the <option> background color is the same as the
     // <select> background color. On Linux, that makes the <option>
     // background color very dark, so by default, try to use a lighter
diff --git third_party/blink/renderer/core/xml/parser/xml_document_parser.cc third_party/blink/renderer/core/xml/parser/xml_document_parser.cc
index 9744de383d..d0539f61e4 100644
--- third_party/blink/renderer/core/xml/parser/xml_document_parser.cc
+++ third_party/blink/renderer/core/xml/parser/xml_document_parser.cc
@@ -28,6 +28,10 @@
 
 #include <libxml/parser.h>
 #include <libxml/parserInternals.h>
+#include <libxml/xmlversion.h>
+#if defined(LIBXML_CATALOG_ENABLED)
+#include <libxml/catalog.h>
+#endif
 #include <libxslt/xslt.h>
 
 #include <memory>
@@ -648,6 +652,9 @@ static void InitializeLibXMLIfNecessary() {
   if (did_init)
     return;
 
+#if defined(LIBXML_CATALOG_ENABLED)
+  xmlCatalogSetDefaults(XML_CATA_ALLOW_NONE);
+#endif
   xmlInitParser();
   xmlRegisterInputCallbacks(MatchFunc, OpenFunc, ReadFunc, CloseFunc);
   xmlRegisterOutputCallbacks(MatchFunc, OpenFunc, WriteFunc, CloseFunc);
diff --git third_party/blink/renderer/platform/BUILD.gn third_party/blink/renderer/platform/BUILD.gn
index 0517700110..54d5716e00 100644
--- third_party/blink/renderer/platform/BUILD.gn
+++ third_party/blink/renderer/platform/BUILD.gn
@@ -146,6 +146,7 @@ executable("character_data_generator") {
     "//build/win:default_exe_manifest",
     "//third_party/icu",
   ]
+  libs = [ "cxxrt" ]
 }
 
 # This isn't strictly necessary since we can just add the deps to "platform",
diff --git third_party/blink/renderer/platform/fonts/font_cache.cc third_party/blink/renderer/platform/fonts/font_cache.cc
index c4b0b4afd9..7373451ba6 100644
--- third_party/blink/renderer/platform/fonts/font_cache.cc
+++ third_party/blink/renderer/platform/fonts/font_cache.cc
@@ -85,7 +85,7 @@ FontCache::FontCache()
 FontPlatformData* FontCache::SystemFontPlatformData(
     const FontDescription& font_description) {
   const AtomicString& family = FontCache::SystemFontFamily();
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   if (family.IsEmpty() || family == FontFamilyNames::system_ui)
     return nullptr;
 #else
diff --git third_party/blink/renderer/platform/fonts/font_cache.h third_party/blink/renderer/platform/fonts/font_cache.h
index 0b081b4afa..0768dac0d7 100644
--- third_party/blink/renderer/platform/fonts/font_cache.h
+++ third_party/blink/renderer/platform/fonts/font_cache.h
@@ -213,7 +213,7 @@ class PLATFORM_EXPORT FontCache {
       const FontDescription&);
 #endif  // defined(OS_ANDROID)
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   struct PlatformFallbackFont {
     String name;
     CString filename;
@@ -287,7 +287,7 @@ class PLATFORM_EXPORT FontCache {
                                const FontFaceCreationParams&,
                                CString& name);
 
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_FUCHSIA)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_FUCHSIA) || defined(OS_BSD)
   static AtomicString GetFamilyNameForCharacter(SkFontMgr*,
                                                 UChar32,
                                                 const FontDescription&,
diff --git third_party/blink/renderer/platform/fonts/font_metrics.cc third_party/blink/renderer/platform/fonts/font_metrics.cc
index 0d431a2eb6..87fc532648 100644
--- third_party/blink/renderer/platform/fonts/font_metrics.cc
+++ third_party/blink/renderer/platform/fonts/font_metrics.cc
@@ -38,7 +38,7 @@
 
 namespace blink {
 
-#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_FUCHSIA) || defined(OS_BSD)
 // This is the largest VDMX table which we'll try to load and parse.
 static const size_t kMaxVDMXTableSize = 1024 * 1024;  // 1 MB
 #endif
@@ -60,7 +60,7 @@ void FontMetrics::AscentDescentWithHacks(
   int vdmx_ascent = 0, vdmx_descent = 0;
   bool is_vdmx_valid = false;
 
-#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_FUCHSIA) || defined(OS_BSD)
   // Manually digging up VDMX metrics is only applicable when bytecode hinting
   // using FreeType.  With DirectWrite or CoreText, no bytecode hinting is ever
   // done.  This code should be pushed into FreeType (hinted font metrics).
@@ -106,7 +106,7 @@ void FontMetrics::AscentDescentWithHacks(
       visual_overflow_inflation_for_ascent = 1;
     if (descent < metrics.fDescent) {
       visual_overflow_inflation_for_descent = 1;
-#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_FUCHSIA)
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_FUCHSIA) || defined(OS_BSD)
       // When subpixel positioning is enabled, if the descent is rounded down,
       // the descent part of the glyph may be truncated when displayed in a
       // 'overflow: hidden' container.  To avoid that, borrow 1 unit from the
diff --git third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
index 9b6f99ce9e..b8cbce3b78 100644
--- third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
+++ third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
@@ -60,7 +60,7 @@ AtomicString ToAtomicString(const SkString& str) {
   return AtomicString::FromUTF8(str.c_str(), str.size());
 }
 
-#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_FUCHSIA)
+#if defined(OS_ANDROID) || defined(OS_LINUX) || defined(OS_FUCHSIA) || defined(OS_BSD)
 // Android special locale for retrieving the color emoji font
 // based on the proposed changes in UTR #51 for introducing
 // an Emoji script code:
@@ -249,7 +249,7 @@ PaintTypeface FontCache::CreateTypeface(
   }
 #endif
 
-#if defined(OS_LINUX) || defined(OS_WIN)
+#if defined(OS_LINUX) || defined(OS_WIN) || defined(OS_BSD)
   // On linux if the fontManager has been overridden then we should be calling
   // the embedder provided font Manager rather than calling
   // SkTypeface::CreateFromName which may redirect the call to the default font
diff --git third_party/blink/renderer/platform/heap/stack_frame_depth.cc third_party/blink/renderer/platform/heap/stack_frame_depth.cc
index e6237ed57c..c67489a7a1 100644
--- third_party/blink/renderer/platform/heap/stack_frame_depth.cc
+++ third_party/blink/renderer/platform/heap/stack_frame_depth.cc
@@ -15,6 +15,11 @@
 extern "C" void* __libc_stack_end;  // NOLINT
 #endif
 
+#if defined(OS_FREEBSD)
+#include <sys/signal.h>
+#include <pthread_np.h>
+#endif
+
 namespace blink {
 
 static const char* g_avoid_optimization = nullptr;
diff --git third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc
index e3e3173bec..2b2a572807 100644
--- third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc
+++ third_party/blink/renderer/platform/image-decoders/jpeg/jpeg_image_decoder.cc
@@ -643,6 +643,9 @@ class JPEGImageReader final {
   IntSize UvSize() const { return uv_size_; }
 
  private:
+#if defined(USE_SYSTEM_LIBJPEG)
+  NO_SANITIZE_CFI_ICALL
+#endif
   JSAMPARRAY AllocateSampleArray() {
 // Some output color spaces don't need the sample array: don't allocate in that
 // case.
diff --git third_party/blink/renderer/platform/image-encoders/image_encoder.cc third_party/blink/renderer/platform/image-encoders/image_encoder.cc
index 0c7f14c7c0..4c450f5d67 100644
--- third_party/blink/renderer/platform/image-encoders/image_encoder.cc
+++ third_party/blink/renderer/platform/image-encoders/image_encoder.cc
@@ -4,6 +4,17 @@
 
 #include "third_party/blink/renderer/platform/image-encoders/image_encoder.h"
 
+#include "build/build_config.h"
+
+#if defined(OS_WIN)
+#include <basetsd.h>  // Included before jpeglib.h because of INT32 clash
+#endif                // OS_WIN
+#include <stdio.h>    // Needed by jpeglib.h
+
+#include "jpeglib.h"  // for JPEG_MAX_DIMENSION
+
+#include "third_party/libwebp/src/webp/encode.h"  // for WEBP_MAX_DIMENSION
+
 namespace blink {
 
 bool ImageEncoder::Encode(Vector<unsigned char>* dst,
diff --git third_party/blink/renderer/platform/image-encoders/image_encoder.h third_party/blink/renderer/platform/image-encoders/image_encoder.h
index 0d1460f348..40306097d5 100644
--- third_party/blink/renderer/platform/image-encoders/image_encoder.h
+++ third_party/blink/renderer/platform/image-encoders/image_encoder.h
@@ -7,8 +7,6 @@
 
 #include "third_party/blink/renderer/platform/platform_export.h"
 #include "third_party/blink/renderer/platform/wtf/vector.h"
-#include "third_party/libjpeg/jpeglib.h"          // for JPEG_MAX_DIMENSION
-#include "third_party/libwebp/src/webp/encode.h"  // for WEBP_MAX_DIMENSION
 #include "third_party/skia/include/core/SkStream.h"
 #include "third_party/skia/include/encode/SkJpegEncoder.h"
 #include "third_party/skia/include/encode/SkPngEncoder.h"
diff --git third_party/blink/renderer/platform/wtf/BUILD.gn third_party/blink/renderer/platform/wtf/BUILD.gn
index c2abc5d4b6..1a1a5fb3b1 100644
--- third_party/blink/renderer/platform/wtf/BUILD.gn
+++ third_party/blink/renderer/platform/wtf/BUILD.gn
@@ -277,10 +277,14 @@ jumbo_component("wtf") {
   if (is_android) {
     libs = [ "log" ]
   }
-  if (is_linux) {
+  if (is_linux && !is_bsd) {
     libs = [ "dl" ]
   }
 
+  if (is_bsd) {
+    libs = [ "execinfo" ]
+  }
+
   if (is_mac) {
     libs = [
       "CoreFoundation.framework",
diff --git third_party/blink/renderer/platform/wtf/assertions.cc third_party/blink/renderer/platform/wtf/assertions.cc
index c7ecc7ffb9..5139a6779d 100644
--- third_party/blink/renderer/platform/wtf/assertions.cc
+++ third_party/blink/renderer/platform/wtf/assertions.cc
@@ -48,7 +48,7 @@
 #include <windows.h>
 #endif
 
-#if defined(OS_MACOSX) || (defined(OS_LINUX) && !defined(__UCLIBC__))
+#if defined(OS_MACOSX) || ((defined(OS_LINUX) || defined(OS_BSD)) && !defined(__UCLIBC__))
 #include <cxxabi.h>
 #include <dlfcn.h>
 #include <execinfo.h>
diff --git third_party/blink/renderer/platform/wtf/atomics.h third_party/blink/renderer/platform/wtf/atomics.h
index bc0f079403..aaef4faff2 100644
--- third_party/blink/renderer/platform/wtf/atomics.h
+++ third_party/blink/renderer/platform/wtf/atomics.h
@@ -176,7 +176,7 @@ ALWAYS_INLINE void AtomicSetOneToZero(int volatile* ptr) {
 #if defined(THREAD_SANITIZER)
 // The definitions below assume an LP64 data model. This is fine because
 // TSan is only supported on x86_64 Linux.
-#if defined(ARCH_CPU_64_BITS) && defined(OS_LINUX)
+#if defined(ARCH_CPU_64_BITS) && defined(OS_LINUX) || defined(OS_BSD)
 ALWAYS_INLINE void ReleaseStore(volatile int* ptr, int value) {
   __tsan_atomic32_store(ptr, value, __tsan_memory_order_release);
 }
diff --git third_party/blink/renderer/platform/wtf/byte_swap.h third_party/blink/renderer/platform/wtf/byte_swap.h
index ebd6896f00..975b146147 100644
--- third_party/blink/renderer/platform/wtf/byte_swap.h
+++ third_party/blink/renderer/platform/wtf/byte_swap.h
@@ -60,15 +60,21 @@ ALWAYS_INLINE uint16_t Bswap16(uint16_t x) {
 
 #else
 
+#ifndef Bswap64
 ALWAYS_INLINE uint64_t Bswap64(uint64_t x) {
   return __builtin_bswap64(x);
 }
+#endif
+#ifndef Bswap32
 ALWAYS_INLINE uint32_t Bswap32(uint32_t x) {
   return __builtin_bswap32(x);
 }
+#endif
+#ifndef Bswap16
 ALWAYS_INLINE uint16_t Bswap16(uint16_t x) {
   return __builtin_bswap16(x);
 }
+#endif
 
 #endif
 
diff --git third_party/blink/renderer/platform/wtf/compiler.h third_party/blink/renderer/platform/wtf/compiler.h
index 4f0d73c30d..38bb16f8ab 100644
--- third_party/blink/renderer/platform/wtf/compiler.h
+++ third_party/blink/renderer/platform/wtf/compiler.h
@@ -74,8 +74,10 @@
 #if defined(__clang__)
 #define NO_SANITIZE_UNRELATED_CAST \
   __attribute__((no_sanitize("cfi-unrelated-cast", "vptr")))
+#define NO_SANITIZE_CFI_ICALL __attribute__((no_sanitize("cfi-icall")))
 #else
 #define NO_SANITIZE_UNRELATED_CAST
+#define NO_SANITIZE_CFI_ICALL
 #endif
 
 #endif /* WTF_Compiler_h */
diff --git third_party/blink/renderer/platform/wtf/container_annotations.h third_party/blink/renderer/platform/wtf/container_annotations.h
index 199bf38695..5e53bc5e45 100644
--- third_party/blink/renderer/platform/wtf/container_annotations.h
+++ third_party/blink/renderer/platform/wtf/container_annotations.h
@@ -10,7 +10,7 @@
 
 // TODO(ochang): Remove the ARCH_CPU_X86_64 condition to enable this for X86
 // once the crashes there have been fixed: http://crbug.com/461406
-#if defined(ADDRESS_SANITIZER) && defined(OS_LINUX) && defined(ARCH_CPU_X86_64)
+#if defined(ADDRESS_SANITIZER) && (defined(OS_LINUX) || defined(OS_BSD)) && defined(ARCH_CPU_X86_64)
 #define ANNOTATE_CONTIGUOUS_CONTAINER
 #define ANNOTATE_NEW_BUFFER(buffer, capacity, newSize)                       \
   if (buffer) {                                                              \
diff --git third_party/blink/renderer/platform/wtf/stack_util.cc third_party/blink/renderer/platform/wtf/stack_util.cc
index 10f1c0df11..487ca20d18 100644
--- third_party/blink/renderer/platform/wtf/stack_util.cc
+++ third_party/blink/renderer/platform/wtf/stack_util.cc
@@ -16,6 +16,11 @@
 extern "C" void* __libc_stack_end;  // NOLINT
 #endif
 
+#if defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
+#include <sys/signal.h>
+#include <pthread_np.h>
+#endif
+
 namespace WTF {
 
 size_t GetUnderestimatedStackSize() {
@@ -29,14 +34,14 @@ size_t GetUnderestimatedStackSize() {
 // correctly for the main thread.
 
 #if defined(__GLIBC__) || defined(OS_ANDROID) || defined(OS_FREEBSD) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_DRAGONFLY)
   // pthread_getattr_np() can fail if the thread is not invoked by
   // pthread_create() (e.g., the main thread of webkit_unit_tests).
   // If so, a conservative size estimate is returned.
 
   pthread_attr_t attr;
   int error;
-#if defined(OS_FREEBSD)
+#if defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
   pthread_attr_init(&attr);
   error = pthread_attr_get_np(pthread_self(), &attr);
 #else
@@ -50,7 +55,7 @@ size_t GetUnderestimatedStackSize() {
     pthread_attr_destroy(&attr);
     return size;
   }
-#if defined(OS_FREEBSD)
+#if defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
   pthread_attr_destroy(&attr);
 #endif
 
@@ -97,10 +102,10 @@ size_t GetUnderestimatedStackSize() {
 
 void* GetStackStart() {
 #if defined(__GLIBC__) || defined(OS_ANDROID) || defined(OS_FREEBSD) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_DRAGONFLY)
   pthread_attr_t attr;
   int error;
-#if defined(OS_FREEBSD)
+#if defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
   pthread_attr_init(&attr);
   error = pthread_attr_get_np(pthread_self(), &attr);
 #else
@@ -114,7 +119,7 @@ void* GetStackStart() {
     pthread_attr_destroy(&attr);
     return reinterpret_cast<uint8_t*>(base) + size;
   }
-#if defined(OS_FREEBSD)
+#if defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
   pthread_attr_destroy(&attr);
 #endif
 #if defined(__GLIBC__)
diff --git third_party/blink/renderer/platform/wtf/threading_pthreads.cc third_party/blink/renderer/platform/wtf/threading_pthreads.cc
index cf4f9837b3..839f4ff59f 100644
--- third_party/blink/renderer/platform/wtf/threading_pthreads.cc
+++ third_party/blink/renderer/platform/wtf/threading_pthreads.cc
@@ -51,14 +51,19 @@
 #include <objc/objc-auto.h>
 #endif
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include <sys/syscall.h>
 #endif
 
-#if defined(OS_LINUX) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_BSD)
 #include <unistd.h>
 #endif
 
+#if defined(OS_BSD)
+#include <sys/signal.h>
+#include <pthread_np.h>
+#endif
+
 namespace WTF {
 
 namespace internal {
@@ -70,6 +75,8 @@ ThreadIdentifier CurrentThreadSyscall() {
   return syscall(__NR_gettid);
 #elif defined(OS_ANDROID)
   return gettid();
+#elif defined(OS_BSD)
+  return pthread_getthreadid_np();
 #else
   return reinterpret_cast<uintptr_t>(pthread_self());
 #endif
diff --git third_party/boringssl/BUILD.gn third_party/boringssl/BUILD.gn
index d31a9f29fa..c832648495 100644
--- third_party/boringssl/BUILD.gn
+++ third_party/boringssl/BUILD.gn
@@ -72,7 +72,7 @@ if (is_win && !is_msan) {
     } else if (current_cpu == "x64") {
       if (is_mac) {
         sources += crypto_sources_mac_x86_64
-      } else if (is_linux || is_android) {
+      } else if (is_linux || is_bsd || is_android) {
         sources += crypto_sources_linux_x86_64
       } else {
         public_configs = [ ":no_asm_config" ]
@@ -80,13 +80,13 @@ if (is_win && !is_msan) {
     } else if (current_cpu == "x86") {
       if (is_mac) {
         sources += crypto_sources_mac_x86
-      } else if (is_linux || is_android) {
+      } else if (is_linux || is_bsd || is_android) {
         sources += crypto_sources_linux_x86
       } else {
         public_configs = [ ":no_asm_config" ]
       }
     } else if (current_cpu == "arm") {
-      if (is_linux || is_android) {
+      if (is_linux || is_bsd || is_android) {
         sources += crypto_sources_linux_arm
       } else if (is_ios) {
         sources += crypto_sources_ios_arm
@@ -94,7 +94,7 @@ if (is_win && !is_msan) {
         public_configs = [ ":no_asm_config" ]
       }
     } else if (current_cpu == "arm64") {
-      if (is_linux || is_android) {
+      if (is_linux || is_bsd || is_android) {
         sources += crypto_sources_linux_aarch64
       } else if (is_ios) {
         sources += crypto_sources_ios_aarch64
diff --git third_party/boringssl/src/crypto/cpu-aarch64-linux.c third_party/boringssl/src/crypto/cpu-aarch64-linux.c
index 0184dd4ffb..80f7b5289a 100644
--- third_party/boringssl/src/crypto/cpu-aarch64-linux.c
+++ third_party/boringssl/src/crypto/cpu-aarch64-linux.c
@@ -17,7 +17,9 @@
 #if defined(OPENSSL_AARCH64) && defined(OPENSSL_LINUX) && \
     !defined(OPENSSL_STATIC_ARMCAP)
 
+#if defined(OPENSSL_LINUX)
 #include <sys/auxv.h>
+#endif
 
 #include <openssl/arm_arch.h>
 
@@ -27,6 +29,7 @@
 extern uint32_t OPENSSL_armcap_P;
 
 void OPENSSL_cpuid_setup(void) {
+#if defined(OPENSSL_LINUX)
   unsigned long hwcap = getauxval(AT_HWCAP);
 
   // See /usr/include/asm/hwcap.h on an aarch64 installation for the source of
@@ -42,9 +45,11 @@ void OPENSSL_cpuid_setup(void) {
     // either.
     return;
   }
+#endif
 
   OPENSSL_armcap_P |= ARMV7_NEON;
 
+#if defined(OPENSSL_LINUX)
   if (hwcap & kAES) {
     OPENSSL_armcap_P |= ARMV8_AES;
   }
@@ -57,6 +62,7 @@ void OPENSSL_cpuid_setup(void) {
   if (hwcap & kSHA256) {
     OPENSSL_armcap_P |= ARMV8_SHA256;
   }
+#endif
 }
 
 #endif  // OPENSSL_AARCH64 && !OPENSSL_STATIC_ARMCAP
diff --git third_party/boringssl/src/crypto/ex_data.c third_party/boringssl/src/crypto/ex_data.c
index 71d60a5280..7ffea5a5b9 100644
--- third_party/boringssl/src/crypto/ex_data.c
+++ third_party/boringssl/src/crypto/ex_data.c
@@ -186,7 +186,9 @@ int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int index, void *val) {
     }
   }
 
-  sk_void_set(ad->sk, index, val);
+  // expression result unused; should this cast be to 'void'?
+  // seems it should, feel free to investigate those #def
+  (void) sk_void_set(ad->sk, index, val);
   return 1;
 }
 
diff --git third_party/breakpad/breakpad/src/common/simple_string_dictionary.h third_party/breakpad/breakpad/src/common/simple_string_dictionary.h
index 9484920537..a1166a2e2d 100644
--- third_party/breakpad/breakpad/src/common/simple_string_dictionary.h
+++ third_party/breakpad/breakpad/src/common/simple_string_dictionary.h
@@ -33,7 +33,7 @@
 #include <assert.h>
 #include <string.h>
 
-#include "common/basictypes.h"
+#include "third_party/breakpad/breakpad/src/common/basictypes.h"
 
 namespace google_breakpad {
 
diff --git third_party/cacheinvalidation/src/google/cacheinvalidation/include/types.h third_party/cacheinvalidation/src/google/cacheinvalidation/include/types.h
index 2894bbfc0d..62b622937a 100644
--- third_party/cacheinvalidation/src/google/cacheinvalidation/include/types.h
+++ third_party/cacheinvalidation/src/google/cacheinvalidation/include/types.h
@@ -334,6 +334,8 @@ class Status {
      */
     PERMANENT_FAILURE
   };
+  
+  Status() : code_(SUCCESS), message_() {}
 
   /* Creates a new Status object given the code and message. */
   Status(Code code, const string& message) : code_(code), message_(message) {}
diff --git third_party/crashpad/crashpad/build/crashpad_buildconfig.gni third_party/crashpad/crashpad/build/crashpad_buildconfig.gni
index f767027fda..513c358a6c 100644
--- third_party/crashpad/crashpad/build/crashpad_buildconfig.gni
+++ third_party/crashpad/crashpad/build/crashpad_buildconfig.gni
@@ -38,7 +38,7 @@ crashpad_is_standalone = crashpad_dependencies == "standalone"
 if (crashpad_is_in_chromium) {
   crashpad_is_mac = is_mac
   crashpad_is_win = is_win
-  crashpad_is_linux = is_linux
+  crashpad_is_linux = is_linux && !is_bsd
   crashpad_is_android = is_android
   crashpad_is_fuchsia = is_fuchsia
 
diff --git third_party/crashpad/crashpad/util/misc/capture_context.h third_party/crashpad/crashpad/util/misc/capture_context.h
index 73b8058030..ad51bc012d 100644
--- third_party/crashpad/crashpad/util/misc/capture_context.h
+++ third_party/crashpad/crashpad/util/misc/capture_context.h
@@ -21,7 +21,7 @@
 #include <mach/mach.h>
 #elif defined(OS_WIN)
 #include <windows.h>
-#elif defined(OS_LINUX) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_BSD)
 #include <ucontext.h>
 #elif defined(OS_FUCHSIA)
 #include <signal.h>
@@ -35,7 +35,7 @@ using NativeCPUContext = x86_thread_state;
 #endif
 #elif defined(OS_WIN)
 using NativeCPUContext = CONTEXT;
-#elif defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_FUCHSIA)
+#elif defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_FUCHSIA) || defined(OS_BSD)
 using NativeCPUContext = ucontext_t;
 #endif  // OS_MACOSX
 
diff --git third_party/crashpad/crashpad/util/misc/metrics.cc third_party/crashpad/crashpad/util/misc/metrics.cc
index 7d191f7126..5d86bdf2dd 100644
--- third_party/crashpad/crashpad/util/misc/metrics.cc
+++ third_party/crashpad/crashpad/util/misc/metrics.cc
@@ -24,7 +24,7 @@
 #define METRICS_OS_NAME "Win"
 #elif defined(OS_ANDROID)
 #define METRICS_OS_NAME "Android"
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
 #define METRICS_OS_NAME "Linux"
 #elif defined(OS_FUCHSIA)
 #define METRICS_OS_NAME "Fuchsia"
diff --git third_party/crashpad/crashpad/util/misc/uuid.cc third_party/crashpad/crashpad/util/misc/uuid.cc
index ffd497083f..2558c33fc9 100644
--- third_party/crashpad/crashpad/util/misc/uuid.cc
+++ third_party/crashpad/crashpad/util/misc/uuid.cc
@@ -95,7 +95,7 @@ bool UUID::InitializeWithNew() {
   InitializeFromBytes(uuid);
   return true;
 #elif defined(OS_WIN) || defined(OS_LINUX) || defined(OS_ANDROID) || \
-    defined(OS_FUCHSIA)
+    defined(OS_FUCHSIA) || defined(OS_BSD)
   // Linux, Android, and Fuchsia do not provide a UUID generator in a
   // widely-available system library. On Linux and Android, uuid_generate()
   // from libuuid is not available everywhere.
diff --git third_party/crashpad/crashpad/util/posix/close_multiple.cc third_party/crashpad/crashpad/util/posix/close_multiple.cc
index 02c8a767ff..d76c674044 100644
--- third_party/crashpad/crashpad/util/posix/close_multiple.cc
+++ third_party/crashpad/crashpad/util/posix/close_multiple.cc
@@ -71,7 +71,7 @@ void CloseNowOrOnExec(int fd, bool ebadf_ok) {
 // This is an advantage over looping over all possible file descriptors, because
 // no attempt needs to be made to close file descriptors that are not open.
 bool CloseMultipleNowOrOnExecUsingFDDir(int min_fd, int preserve_fd) {
-#if defined(OS_MACOSX)
+#if defined(OS_MACOSX) || defined(OS_BSD)
   static constexpr char kFDDir[] = "/dev/fd";
 #elif defined(OS_LINUX) || defined(OS_ANDROID)
   static constexpr char kFDDir[] = "/proc/self/fd";
diff --git third_party/crashpad/crashpad/util/posix/drop_privileges.cc third_party/crashpad/crashpad/util/posix/drop_privileges.cc
index 884a411c37..bdd6151250 100644
--- third_party/crashpad/crashpad/util/posix/drop_privileges.cc
+++ third_party/crashpad/crashpad/util/posix/drop_privileges.cc
@@ -23,7 +23,7 @@ void DropPrivileges() {
   gid_t gid = getgid();
   uid_t uid = getuid();
 
-#if defined(OS_MACOSX)
+#if defined(OS_MACOSX) || defined(OS_BSD)
   // Based on the POSIX.1-2008 2013 edition documentation for setreuid() and
   // setregid(), setreuid() and setregid() alone should be sufficient to drop
   // privileges. The standard specifies that the saved ID should be set to the
diff --git third_party/crashpad/crashpad/util/posix/signals.cc third_party/crashpad/crashpad/util/posix/signals.cc
index 63764ab866..6d11a0a867 100644
--- third_party/crashpad/crashpad/util/posix/signals.cc
+++ third_party/crashpad/crashpad/util/posix/signals.cc
@@ -44,7 +44,7 @@ constexpr int kCrashSignals[] = {
 #if defined(SIGEMT)
     SIGEMT,
 #endif  // defined(SIGEMT)
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     SIGXCPU,
     SIGXFSZ,
 #endif  // defined(OS_LINUX)
@@ -84,7 +84,7 @@ constexpr int kTerminateSignals[] = {
     SIGXCPU,
     SIGXFSZ,
 #endif  // defined(OS_MACOSX)
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     SIGIO,
 #endif  // defined(OS_LINUX)
 };
@@ -214,8 +214,12 @@ bool Signals::WillSignalReraiseAutonomously(const siginfo_t* siginfo) {
          // remains. See 10.12.3 xnu-3789.41.3/bsd/kern/kern_sig.c
          // psignal_internal().
          (code > 0 &&
+#if defined(SI_ASYNCIO)
           code != SI_ASYNCIO &&
+#endif
+#if defined(SI_MESGQ)
           code != SI_MESGQ &&
+#endif
           code != SI_QUEUE &&
           code != SI_TIMER &&
           code != SI_USER &&
diff --git third_party/crashpad/crashpad/util/posix/symbolic_constants_posix.cc third_party/crashpad/crashpad/util/posix/symbolic_constants_posix.cc
index c973c14623..a4cdf80139 100644
--- third_party/crashpad/crashpad/util/posix/symbolic_constants_posix.cc
+++ third_party/crashpad/crashpad/util/posix/symbolic_constants_posix.cc
@@ -64,7 +64,7 @@ constexpr const char* kSignalNames[] = {
     "INFO",
     "USR1",
     "USR2",
-#elif defined(OS_LINUX) || defined(OS_ANDROID)
+#elif defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_BSD)
     // sed -Ene 's/^#define[[:space:]]SIG([[:alnum:]]+)[[:space:]]+[[:digit:]]{1,2}([[:space:]]|$).*/    "\1",/p'
     //     /usr/include/asm-generic/signal.h
     // and fix up by removing SIGIOT, SIGLOST, SIGUNUSED, and SIGRTMIN.
@@ -101,7 +101,7 @@ constexpr const char* kSignalNames[] = {
     "SYS",
 #endif
 };
-#if defined(OS_LINUX) || defined(OS_ANDROID)
+#if defined(OS_LINUX) || defined(OS_ANDROID) || defined(OS_BSD)
 // NSIG is 64 to account for real-time signals.
 static_assert(arraysize(kSignalNames) == 32, "kSignalNames length");
 #else
diff --git third_party/crc32c/src/src/crc32c_arm64_linux_check.h third_party/crc32c/src/src/crc32c_arm64_linux_check.h
index 6817979aac..ac5a407fff 100644
--- third_party/crc32c/src/src/crc32c_arm64_linux_check.h
+++ third_party/crc32c/src/src/crc32c_arm64_linux_check.h
@@ -29,6 +29,8 @@ extern "C" unsigned long getauxval(unsigned long type) __attribute__((weak));
 namespace crc32c {
 
 inline bool CanUseArm64Linux() {
+return false;
+#if 0
 #if HAVE_STRONG_GETAUXVAL || HAVE_WEAK_GETAUXVAL
   // From 'arch/arm64/include/uapi/asm/hwcap.h' in Linux kernel source code.
   constexpr unsigned long kHWCAP_PMULL = 1 << 4;
@@ -39,6 +41,7 @@ inline bool CanUseArm64Linux() {
 #else
   return false;
 #endif  // HAVE_STRONG_GETAUXVAL || HAVE_WEAK_GETAUXVAL
+#endif
 }
 
 }  // namespace crc32c
diff --git third_party/ffmpeg/BUILD.gn third_party/ffmpeg/BUILD.gn
index 494d33fc04..09f9f0897f 100755
--- third_party/ffmpeg/BUILD.gn
+++ third_party/ffmpeg/BUILD.gn
@@ -9,8 +9,13 @@ import("//build/buildflag_header.gni")
 import("//build/config/sanitizers/sanitizers.gni")
 
 # Path to platform configuration files.
-platform_config_root =
-    "chromium/config/$ffmpeg_branding/$os_config/$ffmpeg_arch"
+if (!is_bsd) {
+  platform_config_root =
+      "chromium/config/$ffmpeg_branding/$os_config/$ffmpeg_arch"
+} else {
+  platform_config_root =
+      "chromium/config/$ffmpeg_branding/linux/$ffmpeg_arch"
+}
 
 has_yasm_deps =
     ffmpeg_yasm_sources != [] &&
diff --git third_party/ffmpeg/libavutil/mem.c third_party/ffmpeg/libavutil/mem.c
index 2d227cddfe..79d7e01a15 100644
--- third_party/ffmpeg/libavutil/mem.c
+++ third_party/ffmpeg/libavutil/mem.c
@@ -32,9 +32,6 @@
 #include <stdint.h>
 #include <stdlib.h>
 #include <string.h>
-#if HAVE_MALLOC_H
-#include <malloc.h>
-#endif
 
 #include "avassert.h"
 #include "avutil.h"
diff --git third_party/googletest/src/googletest/include/gtest/internal/gtest-port.h third_party/googletest/src/googletest/include/gtest/internal/gtest-port.h
index fafb134b73..62c001a92b 100644
--- third_party/googletest/src/googletest/include/gtest/internal/gtest-port.h
+++ third_party/googletest/src/googletest/include/gtest/internal/gtest-port.h
@@ -841,7 +841,7 @@ typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
     (GTEST_OS_WINDOWS || GTEST_OS_CYGWIN || GTEST_OS_SYMBIAN || GTEST_OS_AIX)
 
 // Determines whether test results can be streamed to a socket.
-#if GTEST_OS_LINUX
+#if GTEST_OS_LINUX || GTEST_OS_FREEBSD
 # define GTEST_CAN_STREAM_RESULTS_ 1
 #endif
 
diff --git third_party/googletest/src/googletest/src/gtest-port.cc third_party/googletest/src/googletest/src/gtest-port.cc
index f8a0ad65a9..53a538f0b1 100644
--- third_party/googletest/src/googletest/src/gtest-port.cc
+++ third_party/googletest/src/googletest/src/gtest-port.cc
@@ -52,6 +52,11 @@
 # include <mach/vm_map.h>
 #endif  // GTEST_OS_MAC
 
+#if GTEST_OS_FREEBSD
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#endif
+
 #if GTEST_OS_QNX
 # include <devctl.h>
 # include <fcntl.h>
@@ -128,6 +133,28 @@ size_t GetThreadCount() {
   }
 }
 
+#elif GTEST_OS_FREEBSD
+
+#define KP_NLWP(kp) (kp.ki_numthreads)
+
+// Return the number of threads running in the process, or 0 to indicate that
+// we cannot detect it.
+size_t GetThreadCount() {
+  int mib[] = {
+    CTL_KERN,
+    KERN_PROC,
+    KERN_PROC_PID,
+    getpid(),
+  };
+  u_int miblen = sizeof(mib) / sizeof(mib[0]);
+  struct kinfo_proc(info);
+  size_t size = sizeof(info);
+  if (sysctl(mib, miblen, &info, &size, NULL, 0)) {
+    return 0;
+  }
+  return KP_NLWP(info);
+}
+
 #elif GTEST_OS_QNX
 
 // Returns the number of threads running in the process, or 0 to indicate that
diff --git third_party/googletest/src/googletest/src/gtest.cc third_party/googletest/src/googletest/src/gtest.cc
index 1b2aad24ab..233e8b9930 100644
--- third_party/googletest/src/googletest/src/gtest.cc
+++ third_party/googletest/src/googletest/src/gtest.cc
@@ -128,6 +128,7 @@
 
 #if GTEST_CAN_STREAM_RESULTS_
 # include <arpa/inet.h>  // NOLINT
+# include <sys/socket.h> // NOLINT
 # include <netdb.h>  // NOLINT
 # include <sys/socket.h>  // NOLINT
 # include <sys/types.h>  // NOLINT
diff --git third_party/googletest/src/googletest/test/gtest-port_test.cc third_party/googletest/src/googletest/test/gtest-port_test.cc
index 3801e5ee3c..08cb6965b4 100644
--- third_party/googletest/src/googletest/test/gtest-port_test.cc
+++ third_party/googletest/src/googletest/test/gtest-port_test.cc
@@ -296,7 +296,8 @@ TEST(FormatCompilerIndependentFileLocationTest, FormatsUknownFileAndLine) {
   EXPECT_EQ("unknown file", FormatCompilerIndependentFileLocation(NULL, -1));
 }
 
-#if GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_QNX || GTEST_OS_FUCHSIA
+#if GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_QNX || GTEST_OS_FUCHSIA || \
+    GTEST_OS_FREEBSD
 void* ThreadFunc(void* data) {
   internal::Mutex* mutex = static_cast<internal::Mutex*>(data);
   mutex->Lock();
diff --git third_party/leveldatabase/env_chromium.cc third_party/leveldatabase/env_chromium.cc
index e7c1e89193..8e38d3446c 100644
--- third_party/leveldatabase/env_chromium.cc
+++ third_party/leveldatabase/env_chromium.cc
@@ -37,7 +37,11 @@
 #include "third_party/leveldatabase/chromium_logger.h"
 #include "third_party/leveldatabase/leveldb_chrome.h"
 #include "third_party/leveldatabase/src/include/leveldb/options.h"
+#if defined(OS_BSD)
+#include <re2/re2.h>
+#else
 #include "third_party/re2/src/re2/re2.h"
+#endif
 
 using base::FilePath;
 using base::trace_event::MemoryAllocatorDump;
diff --git third_party/libXNVCtrl/NVCtrl.c third_party/libXNVCtrl/NVCtrl.c
index 6eacc95426..4fb7f3a447 100644
--- third_party/libXNVCtrl/NVCtrl.c
+++ third_party/libXNVCtrl/NVCtrl.c
@@ -27,10 +27,6 @@
  * libXNVCtrl library properly protects the Display connection.
  */
 
-#if !defined(XTHREADS)
-#define XTHREADS
-#endif /* XTHREADS */
-
 #define NEED_EVENTS
 #define NEED_REPLIES
 #include <stdint.h>
@@ -39,6 +35,11 @@
 #include <X11/Xutil.h>
 #include <X11/extensions/Xext.h>
 #include <X11/extensions/extutil.h>
+
+#if !defined(XTHREADS)
+#define XTHREADS
+#endif /* XTHREADS */
+
 #include "NVCtrlLib.h"
 #include "nv_control.h"
 
diff --git third_party/libphonenumber/dist/cpp/src/phonenumbers/base/memory/singleton.h third_party/libphonenumber/dist/cpp/src/phonenumbers/base/memory/singleton.h
index 5fd3e4c6e4..99a1fdbf4e 100644
--- third_party/libphonenumber/dist/cpp/src/phonenumbers/base/memory/singleton.h
+++ third_party/libphonenumber/dist/cpp/src/phonenumbers/base/memory/singleton.h
@@ -56,7 +56,7 @@ template <class T> boost::once_flag Singleton<T>::flag = BOOST_ONCE_INIT;
 #include "phonenumbers/base/logging.h"
 #include "phonenumbers/base/thread_checker.h"
 
-#if !defined(__linux__) && !defined(__APPLE__)
+#if !defined(__linux__) && !defined(__APPLE__) && !defined(__FreeBSD__) && !defined(__OpenBSD__)
 
 namespace i18n {
 namespace phonenumbers {
diff --git third_party/libphonenumber/dist/cpp/src/phonenumbers/base/synchronization/lock.h third_party/libphonenumber/dist/cpp/src/phonenumbers/base/synchronization/lock.h
index 296421cd56..d85cffbd92 100644
--- third_party/libphonenumber/dist/cpp/src/phonenumbers/base/synchronization/lock.h
+++ third_party/libphonenumber/dist/cpp/src/phonenumbers/base/synchronization/lock.h
@@ -37,7 +37,7 @@ typedef boost::mutex::scoped_lock AutoLock;
 // Dummy lock implementation on non-POSIX platforms. If you are running on a
 // different platform and care about thread-safety, please compile with
 // -DI18N_PHONENUMBERS_USE_BOOST.
-#if !defined(__linux__) && !defined(__APPLE__)
+#if !defined(__linux__) && !defined(__APPLE__) && !defined(__FreeBSD__) && !defined(__OpenBSD__)
 
 namespace i18n {
 namespace phonenumbers {
diff --git third_party/libphonenumber/dist/cpp/src/phonenumbers/base/thread_checker.h third_party/libphonenumber/dist/cpp/src/phonenumbers/base/thread_checker.h
index b7a3523434..14a5d98878 100644
--- third_party/libphonenumber/dist/cpp/src/phonenumbers/base/thread_checker.h
+++ third_party/libphonenumber/dist/cpp/src/phonenumbers/base/thread_checker.h
@@ -23,6 +23,7 @@
 // user of the library know that it can't be used in a thread-safe manner when
 // it is not depending on Boost.
 #if !defined(__linux__) && !defined(__APPLE__) && \
+    !defined(__FreeBSD__) && !defined(__OpenBSD__) && \
     !defined(I18N_PHONENUMBERS_NO_THREAD_SAFETY)
 #error Building without Boost, please provide \
        -DI18N_PHONENUMBERS_NO_THREAD_SAFETY
@@ -31,7 +32,7 @@
 #endif
 
 #if !defined(NDEBUG) && !defined(I18N_PHONENUMBERS_USE_BOOST) && \
-    (defined(__linux__) || defined(__apple__))
+    (defined(__linux__) || defined(__apple__)) || defined(__FreeBSD__) || defined(__OpenBSD__)
 
 #include <pthread.h>
 
diff --git third_party/libyuv/include/libyuv/row.h third_party/libyuv/include/libyuv/row.h
index 646a6abb10..917e5a4492 100644
--- third_party/libyuv/include/libyuv/row.h
+++ third_party/libyuv/include/libyuv/row.h
@@ -156,10 +156,14 @@ extern "C" {
 #define HAS_ARGBSHADEROW_SSE2
 #define HAS_ARGBSUBTRACTROW_SSE2
 #define HAS_ARGBUNATTENUATEROW_SSE2
+#if !(defined(__i386__) && defined(__GNUC__))
 #define HAS_BLENDPLANEROW_SSSE3
+#endif
 #define HAS_COMPUTECUMULATIVESUMROW_SSE2
 #define HAS_CUMULATIVESUMTOAVERAGEROW_SSE2
+#if !(defined(__i386__) && defined(__GNUC__))
 #define HAS_INTERPOLATEROW_SSSE3
+#endif
 #define HAS_RGBCOLORTABLEROW_X86
 #define HAS_SOBELROW_SSE2
 #define HAS_SOBELTOPLANEROW_SSE2
@@ -205,7 +209,9 @@ extern "C" {
 #define HAS_I422TORGB565ROW_AVX2
 #define HAS_I422TORGBAROW_AVX2
 #define HAS_I444TOARGBROW_AVX2
+#if !(defined(__i386__) && defined(__GNUC__))
 #define HAS_INTERPOLATEROW_AVX2
+#endif
 #define HAS_J422TOARGBROW_AVX2
 #define HAS_MERGEUVROW_AVX2
 #define HAS_MIRRORROW_AVX2
@@ -230,7 +236,9 @@ extern "C" {
 #define HAS_ARGBMULTIPLYROW_AVX2
 #define HAS_ARGBSUBTRACTROW_AVX2
 #define HAS_ARGBUNATTENUATEROW_AVX2
+#if !(defined(__i386__) && defined(__GNUC__))
 #define HAS_BLENDPLANEROW_AVX2
+#endif
 
 #if defined(__x86_64__) || !defined(__pic__) || defined(__clang__) || \
     defined(_MSC_VER)
diff --git third_party/mesa/BUILD.gn third_party/mesa/BUILD.gn
index 875e67ca28..088a7178d3 100644
--- third_party/mesa/BUILD.gn
+++ third_party/mesa/BUILD.gn
@@ -90,6 +90,10 @@ config("mesa_internal_config") {
     defines += [ "_GNU_SOURCE" ]
   }
 
+  if (is_bsd) {
+    defines += [ "_BSD_SOURCE" ]
+  }
+
   if (is_win) {
     defines += [
       # Generated files use const only if __cplusplus or __STDC__ is defined.
diff --git third_party/node/node.py third_party/node/node.py
index 8097e2c49a..19d90e3267 100755
--- third_party/node/node.py
+++ third_party/node/node.py
@@ -12,6 +12,8 @@ import sys
 def GetBinaryPath():
   return os_path.join(os_path.dirname(__file__), *{
     'Darwin': ('mac', 'node-darwin-x64', 'bin', 'node'),
+    'DragonFly': ('dragonfly', 'node-dragonfly-x64', 'bin', 'node'),
+    'FreeBSD': ('freebsd', 'node-freebsd-x64', 'bin', 'node'),
     'Linux': ('linux', 'node-linux-x64', 'bin', 'node'),
     'Windows': ('win', 'node.exe'),
   }[platform.system()])
diff --git third_party/node/node_modules/polymer-bundler/lib/constants.js.orig third_party/node/node_modules/polymer-bundler/lib/constants.js.orig
deleted file mode 100644
index 1c80a19f57..0000000000
--- third_party/node/node_modules/polymer-bundler/lib/constants.js.orig
+++ /dev/null
@@ -1,24 +0,0 @@
-"use strict";
-/**
- * @license
- * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
- * This code may only be used under the BSD style license found at
- * http://polymer.github.io/LICENSE.txt
- * The complete set of authors may be found at
- * http://polymer.github.io/AUTHORS.txt
- * The complete set of contributors may be found at
- * http://polymer.github.io/CONTRIBUTORS.txt
- * Code distributed by Google as part of the polymer project is also
- * subject to an additional IP rights grant found at
- * http://polymer.github.io/PATENTS.txt
- */
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.default = {
-    EXTERNAL_URL: /^(?:https?:)?\/\//,
-    ABS_URL: /(^\/)|(^#)|(^[\w-\d]*:)/,
-    URL: /url\([^)]*\)/g,
-    URL_ATTR: ['href', 'src', 'action', 'style', 'assetpath'],
-    URL_TEMPLATE: '{{.*}}|\\[\\[.*\\]\\]',
-    OLD_POLYMER: 'This version of polymer-bundler is not compatible with Polymer < 0.8. Please use vulcanize 0.7.x.'
-};
-//# sourceMappingURL=constants.js.map
\ No newline at end of file
diff --git third_party/pdfium/core/fxcrt/fx_system.h third_party/pdfium/core/fxcrt/fx_system.h
index 8ad23a19c7..94c5fed568 100644
--- third_party/pdfium/core/fxcrt/fx_system.h
+++ third_party/pdfium/core/fxcrt/fx_system.h
@@ -41,7 +41,7 @@
 #elif defined(_WIN64)
 #define _FX_OS_ _FX_OS_WIN64_
 #define _FX_PLATFORM_ _FX_PLATFORM_WINDOWS_
-#elif defined(__linux__)
+#elif defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)
 #define _FX_OS_ _FX_OS_LINUX_
 #define _FX_PLATFORM_ _FX_PLATFORM_LINUX_
 #elif defined(__APPLE__)
diff --git third_party/pdfium/core/fxge/fx_ge_linux.cpp third_party/pdfium/core/fxge/fx_ge_linux.cpp
index d2da781881..9b4ae458ca 100644
--- third_party/pdfium/core/fxge/fx_ge_linux.cpp
+++ third_party/pdfium/core/fxge/fx_ge_linux.cpp
@@ -146,9 +146,8 @@ std::unique_ptr<SystemFontInfoIface> SystemFontInfoIface::CreateDefault(
     const char** pUserPaths) {
   auto pInfo = pdfium::MakeUnique<CFX_LinuxFontInfo>();
   if (!pInfo->ParseFontCfg(pUserPaths)) {
-    pInfo->AddPath("/usr/share/fonts");
-    pInfo->AddPath("/usr/share/X11/fonts/Type1");
-    pInfo->AddPath("/usr/share/X11/fonts/TTF");
+    pInfo->AddPath("/usr/local/share/fonts/Type1");
+    pInfo->AddPath("/usr/local/share/fonts/TTF");
     pInfo->AddPath("/usr/local/share/fonts");
   }
   return std::move(pInfo);
diff --git third_party/pdfium/fxjs/JS_Define.cpp third_party/pdfium/fxjs/JS_Define.cpp
index d5b1cefeda..1296018d83 100644
--- third_party/pdfium/fxjs/JS_Define.cpp
+++ third_party/pdfium/fxjs/JS_Define.cpp
@@ -30,7 +30,12 @@ double GetLocalTZA() {
   long timezone = 0;
   _get_timezone(&timezone);
 #endif  // _FX_PLATFORM_ == _FX_PLATFORM_WINDOWS_
+#ifdef __FreeBSD__
+  struct tm *lt;
+  return (double)(-(lt->tm_gmtoff * 1000));
+#else
   return (double)(-(timezone * 1000));
+#endif
 }
 
 int GetDaylightSavingTA(double d) {
diff --git third_party/pdfium/fxjs/cjs_publicmethods.cpp third_party/pdfium/fxjs/cjs_publicmethods.cpp
index 6f49940494..deacfef88a 100644
--- third_party/pdfium/fxjs/cjs_publicmethods.cpp
+++ third_party/pdfium/fxjs/cjs_publicmethods.cpp
@@ -71,6 +71,103 @@ const wchar_t* const kFullMonths[] = {L"January", L"February", L"March",
                                       L"July",    L"August",   L"September",
                                       L"October", L"November", L"December"};
 
+#if defined(__FreeBSD__) || defined(__DragonFly__)
+/*
+ * cvt.c - IEEE floating point formatting routines for FreeBSD
+ * from GNU libc-4.6.27
+ */
+
+/*
+ *    ap_ecvt converts to decimal
+ *      the number of digits is specified by ndigit
+ *      decpt is set to the position of the decimal point
+ *      sign is set to 0 for positive, 1 for negative
+ */
+
+#define	NDIG	80
+
+static char *
+     ap_cvt(double arg, int ndigits, int *decpt, int *sign, int eflag)
+{
+    register int r2;
+    double fi, fj;
+    register char *p, *p1;
+    static char buf[NDIG];
+
+    if (ndigits >= NDIG - 1)
+	ndigits = NDIG - 2;
+    r2 = 0;
+    *sign = 0;
+    p = &buf[0];
+    if (arg < 0) {
+	*sign = 1;
+	arg = -arg;
+    }
+    arg = modf(arg, &fi);
+    p1 = &buf[NDIG];
+    /*
+     * Do integer part
+     */
+    if (fi != 0) {
+	p1 = &buf[NDIG];
+	while (fi != 0) {
+	    fj = modf(fi / 10, &fi);
+	    *--p1 = (int) ((fj + .03) * 10) + '0';
+	    r2++;
+	}
+	while (p1 < &buf[NDIG])
+	    *p++ = *p1++;
+    }
+    else if (arg > 0) {
+	while ((fj = arg * 10) < 1) {
+	    arg = fj;
+	    r2--;
+	}
+    }
+    p1 = &buf[ndigits];
+    if (eflag == 0)
+	p1 += r2;
+    *decpt = r2;
+    if (p1 < &buf[0]) {
+	buf[0] = '\0';
+        return (buf);
+    }
+    while (p <= p1 && p < &buf[NDIG]) {
+	arg *= 10;
+	arg = modf(arg, &fj);
+	*p++ = (int) fj + '0';
+    }
+    if (p1 >= &buf[NDIG]) {
+	buf[NDIG - 1] = '\0';
+	return (buf);
+    }
+    p = p1;
+    *p1 += 5;
+    while (*p1 > '9') {
+	*p1 = '0';
+	if (p1 > buf)
+	    ++ * --p1;
+	else {
+	    *p1 = '1';
+	    (*decpt)++;
+	    if (eflag == 0) {
+		if (p > buf)
+		    *p = '0';
+		p++;
+	    }
+	}
+    }
+    *p = '\0';
+    return (buf);
+}
+
+static char *
+     fcvt(double arg, int ndigits, int *decpt, int *sign)
+{
+     return (ap_cvt(arg, ndigits, decpt, sign, 0));
+}
+#endif // defined(__FreeBSD__)
+
 template <typename T>
 T StrTrim(const T& str) {
   T result = str;
diff --git third_party/pdfium/third_party/base/logging.h third_party/pdfium/third_party/base/logging.h
index 38b0dd9a17..c060828614 100644
--- third_party/pdfium/third_party/base/logging.h
+++ third_party/pdfium/third_party/base/logging.h
@@ -10,7 +10,7 @@
 
 #ifndef _WIN32
 #define NULL_DEREF_IF_POSSIBLE \
-  *(reinterpret_cast<volatile char*>(NULL) + 42) = 0x42;
+  *(reinterpret_cast<volatile char*>(__null) + 42) = 0x42;
 #else
 #define NULL_DEREF_IF_POSSIBLE
 #endif
diff --git third_party/pdfium/xfa/fgas/font/cfgas_fontmgr.cpp third_party/pdfium/xfa/fgas/font/cfgas_fontmgr.cpp
index d7acc62eef..838834201c 100644
--- third_party/pdfium/xfa/fgas/font/cfgas_fontmgr.cpp
+++ third_party/pdfium/xfa/fgas/font/cfgas_fontmgr.cpp
@@ -252,8 +252,8 @@ namespace {
 
 constexpr const char* g_FontFolders[] = {
 #if _FX_PLATFORM_ == _FX_PLATFORM_LINUX_
-    "/usr/share/fonts", "/usr/share/X11/fonts/Type1",
-    "/usr/share/X11/fonts/TTF", "/usr/local/share/fonts",
+    "/usr/local/share/fonts/Type1",
+    "/usr/local/share/fonts/TTF", "/usr/local/share/fonts",
 #elif _FX_PLATFORM_ == _FX_PLATFORM_APPLE_
     "~/Library/Fonts", "/Library/Fonts", "/System/Library/Fonts",
 #elif _FX_PLATFORM_ == _FX_PLATFORM_ANDROID_
diff --git third_party/perfetto/include/perfetto/base/build_config.h third_party/perfetto/include/perfetto/base/build_config.h
index e083415c70..6b5d99689f 100644
--- third_party/perfetto/include/perfetto/base/build_config.h
+++ third_party/perfetto/include/perfetto/base/build_config.h
@@ -28,6 +28,7 @@
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 1
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FREEBSD() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
 #elif defined(__APPLE__)
@@ -36,22 +37,25 @@
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
-#elif defined(__linux__)
+#elif defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 1
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FREEBSD() 1
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
 #elif defined(_WIN32)
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FREEBSD() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 1
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
 #elif defined(__EMSCRIPTEN__)
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
+#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FREEBSD() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
 #define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 1
 #else
diff --git third_party/perfetto/include/perfetto/base/watchdog_posix.h third_party/perfetto/include/perfetto/base/watchdog_posix.h
index 17d6fe26a6..46264416ed 100644
--- third_party/perfetto/include/perfetto/base/watchdog_posix.h
+++ third_party/perfetto/include/perfetto/base/watchdog_posix.h
@@ -45,7 +45,7 @@ class Watchdog {
     Timer(const Timer&) = delete;
     Timer& operator=(const Timer&) = delete;
 
-    timer_t timerid_ = nullptr;
+    timer_t timerid_ = 0;
   };
   virtual ~Watchdog();
 
diff --git third_party/perfetto/src/base/unix_task_runner.cc third_party/perfetto/src/base/unix_task_runner.cc
index 5a47b7aad4..7ba729008b 100644
--- third_party/perfetto/src/base/unix_task_runner.cc
+++ third_party/perfetto/src/base/unix_task_runner.cc
@@ -45,7 +45,7 @@ UnixTaskRunner::UnixTaskRunner() {
   control_read_.reset(pipe_fds[0]);
   control_write_.reset(pipe_fds[1]);
 
-#if PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX)
+#if PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) && !PERFETTO_BUILDFLAG(PERFETTO_OS_FREEBSD)
   // We are never expecting to have more than a few bytes in the wake-up pipe.
   // Reduce the buffer size on Linux. Note that this gets rounded up to the page
   // size.
diff --git third_party/perfetto/src/tracing/core/service_impl.cc third_party/perfetto/src/tracing/core/service_impl.cc
index b67eb56760..495eda2828 100644
--- third_party/perfetto/src/tracing/core/service_impl.cc
+++ third_party/perfetto/src/tracing/core/service_impl.cc
@@ -1041,7 +1041,7 @@ void ServiceImpl::MaybeSnapshotClocks(TracingSession* tracing_session,
   protos::TrustedPacket packet;
   protos::ClockSnapshot* clock_snapshot = packet.mutable_clock_snapshot();
 
-#if !PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX) && !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
+#if !PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX) && !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN) && !PERFETTO_BUILDFLAG(PERFETTO_OS_FREEBSD)
   struct {
     clockid_t id;
     protos::ClockSnapshot::Clock::Type type;
diff --git third_party/skia/src/core/SkCpu.cpp third_party/skia/src/core/SkCpu.cpp
index b4b2d6802b..cd2a5c4e8b 100644
--- third_party/skia/src/core/SkCpu.cpp
+++ third_party/skia/src/core/SkCpu.cpp
@@ -78,6 +78,8 @@
     #include <sys/auxv.h>
 
     static uint32_t read_cpu_features() {
+return 0;
+#if 0
         const uint32_t kHWCAP_CRC32   = (1<< 7),
                        kHWCAP_ASIMDHP = (1<<10);
 
@@ -86,6 +88,7 @@
         if (hwcaps & kHWCAP_CRC32  ) { features |= SkCpu::CRC32; }
         if (hwcaps & kHWCAP_ASIMDHP) { features |= SkCpu::ASIMDHP; }
         return features;
+#endif
     }
 
 #elif defined(SK_CPU_ARM32) && __has_include(<sys/auxv.h>) && \
diff --git third_party/skia/src/gpu/GrAutoLocaleSetter.h third_party/skia/src/gpu/GrAutoLocaleSetter.h
index c373b78e97..18a66ca810 100644
--- third_party/skia/src/gpu/GrAutoLocaleSetter.h
+++ third_party/skia/src/gpu/GrAutoLocaleSetter.h
@@ -25,7 +25,7 @@
 #define HAVE_XLOCALE 0
 #endif
 
-#if defined(SK_BUILD_FOR_ANDROID) || defined(__UCLIBC__) || defined(_NEWLIB_VERSION)
+#if defined(SK_BUILD_FOR_ANDROID) || defined(__UCLIBC__) || defined(_NEWLIB_VERSION) || defined(__FreeBSD__)
 #define HAVE_LOCALE_T 0
 #else
 #define HAVE_LOCALE_T 1
diff --git third_party/skia/src/images/SkJpegEncoder.cpp third_party/skia/src/images/SkJpegEncoder.cpp
index 606b553537..1db3822f77 100644
--- third_party/skia/src/images/SkJpegEncoder.cpp
+++ third_party/skia/src/images/SkJpegEncoder.cpp
@@ -85,9 +85,14 @@ bool SkJpegEncoderMgr::setParams(const SkImageInfo& srcInfo, const SkJpegEncoder
         }
     };
 
+#ifdef JCS_EXTENSIONS
     J_COLOR_SPACE jpegColorType = JCS_EXT_RGBA;
+#else
+    J_COLOR_SPACE jpegColorType = JCS_RGB;
+#endif
     int numComponents = 0;
     switch (srcInfo.colorType()) {
+#ifdef JCS_EXTENSIONS
         case kRGBA_8888_SkColorType:
             fProc = chooseProc8888();
             jpegColorType = JCS_EXT_RGBA;
@@ -98,6 +103,7 @@ bool SkJpegEncoderMgr::setParams(const SkImageInfo& srcInfo, const SkJpegEncoder
             jpegColorType = JCS_EXT_BGRA;
             numComponents = 4;
             break;
+#endif
         case kRGB_565_SkColorType:
             fProc = transform_scanline_565;
             jpegColorType = JCS_RGB;
@@ -117,6 +123,7 @@ bool SkJpegEncoderMgr::setParams(const SkImageInfo& srcInfo, const SkJpegEncoder
             jpegColorType = JCS_GRAYSCALE;
             numComponents = 1;
             break;
+#ifdef JCS_EXTENSIONS
         case kRGBA_F16_SkColorType:
             if (!srcInfo.colorSpace() ||
                     SkTransferFunctionBehavior::kRespect != options.fBlendBehavior) {
@@ -133,6 +140,7 @@ bool SkJpegEncoderMgr::setParams(const SkImageInfo& srcInfo, const SkJpegEncoder
             jpegColorType = JCS_EXT_RGBA;
             numComponents = 4;
             break;
+#endif
         default:
             return false;
     }
diff --git third_party/skia/src/opts/SkRasterPipeline_opts.h third_party/skia/src/opts/SkRasterPipeline_opts.h
index 9fe3d941a9..1914d22773 100644
--- third_party/skia/src/opts/SkRasterPipeline_opts.h
+++ third_party/skia/src/opts/SkRasterPipeline_opts.h
@@ -653,7 +653,7 @@ SI F approx_powf(F x, F y) {
 }
 
 SI F from_half(U16 h) {
-#if defined(__aarch64__) && !defined(SK_BUILD_FOR_GOOGLE3)  // Temporary workaround for some Google3 builds.
+#if defined(JUMPER_IS_NEON) && defined(__aarch64__) && !defined(SK_BUILD_FOR_GOOGLE3)  // Temporary workaround for some Google3 builds.
     return vcvt_f32_f16(h);
 
 #elif defined(JUMPER_IS_HSW) || defined(JUMPER_IS_AVX512)
@@ -673,7 +673,7 @@ SI F from_half(U16 h) {
 }
 
 SI U16 to_half(F f) {
-#if defined(__aarch64__) && !defined(SK_BUILD_FOR_GOOGLE3)  // Temporary workaround for some Google3 builds.
+#if defined(JUMPER_IS_NEON) && defined(__aarch64__) && !defined(SK_BUILD_FOR_GOOGLE3)  // Temporary workaround for some Google3 builds.
     return vcvt_f16_f32(f);
 
 #elif defined(JUMPER_IS_HSW) || defined(JUMPER_IS_AVX512)
diff --git third_party/skia/src/ports/SkFontHost_FreeType.cpp third_party/skia/src/ports/SkFontHost_FreeType.cpp
index 3e8e9576dd..9d219f4fb2 100644
--- third_party/skia/src/ports/SkFontHost_FreeType.cpp
+++ third_party/skia/src/ports/SkFontHost_FreeType.cpp
@@ -99,8 +99,6 @@ public:
     FreeTypeLibrary()
         : fGetVarDesignCoordinates(nullptr)
         , fLibrary(nullptr)
-        , fIsLCDSupported(false)
-        , fLCDExtra(0)
     {
         if (FT_New_Library(&gFTMemory, &fLibrary)) {
             return;
@@ -147,12 +145,7 @@ public:
         }
 #endif
 
-        // Setup LCD filtering. This reduces color fringes for LCD smoothed glyphs.
-        // The default has changed over time, so this doesn't mean the same thing to all users.
-        if (FT_Library_SetLcdFilter(fLibrary, FT_LCD_FILTER_DEFAULT) == 0) {
-            fIsLCDSupported = true;
-            fLCDExtra = 2; //Using a filter adds one full pixel to each side.
-        }
+        FT_Library_SetLcdFilter(fLibrary, FT_LCD_FILTER_DEFAULT);
     }
     ~FreeTypeLibrary() {
         if (fLibrary) {
@@ -161,8 +154,6 @@ public:
     }
 
     FT_Library library() { return fLibrary; }
-    bool isLCDSupported() { return fIsLCDSupported; }
-    int lcdExtra() { return fLCDExtra; }
 
     // FT_Get_{MM,Var}_{Blend,Design}_Coordinates were added in FreeType 2.7.1.
     // Prior to this there was no way to get the coordinates out of the FT_Face.
@@ -173,8 +164,6 @@ public:
 
 private:
     FT_Library fLibrary;
-    bool fIsLCDSupported;
-    int fLCDExtra;
 
     // FT_Library_SetLcdFilterWeights was introduced in FreeType 2.4.0.
     // The following platforms provide FreeType of at least 2.4.0.
@@ -653,17 +642,6 @@ void SkTypeface_FreeType::onFilterRec(SkScalerContextRec* rec) const {
         rec->fTextSize = SkIntToScalar(1 << 14);
     }
 
-    if (isLCD(*rec)) {
-        // TODO: re-work so that FreeType is set-up and selected by the SkFontMgr.
-        SkAutoMutexAcquire ama(gFTMutex);
-        ref_ft_library();
-        if (!gFTLibrary->isLCDSupported()) {
-            // If the runtime Freetype library doesn't support LCD, disable it here.
-            rec->fMaskFormat = SkMask::kA8_Format;
-        }
-        unref_ft_library();
-    }
-
     SkPaint::Hinting h = rec->getHinting();
     if (SkPaint::kFull_Hinting == h && !isLCD(*rec)) {
         // collapse full->normal hinting if we're not doing LCD
@@ -1054,11 +1032,11 @@ bool SkScalerContext_FreeType::getCBoxForLetter(char letter, FT_BBox* bbox) {
 void SkScalerContext_FreeType::updateGlyphIfLCD(SkGlyph* glyph) {
     if (isLCD(fRec)) {
         if (fLCDIsVert) {
-            glyph->fHeight += gFTLibrary->lcdExtra();
-            glyph->fTop -= gFTLibrary->lcdExtra() >> 1;
+            glyph->fHeight += 2;
+            glyph->fTop -= 1;
         } else {
-            glyph->fWidth += gFTLibrary->lcdExtra();
-            glyph->fLeft -= gFTLibrary->lcdExtra() >> 1;
+            glyph->fWidth += 2;
+            glyph->fLeft -= 1;
         }
     }
 }
diff --git third_party/skia/src/ports/SkOSFile_stdio.cpp third_party/skia/src/ports/SkOSFile_stdio.cpp
index d8541c21c0..e74f94a6b3 100644
--- third_party/skia/src/ports/SkOSFile_stdio.cpp
+++ third_party/skia/src/ports/SkOSFile_stdio.cpp
@@ -129,7 +129,7 @@ void sk_fflush(FILE* f) {
 
 void sk_fsync(FILE* f) {
 #if !defined(_WIN32) && !defined(SK_BUILD_FOR_ANDROID) && !defined(__UCLIBC__) \
-        && !defined(_NEWLIB_VERSION)
+        && !defined(_NEWLIB_VERSION) && !defined(__FreeBSD__)
     int fd = fileno(f);
     fsync(fd);
 #endif
diff --git third_party/skia/src/sksl/SkSLString.h third_party/skia/src/sksl/SkSLString.h
index 417a28b23a..63ce92fe06 100644
--- third_party/skia/src/sksl/SkSLString.h
+++ third_party/skia/src/sksl/SkSLString.h
@@ -22,6 +22,8 @@
     #include "SkString.h"
 #endif
 
+#include <stdarg.h>
+
 namespace SkSL {
 
 // Represents a (not necessarily null-terminated) slice of a string.
diff --git third_party/sqlite/BUILD.gn third_party/sqlite/BUILD.gn
index 46abef12a0..fd141e0c1d 100644
--- third_party/sqlite/BUILD.gn
+++ third_party/sqlite/BUILD.gn
@@ -155,7 +155,7 @@ config("sqlite_warnings") {
     # sqlite3Fts3InitTok).
     cflags += [ "-Wno-unused-function" ]
   }
-  if (is_linux) {
+  if (is_linux && !is_bsd) {
     cflags += [
       # SQLite doesn"t believe in compiler warnings,
       # preferring testing.
@@ -208,7 +208,7 @@ component("chromium_sqlite3") {
     }
   }
 
-  if (is_linux || is_android) {
+  if ((is_linux && !is_bsd) || is_android) {
     defines += [
       # Linux provides fdatasync(), a faster equivalent of fsync().
       "fdatasync=fdatasync",
@@ -243,7 +243,7 @@ component("chromium_sqlite3") {
     ":sqlite_warnings",
   ]
 
-  if (is_linux) {
+  if (is_linux && !is_bsd) {
     libs = [ "dl" ]
   } else if (is_mac || is_ios) {
     libs = [ "CoreFoundation.framework" ]
diff --git third_party/swiftshader/BUILD.gn third_party/swiftshader/BUILD.gn
index 7af9f6af24..2f0d263787 100644
--- third_party/swiftshader/BUILD.gn
+++ third_party/swiftshader/BUILD.gn
@@ -100,7 +100,6 @@ config("swiftshader_config") {
 
     if (is_linux) {
       ldflags = [
-        "-Wl,--hash-style=both",
         "-Wl,--gc-sections",
       ]
 
diff --git third_party/swiftshader/src/Common/Configurator.cpp third_party/swiftshader/src/Common/Configurator.cpp
index 445305cb87..8e787b298b 100644
--- third_party/swiftshader/src/Common/Configurator.cpp
+++ third_party/swiftshader/src/Common/Configurator.cpp
@@ -42,6 +42,9 @@ namespace sw
 
 	bool Configurator::readFile()
 	{
+#if defined(__FreeBSD__)
+                return false;
+#endif      
 		#if defined(__unix__)
 			if(access(path.c_str(), R_OK) != 0)
 			{
diff --git third_party/swiftshader/src/Common/MutexLock.hpp third_party/swiftshader/src/Common/MutexLock.hpp
index 3a071c906e..806996fbd0 100644
--- third_party/swiftshader/src/Common/MutexLock.hpp
+++ third_party/swiftshader/src/Common/MutexLock.hpp
@@ -17,7 +17,7 @@
 
 #include "Thread.hpp"
 
-#if defined(__linux__)
+#if defined(__linux__) || defined(__FreeBSD__)
 // Use a pthread mutex on Linux. Since many processes may use SwiftShader
 // at the same time it's best to just have the scheduler overhead.
 #include <pthread.h>
diff --git third_party/swiftshader/src/Common/SharedLibrary.hpp third_party/swiftshader/src/Common/SharedLibrary.hpp
index 85e5e7d28c..a726eed23e 100644
--- third_party/swiftshader/src/Common/SharedLibrary.hpp
+++ third_party/swiftshader/src/Common/SharedLibrary.hpp
@@ -129,7 +129,7 @@ void *loadLibrary(const std::string &libraryDirectory, const char *(&names)[n],
 
 	inline void *getLibraryHandle(const char *path)
 	{
-		#ifdef __ANDROID__
+		#if defined( __ANDROID__) || defined(__FreeBSD__)
 			// bionic doesn't support RTLD_NOLOAD before L
 			return dlopen(path, RTLD_NOW | RTLD_LOCAL);
 		#else
diff --git third_party/swiftshader/src/Main/SwiftConfig.cpp third_party/swiftshader/src/Main/SwiftConfig.cpp
index 1c22394a54..b8af5b8139 100644
--- third_party/swiftshader/src/Main/SwiftConfig.cpp
+++ third_party/swiftshader/src/Main/SwiftConfig.cpp
@@ -762,7 +762,11 @@ namespace sw
 		struct stat status;
 		int lastModified = ini.getInteger("LastModified", "Time", 0);
 
+#if !defined(__FreeBSD__)
 		bool noConfig = stat("SwiftShader.ini", &status) != 0;
+#else
+                bool noConfig = false;
+#endif
 		newConfig = !noConfig && abs((int)status.st_mtime - lastModified) > 1;
 
 		if(disableServerOverride)
diff --git third_party/swiftshader/src/OpenGL/compiler/osinclude.h third_party/swiftshader/src/OpenGL/compiler/osinclude.h
index 54d4c75025..46cbcf125f 100644
--- third_party/swiftshader/src/OpenGL/compiler/osinclude.h
+++ third_party/swiftshader/src/OpenGL/compiler/osinclude.h
@@ -26,7 +26,7 @@
       defined(__FreeBSD__) || defined(__OpenBSD__) || \
       defined(__sun) || defined(ANDROID) || \
       defined(__GLIBC__) || defined(__GNU__) || \
-      defined(__QNX__) || defined(__Fuchsia__)
+      defined(__QNX__) || defined(__Fuchsia__) || defined(__DragonFly__)
 #define ANGLE_OS_POSIX
 #else
 #error Unsupported platform.
diff --git third_party/swiftshader/src/OpenGL/libEGL/Display.cpp third_party/swiftshader/src/OpenGL/libEGL/Display.cpp
index 1f6b37faf5..1da1b05ff0 100644
--- third_party/swiftshader/src/OpenGL/libEGL/Display.cpp
+++ third_party/swiftshader/src/OpenGL/libEGL/Display.cpp
@@ -30,7 +30,7 @@
 #include <sys/ioctl.h>
 #include <linux/fb.h>
 #include <fcntl.h>
-#elif defined(__linux__)
+#elif defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)
 #include "Main/libX11.hpp"
 #elif defined(__APPLE__)
 #include "OSXUtils.hpp"
@@ -66,7 +66,8 @@ Display *Display::get(EGLDisplay dpy)
 
 	static void *nativeDisplay = nullptr;
 
-	#if defined(__linux__) && !defined(__ANDROID__)
+	#if (defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)) && \
+		!defined(__ANDROID__)
 		// Even if the application provides a native display handle, we open (and close) our own connection
 		if(!nativeDisplay && dpy != HEADLESS_DISPLAY && libX11 && libX11->XOpenDisplay)
 		{
@@ -89,7 +90,8 @@ Display::~Display()
 {
 	terminate();
 
-	#if defined(__linux__) && !defined(__ANDROID__)
+	#if (defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)) && \
+		!defined(__ANDROID__)
 		if(nativeDisplay && libX11->XCloseDisplay)
 		{
 			libX11->XCloseDisplay((::Display*)nativeDisplay);
@@ -677,7 +679,7 @@ bool Display::isValidWindow(EGLNativeWindowType window)
 			return false;
 		}
 		return true;
-	#elif defined(__linux__)
+	#elif defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)
 		if(nativeDisplay)
 		{
 			XWindowAttributes windowAttributes;
@@ -843,7 +845,7 @@ sw::Format Display::getDisplayFormat() const
 
 		// No framebuffer device found, or we're in user space
 		return sw::FORMAT_X8B8G8R8;
-	#elif defined(__linux__)
+	#elif defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)
 		if(nativeDisplay)
 		{
 			Screen *screen = libX11->XDefaultScreenOfDisplay((::Display*)nativeDisplay);
diff --git third_party/swiftshader/src/OpenGL/libEGL/Surface.cpp third_party/swiftshader/src/OpenGL/libEGL/Surface.cpp
index 237804bfbe..dd37ed3319 100644
--- third_party/swiftshader/src/OpenGL/libEGL/Surface.cpp
+++ third_party/swiftshader/src/OpenGL/libEGL/Surface.cpp
@@ -26,7 +26,8 @@
 #include "common/debug.h"
 #include "Main/FrameBuffer.hpp"
 
-#if defined(__linux__) && !defined(__ANDROID__)
+#if (defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)) && \
+	!defined(__ANDROID__)
 #include "Main/libX11.hpp"
 #elif defined(_WIN32)
 #include <tchar.h>
@@ -341,7 +342,7 @@ bool WindowSurface::checkForResize()
 	#elif defined(__ANDROID__)
 		int windowWidth;  window->query(window, NATIVE_WINDOW_WIDTH, &windowWidth);
 		int windowHeight; window->query(window, NATIVE_WINDOW_HEIGHT, &windowHeight);
-	#elif defined(__linux__)
+	#elif defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)
 		XWindowAttributes windowAttributes;
 		Status status = libX11->XGetWindowAttributes((::Display*)display->getNativeDisplay(), window, &windowAttributes);
 
diff --git third_party/swiftshader/src/OpenGL/libEGL/libEGL.cpp third_party/swiftshader/src/OpenGL/libEGL/libEGL.cpp
index 8e0be66c79..63e46ab432 100644
--- third_party/swiftshader/src/OpenGL/libEGL/libEGL.cpp
+++ third_party/swiftshader/src/OpenGL/libEGL/libEGL.cpp
@@ -25,7 +25,7 @@
 
 #if defined(__ANDROID__)
 #include <system/window.h>
-#elif defined(__linux__)
+#elif defined(__linux__) || defined(__FreeBSD__)
 #include "Main/libX11.hpp"
 #endif
 
@@ -119,7 +119,7 @@ EGLDisplay GetDisplay(EGLNativeDisplayType display_id)
 		// FIXME: Check if display_id is the default display
 	}
 
-	#if defined(__linux__) && !defined(__ANDROID__)
+	#if (defined(__linux__) || defined(__FreeBSD__)) && !defined(__ANDROID__)
 		if(!libX11)
 		{
 			return success(HEADLESS_DISPLAY);
@@ -176,7 +176,7 @@ const char *QueryString(EGLDisplay dpy, EGLint name)
 	{
 		return success(
 			"EGL_KHR_client_get_all_proc_addresses "
-#if defined(__linux__) && !defined(__ANDROID__)
+#if (defined(__linux__) || defined(__FreeBSD__)) && !defined(__ANDROID__)
 			"EGL_KHR_platform_gbm "
 			"EGL_KHR_platform_x11 "
 #endif
@@ -1002,7 +1002,7 @@ EGLBoolean WaitNative(EGLint engine)
 
 	if(context)
 	{
-		#if defined(__linux__) && !defined(__ANDROID__)
+		#if (defined(__linux__) || defined(__FreeBSD__)) && !defined(__ANDROID__)
 			egl::Display *display = context->getDisplay();
 
 			if(!display)
@@ -1168,7 +1168,7 @@ EGLDisplay GetPlatformDisplayEXT(EGLenum platform, void *native_display, const E
 {
 	TRACE("(EGLenum platform = 0x%X, void *native_display = %p, const EGLint *attrib_list = %p)", platform, native_display, attrib_list);
 
-	#if defined(__linux__) && !defined(__ANDROID__)
+	#if (defined(__linux__) || defined(__FreeBSD__)) && !defined(__ANDROID__)
 		switch(platform)
 		{
 		case EGL_PLATFORM_X11_EXT: break;
diff --git third_party/swiftshader/src/OpenGL/libEGL/libEGL.hpp third_party/swiftshader/src/OpenGL/libEGL/libEGL.hpp
index 7ef0d31dce..315c5ba213 100644
--- third_party/swiftshader/src/OpenGL/libEGL/libEGL.hpp
+++ third_party/swiftshader/src/OpenGL/libEGL/libEGL.hpp
@@ -104,7 +104,7 @@ private:
 				#else
 					const char *libEGL_lib[] = {"/vendor/lib/egl/libEGL_swiftshader.so", "/system/lib/egl/libEGL_swiftshader.so"};
 				#endif
-			#elif defined(__linux__)
+            #elif defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)
 				#if defined(__LP64__)
 					const char *libEGL_lib[] = {"lib64EGL_translator.so", "libEGL.so.1", "libEGL.so"};
 				#else
diff --git third_party/swiftshader/src/OpenGL/libGLES_CM/libGLES_CM.hpp third_party/swiftshader/src/OpenGL/libGLES_CM/libGLES_CM.hpp
index b9c29f5819..cd1905d6c0 100644
--- third_party/swiftshader/src/OpenGL/libGLES_CM/libGLES_CM.hpp
+++ third_party/swiftshader/src/OpenGL/libGLES_CM/libGLES_CM.hpp
@@ -265,7 +265,7 @@ private:
 				#else
 					const char *libGLES_CM_lib[] = {"/vendor/lib/egl/libGLESv1_CM_swiftshader.so", "/system/lib/egl/libGLESv1_CM_swiftshader.so"};
 				#endif
-			#elif defined(__linux__)
+            #elif defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)
 				#if defined(__LP64__)
 					const char *libGLES_CM_lib[] = {"lib64GLES_CM_translator.so", "libGLES_CM.so.1", "libGLES_CM.so"};
 				#else
diff --git third_party/swiftshader/src/OpenGL/libGLESv2/libGLESv2.hpp third_party/swiftshader/src/OpenGL/libGLESv2/libGLESv2.hpp
index 1677d16e85..7e1fdd688b 100644
--- third_party/swiftshader/src/OpenGL/libGLESv2/libGLESv2.hpp
+++ third_party/swiftshader/src/OpenGL/libGLESv2/libGLESv2.hpp
@@ -290,7 +290,7 @@ private:
 				#else
 					const char *libGLESv2_lib[] = {"/vendor/lib/egl/libGLESv2_swiftshader.so", "/system/lib/egl/libGLESv2_swiftshader.so"};
 				#endif
-			#elif defined(__linux__)
+            #elif defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)
 				#if defined(__LP64__)
 					const char *libGLESv2_lib[] = {"lib64GLES_V2_translator.so", "libGLESv2.so.2", "libGLESv2.so"};
 				#else
diff --git third_party/swiftshader/third_party/llvm-subzero/build/Linux/include/llvm/Config/config.h third_party/swiftshader/third_party/llvm-subzero/build/Linux/include/llvm/Config/config.h
index e14edbdbfd..51b4db986e 100644
--- third_party/swiftshader/third_party/llvm-subzero/build/Linux/include/llvm/Config/config.h
+++ third_party/swiftshader/third_party/llvm-subzero/build/Linux/include/llvm/Config/config.h
@@ -121,7 +121,7 @@
 #define HAVE_LINK_H 1
 
 /* Define to 1 if you have the `lseek64' function. */
-#define HAVE_LSEEK64 1
+/* #undef HAVE_LSEEK64 */
 
 /* Define to 1 if you have the <mach/mach.h> header file. */
 /* #undef HAVE_MACH_MACH_H */
@@ -130,7 +130,7 @@
 /* #undef HAVE_MALLCTL */
 
 /* Define to 1 if you have the `mallinfo' function. */
-#define HAVE_MALLINFO 1
+/* #undef HAVE_MALLINFO */
 
 /* Define to 1 if you have the <malloc.h> header file. */
 #define HAVE_MALLOC_H 1
@@ -154,7 +154,7 @@
 /* #undef HAVE_NDIR_H */
 
 /* Define to 1 if you have the `posix_fallocate' function. */
-#define HAVE_POSIX_FALLOCATE 1
+/* #undef HAVE_POSIX_FALLOCATE */
 
 /* Define to 1 if you have the `posix_spawn' function. */
 #define HAVE_POSIX_SPAWN 1
diff --git third_party/swiftshader/third_party/llvm-subzero/lib/Support/Unix/Process.inc third_party/swiftshader/third_party/llvm-subzero/lib/Support/Unix/Process.inc
index 16f8f5a98e..3b22ac41dd 100644
--- third_party/swiftshader/third_party/llvm-subzero/lib/Support/Unix/Process.inc
+++ third_party/swiftshader/third_party/llvm-subzero/lib/Support/Unix/Process.inc
@@ -35,7 +35,7 @@
 // DragonFlyBSD, OpenBSD, and Bitrig have deprecated <malloc.h> for
 // <stdlib.h> instead. Unix.h includes this for us already.
 #if defined(HAVE_MALLOC_H) && !defined(__DragonFly__) && \
-    !defined(__OpenBSD__) && !defined(__Bitrig__)
+    !defined(__FreeBSD__) && !defined(__OpenBSD__) && !defined(__Bitrig__)
 #include <malloc.h>
 #endif
 #if defined(HAVE_MALLCTL)
diff --git third_party/usrsctp/BUILD.gn third_party/usrsctp/BUILD.gn
index 94f26786e1..3db0129957 100644
--- third_party/usrsctp/BUILD.gn
+++ third_party/usrsctp/BUILD.gn
@@ -116,11 +116,16 @@ static_library("usrsctp") {
     "-UINET6",
   ]
 
-  if (is_linux || is_android) {
+  if ((is_linux && !is_bsd) || is_android ) {
     defines += [
       "__Userspace_os_Linux",
       "_GNU_SOURCE",
     ]
+  } else if (is_bsd) {
+      defines += [
+        "__Userspace_os_DragonFly",
+        "HAVE_SYS_QUEUE_H",
+      ]
   } else if (is_mac || is_ios) {
     defines += [
       "HAVE_SA_LEN",
diff --git third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_os_userspace.h third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_os_userspace.h
index 8613301ab0..23932f1e64 100755
--- third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_os_userspace.h
+++ third_party/usrsctp/usrsctplib/usrsctplib/netinet/sctp_os_userspace.h
@@ -43,6 +43,10 @@
 
 #include <errno.h>
 
+#if defined(__Userspace_os_DragonFly)
+#include <sys/param.h>
+#endif
+
 #if defined(__Userspace_os_Windows)
 #include <winsock2.h>
 #include <ws2tcpip.h>
diff --git third_party/webrtc/BUILD.gn third_party/webrtc/BUILD.gn
index 4cc18252b1..b409cac452 100644
--- third_party/webrtc/BUILD.gn
+++ third_party/webrtc/BUILD.gn
@@ -132,6 +132,9 @@ config("common_inherited_config") {
   if (is_linux) {
     defines += [ "WEBRTC_LINUX" ]
   }
+  if (is_bsd) {
+    defines += [ "WEBRTC_BSD" ]
+  }
   if (is_mac) {
     defines += [ "WEBRTC_MAC" ]
   }
diff --git third_party/webrtc/modules/audio_device/BUILD.gn third_party/webrtc/modules/audio_device/BUILD.gn
index 9050faf647..484442fd69 100644
--- third_party/webrtc/modules/audio_device/BUILD.gn
+++ third_party/webrtc/modules/audio_device/BUILD.gn
@@ -287,7 +287,7 @@ rtc_source_set("audio_device_impl") {
     if (rtc_use_dummy_audio_file_devices) {
       defines += [ "WEBRTC_DUMMY_FILE_DEVICES" ]
     } else {
-      if (is_linux) {
+      if (is_linux && !is_bsd) {
         sources += [
           "linux/alsasymboltable_linux.cc",
           "linux/alsasymboltable_linux.h",
diff --git third_party/webrtc/modules/rtp_rtcp/source/forward_error_correction.cc third_party/webrtc/modules/rtp_rtcp/source/forward_error_correction.cc
index 30689e38ae..c6bb5fca11 100644
--- third_party/webrtc/modules/rtp_rtcp/source/forward_error_correction.cc
+++ third_party/webrtc/modules/rtp_rtcp/source/forward_error_correction.cc
@@ -13,6 +13,7 @@
 #include <string.h>
 
 #include <algorithm>
+#include <cstdlib>
 #include <iterator>
 #include <utility>
 
diff --git third_party/webrtc/rtc_base/BUILD.gn third_party/webrtc/rtc_base/BUILD.gn
index c3fd525e6a..72cd2a999e 100644
--- third_party/webrtc/rtc_base/BUILD.gn
+++ third_party/webrtc/rtc_base/BUILD.gn
@@ -894,8 +894,6 @@ rtc_static_library("rtc_base_generic") {
 
   if (rtc_use_x11) {
     libs += [
-      "dl",
-      "rt",
       "Xext",
       "X11",
       "Xcomposite",
@@ -903,7 +901,7 @@ rtc_static_library("rtc_base_generic") {
     ]
   }
 
-  if (is_linux) {
+  if (is_linux && !is_bsd) {
     libs += [
       "dl",
       "rt",
diff --git third_party/webrtc/rtc_base/byteorder.h third_party/webrtc/rtc_base/byteorder.h
index 85f0cc544a..87520c0634 100644
--- third_party/webrtc/rtc_base/byteorder.h
+++ third_party/webrtc/rtc_base/byteorder.h
@@ -77,7 +77,7 @@
 #error RTC_ARCH_CPU_BIG_ENDIAN or RTC_ARCH_CPU_LITTLE_ENDIAN must be defined.
 #endif  // defined(RTC_ARCH_CPU_LITTLE_ENDIAN)
 #elif defined(WEBRTC_POSIX)
-#include <endian.h>
+#include <sys/endian.h>
 #endif
 
 namespace rtc {
diff --git third_party/webrtc/rtc_base/httpcommon.cc third_party/webrtc/rtc_base/httpcommon.cc
index f23cb63a6e..dc7ae69dbe 100644
--- third_party/webrtc/rtc_base/httpcommon.cc
+++ third_party/webrtc/rtc_base/httpcommon.cc
@@ -427,7 +427,7 @@ bool HttpDateToSeconds(const std::string& date, time_t* seconds) {
     gmt = non_gmt + kTimeZoneOffsets[zindex] * 60 * 60;
   }
   // TODO: Android should support timezone, see b/2441195
-#if defined(WEBRTC_MAC) && !defined(WEBRTC_IOS) || defined(WEBRTC_ANDROID) || defined(BSD)
+#if defined(WEBRTC_MAC) && !defined(WEBRTC_IOS) || defined(WEBRTC_ANDROID) || defined(WEBRTC_BSD)
   tm *tm_for_timezone = localtime(&gmt);
   *seconds = gmt + tm_for_timezone->tm_gmtoff;
 #else
diff --git third_party/webrtc/rtc_base/ifaddrs_converter.h third_party/webrtc/rtc_base/ifaddrs_converter.h
index 35bef5b004..b0a370a3e1 100644
--- third_party/webrtc/rtc_base/ifaddrs_converter.h
+++ third_party/webrtc/rtc_base/ifaddrs_converter.h
@@ -14,6 +14,8 @@
 #if defined(WEBRTC_ANDROID)
 #include "rtc_base/ifaddrs-android.h"
 #else
+#include <sys/types.h>
+#include <sys/socket.h>
 #include <ifaddrs.h>
 #endif  // WEBRTC_ANDROID
 
diff --git third_party/webrtc/rtc_base/ipaddress.h third_party/webrtc/rtc_base/ipaddress.h
index c7a7e708e1..9616283ee8 100644
--- third_party/webrtc/rtc_base/ipaddress.h
+++ third_party/webrtc/rtc_base/ipaddress.h
@@ -17,6 +17,10 @@
 #include <arpa/inet.h>
 #include <netdb.h>
 #endif
+#if defined(WEBRTC_BSD)
+#include <sys/types.h>
+#include <sys/socket.h>
+#endif
 #if defined(WEBRTC_WIN)
 #include <winsock2.h>
 #include <ws2tcpip.h>
diff --git third_party/webrtc/rtc_base/network.cc third_party/webrtc/rtc_base/network.cc
index e857e75574..cc206207fa 100644
--- third_party/webrtc/rtc_base/network.cc
+++ third_party/webrtc/rtc_base/network.cc
@@ -14,7 +14,7 @@
 // linux/if.h can't be included at the same time as the posix sys/if.h, and
 // it's transitively required by linux/route.h, so include that version on
 // linux instead of the standard posix one.
-#if defined(WEBRTC_LINUX)
+#if defined(WEBRTC_LINUX) && !defined(WEBRTC_BSD)
 #include <linux/if.h>
 #include <linux/route.h>
 #elif !defined(__native_client__)
@@ -757,7 +757,7 @@ bool BasicNetworkManager::CreateNetworks(bool include_ignored,
 }
 #endif  // WEBRTC_WIN
 
-#if defined(WEBRTC_LINUX)
+#if defined(WEBRTC_LINUX) && !defined(WEBRTC_BSD)
 bool IsDefaultRoute(const std::string& network_name) {
   FileStream fs;
   if (!fs.Open("/proc/net/route", "r", nullptr)) {
@@ -801,7 +801,7 @@ bool BasicNetworkManager::IsIgnoredNetwork(const Network& network) const {
       strncmp(network.name().c_str(), "vboxnet", 7) == 0) {
     return true;
   }
-#if defined(WEBRTC_LINUX)
+#if defined(WEBRTC_LINUX) && !defined(WEBRTC_BSD)
   // Make sure this is a default route, if we're ignoring non-defaults.
   if (ignore_non_default_routes_ && !IsDefaultRoute(network.name())) {
     return true;
diff --git third_party/webrtc/rtc_base/network.h third_party/webrtc/rtc_base/network.h
index 49f500c297..09908c8c70 100644
--- third_party/webrtc/rtc_base/network.h
+++ third_party/webrtc/rtc_base/network.h
@@ -24,6 +24,10 @@
 #include "rtc_base/networkmonitor.h"
 #include "rtc_base/sigslot.h"
 
+#if defined(WEBRTC_BSD)
+#include <sys/types.h>
+#endif
+
 #if defined(WEBRTC_POSIX)
 struct ifaddrs;
 #endif  // defined(WEBRTC_POSIX)
diff --git third_party/webrtc/rtc_base/physicalsocketserver.cc third_party/webrtc/rtc_base/physicalsocketserver.cc
index 636c034e71..4b4b25b984 100644
--- third_party/webrtc/rtc_base/physicalsocketserver.cc
+++ third_party/webrtc/rtc_base/physicalsocketserver.cc
@@ -68,7 +68,7 @@ typedef void* SockOptArg;
 
 #endif  // WEBRTC_POSIX
 
-#if defined(WEBRTC_POSIX) && !defined(WEBRTC_MAC) && !defined(__native_client__)
+#if defined(WEBRTC_POSIX) && !defined(WEBRTC_MAC) && !defined(WEBRTC_BSD) && !defined(__native_client__)
 
 int64_t GetSocketRecvTimestamp(int socket) {
   struct timeval tv_ioctl;
@@ -295,7 +295,7 @@ int PhysicalSocket::GetOption(Option opt, int* value) {
   socklen_t optlen = sizeof(*value);
   int ret = ::getsockopt(s_, slevel, sopt, (SockOptArg)value, &optlen);
   if (ret != -1 && opt == OPT_DONTFRAGMENT) {
-#if defined(WEBRTC_LINUX) && !defined(WEBRTC_ANDROID)
+#if defined(WEBRTC_LINUX) && !defined(WEBRTC_ANDROID) && !defined(WEBRTC_BSD)
     *value = (*value != IP_PMTUDISC_DONT) ? 1 : 0;
 #endif
   }
@@ -308,7 +308,7 @@ int PhysicalSocket::SetOption(Option opt, int value) {
   if (TranslateOption(opt, &slevel, &sopt) == -1)
     return -1;
   if (opt == OPT_DONTFRAGMENT) {
-#if defined(WEBRTC_LINUX) && !defined(WEBRTC_ANDROID)
+#if defined(WEBRTC_LINUX) && !defined(WEBRTC_ANDROID) && !defined(WEBRTC_BSD)
     value = (value) ? IP_PMTUDISC_DO : IP_PMTUDISC_DONT;
 #endif
   }
@@ -318,7 +318,7 @@ int PhysicalSocket::SetOption(Option opt, int value) {
 int PhysicalSocket::Send(const void* pv, size_t cb) {
   int sent = DoSend(s_, reinterpret_cast<const char *>(pv),
       static_cast<int>(cb),
-#if defined(WEBRTC_LINUX) && !defined(WEBRTC_ANDROID)
+#if defined(WEBRTC_LINUX) && !defined(WEBRTC_ANDROID) && !defined(WEBRTC_BSD)
       // Suppress SIGPIPE. Without this, attempting to send on a socket whose
       // other end is closed will result in a SIGPIPE signal being raised to
       // our process, which by default will terminate the process, which we
@@ -347,7 +347,7 @@ int PhysicalSocket::SendTo(const void* buffer,
   size_t len = addr.ToSockAddrStorage(&saddr);
   int sent = DoSendTo(
       s_, static_cast<const char *>(buffer), static_cast<int>(length),
-#if defined(WEBRTC_LINUX) && !defined(WEBRTC_ANDROID)
+#if defined(WEBRTC_LINUX) && !defined(WEBRTC_ANDROID) && !defined(WEBRTC_BSD)
       // Suppress SIGPIPE. See above for explanation.
       MSG_NOSIGNAL,
 #else
@@ -538,7 +538,7 @@ int PhysicalSocket::TranslateOption(Option opt, int* slevel, int* sopt) {
       *slevel = IPPROTO_IP;
       *sopt = IP_DONTFRAGMENT;
       break;
-#elif defined(WEBRTC_MAC) || defined(BSD) || defined(__native_client__)
+#elif defined(WEBRTC_MAC) || defined(WEBRTC_BSD) || defined(__native_client__)
       RTC_LOG(LS_WARNING) << "Socket::OPT_DONTFRAGMENT not supported.";
       return -1;
 #elif defined(WEBRTC_POSIX)
diff --git third_party/webrtc/rtc_base/physicalsocketserver.h third_party/webrtc/rtc_base/physicalsocketserver.h
index 158c3d6605..7787f7cff1 100644
--- third_party/webrtc/rtc_base/physicalsocketserver.h
+++ third_party/webrtc/rtc_base/physicalsocketserver.h
@@ -11,7 +11,7 @@
 #ifndef RTC_BASE_PHYSICALSOCKETSERVER_H_
 #define RTC_BASE_PHYSICALSOCKETSERVER_H_
 
-#if defined(WEBRTC_POSIX) && defined(WEBRTC_LINUX)
+#if defined(WEBRTC_POSIX) && defined(WEBRTC_LINUX) && !defined(WEBRTC_BSD)
 #include <sys/epoll.h>
 #define WEBRTC_USE_EPOLL 1
 #endif
diff --git third_party/webrtc/rtc_base/platform_thread.cc third_party/webrtc/rtc_base/platform_thread.cc
index 79d9d53aee..93b3183381 100644
--- third_party/webrtc/rtc_base/platform_thread.cc
+++ third_party/webrtc/rtc_base/platform_thread.cc
@@ -15,7 +15,9 @@
 #include "rtc_base/timeutils.h"
 
 #if defined(WEBRTC_LINUX)
+#if !defined(__FreeBSD__) && !defined(__DragonFly__)
 #include <sys/prctl.h>
+#endif
 #include <sys/syscall.h>
 #endif
 
diff --git third_party/webrtc/rtc_base/platform_thread_types.cc third_party/webrtc/rtc_base/platform_thread_types.cc
index 15d48618bd..75b828c03f 100644
--- third_party/webrtc/rtc_base/platform_thread_types.cc
+++ third_party/webrtc/rtc_base/platform_thread_types.cc
@@ -11,7 +11,9 @@
 #include "rtc_base/platform_thread_types.h"
 
 #if defined(WEBRTC_LINUX)
+#if !defined(__FreeBSD__) && !defined(__DragonFly__)
 #include <sys/prctl.h>
+#endif
 #include <sys/syscall.h>
 #endif
 
@@ -27,8 +29,10 @@ PlatformThreadId CurrentThreadId() {
   return gettid();
 #elif defined(WEBRTC_FUCHSIA)
   return zx_thread_self();
-#elif defined(WEBRTC_LINUX)
+#elif defined(WEBRTC_LINUX) && !defined(__FreeBSD__) && !defined(__DragonFly__)
   return syscall(__NR_gettid);
+#elif defined(__FreeBSD__) || defined(__DragonFly__)
+  return reinterpret_cast<uint64_t>(pthread_self());
 #else
   // Default implementation for nacl and solaris.
   return reinterpret_cast<pid_t>(pthread_self());
@@ -55,6 +59,7 @@ bool IsThreadRefEqual(const PlatformThreadRef& a, const PlatformThreadRef& b) {
 }
 
 void SetCurrentThreadName(const char* name) {
+#if !defined(__FreeBSD__) && !defined(__DragonFly__)
 #if defined(WEBRTC_WIN)
   struct {
     DWORD dwType;
@@ -73,6 +78,7 @@ void SetCurrentThreadName(const char* name) {
 #elif defined(WEBRTC_MAC) || defined(WEBRTC_IOS)
   pthread_setname_np(name);
 #endif
+#endif
 }
 
 }  // namespace rtc
diff --git third_party/webrtc/rtc_base/stringutils.h third_party/webrtc/rtc_base/stringutils.h
index b42cfa57e0..3c42bccfba 100644
--- third_party/webrtc/rtc_base/stringutils.h
+++ third_party/webrtc/rtc_base/stringutils.h
@@ -24,11 +24,11 @@
 #endif  // WEBRTC_WIN
 
 #if defined(WEBRTC_POSIX)
-#ifdef BSD
+#if defined(WEBRTC_BSD) || defined(BSD)
 #include <stdlib.h>
-#else  // BSD
+#else  // WEBRTC_BSD
 #include <alloca.h>
-#endif  // !BSD
+#endif  // !WEBRTC_BSD
 #endif  // WEBRTC_POSIX
 
 #include <string>
diff --git third_party/webrtc/system_wrappers/BUILD.gn third_party/webrtc/system_wrappers/BUILD.gn
index af778fd90c..fea05919b5 100644
--- third_party/webrtc/system_wrappers/BUILD.gn
+++ third_party/webrtc/system_wrappers/BUILD.gn
@@ -75,8 +75,6 @@ rtc_static_library("system_wrappers") {
     if (!build_with_chromium) {
       deps += [ ":cpu_features_linux" ]
     }
-
-    libs += [ "rt" ]
   }
 
   if (is_ios || is_mac) {
diff --git third_party/webrtc/webrtc.gni third_party/webrtc/webrtc.gni
index 95c24d4968..b6d3530f17 100644
--- third_party/webrtc/webrtc.gni
+++ third_party/webrtc/webrtc.gni
@@ -208,7 +208,7 @@ rtc_libvpx_dir = "//third_party/libvpx"
 rtc_opus_dir = "//third_party/opus"
 
 # Desktop capturer is supported only on Windows, OSX and Linux.
-rtc_desktop_capture_supported = is_win || is_mac || (is_linux && rtc_use_x11)
+rtc_desktop_capture_supported = is_win || is_mac || ((is_linux && rtc_use_x11) && !is_bsd)
 
 ###############################################################################
 # Templates
diff --git third_party/yasm/BUILD.gn third_party/yasm/BUILD.gn
index ab2f9414bd..6be049a321 100644
--- third_party/yasm/BUILD.gn
+++ third_party/yasm/BUILD.gn
@@ -60,7 +60,12 @@ if (current_toolchain == host_toolchain) {
   # x86insn_nasm.c. These files were previously generated during the build but
   # are now shipped pre-generated by yasm.
   yasm_gen_include_dir = "$target_gen_dir/gen_include"
-  config_makefile = "source/config/Makefile"
+  # Hack for all BSD derivatives use OpenBSD include directory
+  if (is_bsd) {
+    config_makefile = "source/config/openbsd/Makefile"
+  } else {
+    config_makefile = "source/config/$host_os/Makefile"
+  }
   version_file = "version.mac"
 
   import("//build/compiled_action.gni")
diff --git third_party/zlib/BUILD.gn third_party/zlib/BUILD.gn
index cf339d44f0..c191e3a022 100644
--- third_party/zlib/BUILD.gn
+++ third_party/zlib/BUILD.gn
@@ -327,7 +327,7 @@ static_library("minizip") {
     ]
   }
 
-  if (is_mac || is_ios || is_android || is_nacl) {
+  if (is_mac || is_ios || is_android || is_nacl || is_bsd) {
     # Mac, Android and the BSDs don't have fopen64, ftello64, or fseeko64. We
     # use fopen, ftell, and fseek instead on these systems.
     defines = [ "USE_FILE32API" ]
diff --git tools/gn/args.cc tools/gn/args.cc
index a53eb490da..f6d002ba36 100644
--- tools/gn/args.cc
+++ tools/gn/args.cc
@@ -302,6 +302,8 @@ void Args::SetSystemVarsLocked(Scope* dest) const {
   os = "mac";
 #elif defined(OS_LINUX)
   os = "linux";
+#elif defined(OS_BSD)
+  os = "bsd";
 #elif defined(OS_ANDROID)
   os = "android";
 #elif defined(OS_NETBSD)
diff --git tools/gn/bootstrap/bootstrap.py tools/gn/bootstrap/bootstrap.py
index 300abacdbc..badf5f80c2 100755
--- tools/gn/bootstrap/bootstrap.py
+++ tools/gn/bootstrap/bootstrap.py
@@ -32,9 +32,14 @@ SRC_ROOT = os.path.dirname(os.path.dirname(GN_ROOT))
 
 is_win = sys.platform.startswith('win')
 is_linux = sys.platform.startswith('linux')
+is_freebsd = sys.platform.startswith('freebsd')
+is_netbsd = sys.platform.startswith('netbsd')
+is_openbsd = sys.platform.startswith('openbsd')
+is_dragonfly = sys.platform.startswith('dragonfly')
+is_bsd = is_freebsd or is_netbsd or is_openbsd or is_dragonfly
 is_mac = sys.platform.startswith('darwin')
 is_aix = sys.platform.startswith('aix')
-is_posix = is_linux or is_mac or is_aix
+is_posix = is_linux or is_mac or is_aix or is_bsd
 
 def check_call(cmd, **kwargs):
   logging.debug('Running: %s', ' '.join(cmd))
@@ -729,6 +734,43 @@ def write_gn_ninja(path, root_gen_dir, options, windows_x64_toolchain):
         'cflags': cflags + ['-DHAVE_CONFIG_H'],
     }
 
+  if is_bsd:
+    libs.extend(['-lexecinfo', '-lkvm'])
+    ldflags.extend(['-pthread'])
+    include_dirs += ["/usr/local/include"]
+
+    static_libraries['xdg_user_dirs'] = {
+        'sources': [
+            'base/third_party/xdg_user_dirs/xdg_user_dir_lookup.cc',
+        ],
+        'tool': 'cxx',
+    }
+    static_libraries['base']['sources'].extend([
+        'base/memory/shared_memory_handle_posix.cc',
+        'base/memory/shared_memory_posix.cc',
+        'base/nix/xdg_util.cc',
+        'base/process/memory_stubs.cc',
+        'base/process/process_info_linux.cc',
+        'base/process/internal_linux.cc',
+        'base/process/process_handle_freebsd.cc',
+        'base/process/process_metrics_freebsd.cc',
+        'base/strings/sys_string_conversions_posix.cc',
+        'base/sys_info_freebsd.cc',
+        'base/threading/platform_thread_linux.cc',
+        'base/synchronization/waitable_event_posix.cc',
+        'base/time/time_exploded_posix.cc',
+        'base/time/time_now_posix.cc',
+    ])
+    static_libraries['libevent']['include_dirs'].extend([
+        os.path.join(SRC_ROOT, 'base', 'third_party', 'libevent', 'freebsd')
+    ])
+    static_libraries['libevent']['sources'].extend([
+        'base/third_party/libevent/kqueue.c',
+    ])
+
+    # Suppressing warnings
+    cflags.extend(['-Wno-deprecated-register', '-Wno-parentheses-equality'])
+
   if is_linux or is_aix:
     static_libraries['xdg_user_dirs'] = {
         'sources': [
@@ -845,18 +887,6 @@ def write_gn_ninja(path, root_gen_dir, options, windows_x64_toolchain):
       static_libraries['libevent']['sources'].extend([
          'base/third_party/libevent/epoll.c',
       ])
-    else:
-      ldflags.extend(['-pthread'])
-      libs.extend(['-lrt'])
-      static_libraries['base']['sources'].extend([
-          'base/process/internal_aix.cc'
-      ])
-      static_libraries['libevent']['include_dirs'].extend([
-          os.path.join(SRC_ROOT, 'base', 'third_party', 'libevent', 'aix')
-      ])
-      static_libraries['libevent']['include_dirs'].extend([
-          os.path.join(SRC_ROOT, 'base', 'third_party', 'libevent', 'compat')
-      ])
 
   if is_mac:
     static_libraries['base']['sources'].extend([
diff --git tools/grit/grit/node/base.py tools/grit/grit/node/base.py
index e40bad88fc..6c51dddc0b 100755
--- tools/grit/grit/node/base.py
+++ tools/grit/grit/node/base.py
@@ -475,12 +475,15 @@ class Node(object):
         value = target_platform == 'android'
       elif name == 'is_ios':
         value = target_platform == 'ios'
+      elif name == 'is_dragonfly':
+        value = 'dragonfly' in target_platform
       elif name == 'is_bsd':
-        value = 'bsd' in target_platform
+        value = ('dragonfly' in target_platform or
+                 'bsd' in target_platform)
       elif name == 'is_posix':
         value = (target_platform in ('darwin', 'linux2', 'linux3', 'sunos5',
                                      'android', 'ios')
-                 or 'bsd' in target_platform)
+                 or 'bsd' in target_platform or 'dragonfly' in target_platform)
 
       elif name == 'pp_ifdef':
         def pp_ifdef(symbol):
diff --git tools/json_schema_compiler/feature_compiler.py tools/json_schema_compiler/feature_compiler.py
index 243e61ee1e..5d48176af5 100644
--- tools/json_schema_compiler/feature_compiler.py
+++ tools/json_schema_compiler/feature_compiler.py
@@ -211,6 +211,7 @@ FEATURE_GRAMMAR = (
         'enum_map': {
           'chromeos': 'Feature::CHROMEOS_PLATFORM',
           'linux': 'Feature::LINUX_PLATFORM',
+          'bsd': 'Feature::LINUX_PLATFORM',
           'mac': 'Feature::MACOSX_PLATFORM',
           'win': 'Feature::WIN_PLATFORM',
         }
diff --git tools/json_schema_compiler/model.py tools/json_schema_compiler/model.py
index b6126b8929..27ee8256aa 100644
--- tools/json_schema_compiler/model.py
+++ tools/json_schema_compiler/model.py
@@ -602,7 +602,7 @@ class Platforms(object):
   """
   CHROMEOS = _PlatformInfo("chromeos")
   CHROMEOS_TOUCH = _PlatformInfo("chromeos_touch")
-  LINUX = _PlatformInfo("linux")
+  LINUX = _PlatformInfo("bsd")
   MAC = _PlatformInfo("mac")
   WIN = _PlatformInfo("win")
 
diff --git tools/perf/chrome_telemetry_build/BUILD.gn tools/perf/chrome_telemetry_build/BUILD.gn
index cb26ff8158..c229b65a42 100644
--- tools/perf/chrome_telemetry_build/BUILD.gn
+++ tools/perf/chrome_telemetry_build/BUILD.gn
@@ -44,7 +44,7 @@ group("telemetry_chrome_test") {
     data_deps += [ "//chrome:reorder_imports" ]
   }
 
-  if (is_linux) {
+  if (is_linux && !is_bsd) {
     data_deps += [ "//third_party/breakpad:dump_syms($host_toolchain)" ]
   }
 
diff --git tools/variations/fieldtrial_to_struct.py tools/variations/fieldtrial_to_struct.py
index 240160fbfd..a069644a07 100755
--- tools/variations/fieldtrial_to_struct.py
+++ tools/variations/fieldtrial_to_struct.py
@@ -117,7 +117,7 @@ def main(arguments):
     parser.error('You must specify a --platform.')
 
   supported_platforms = ['android', 'chromeos', 'fuchsia', 'ios', 'linux',
-                         'mac', 'win']
+                         'mac', 'win', 'bsd']
   if opts.platform not in supported_platforms:
     parser.error('\'%s\' is an unknown platform. Supported platforms: %s' %
         (opts.platform, supported_platforms))
diff --git ui/base/dragdrop/os_exchange_data_provider_factory.cc ui/base/dragdrop/os_exchange_data_provider_factory.cc
index 9c3a9ab2cb..f05fd32035 100644
--- ui/base/dragdrop/os_exchange_data_provider_factory.cc
+++ ui/base/dragdrop/os_exchange_data_provider_factory.cc
@@ -8,7 +8,7 @@
 
 #if defined(USE_X11)
 #include "ui/base/dragdrop/os_exchange_data_provider_aurax11.h"
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
 #include "ui/base/dragdrop/os_exchange_data_provider_aura.h"
 #elif defined(OS_MACOSX)
 #include "ui/base/dragdrop/os_exchange_data_provider_builder_mac.h"
@@ -42,7 +42,7 @@ OSExchangeDataProviderFactory::CreateProvider() {
 
 #if defined(USE_X11)
   return std::make_unique<OSExchangeDataProviderAuraX11>();
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
   return std::make_unique<OSExchangeDataProviderAura>();
 #elif defined(OS_MACOSX)
   return ui::BuildOSExchangeDataProviderMac();
diff --git ui/base/ime/ime_engine_handler_interface.h ui/base/ime/ime_engine_handler_interface.h
index fdca0ee898..f5bac9f295 100644
--- ui/base/ime/ime_engine_handler_interface.h
+++ ui/base/ime/ime_engine_handler_interface.h
@@ -162,7 +162,7 @@ class UI_BASE_IME_EXPORT IMEEngineHandlerInterface {
   // Hides the input view window (from API call).
   virtual void HideInputView() = 0;
 
-#elif defined(OS_LINUX) || defined(OS_WIN)
+#elif defined(OS_LINUX) || defined(OS_WIN) || defined(OS_BSD)
 
   // Get the id of the IME extension.
   virtual std::string GetExtensionId() const = 0;
diff --git ui/base/ime/input_method_initializer.cc ui/base/ime/input_method_initializer.cc
index b64f362a5d..981875c885 100644
--- ui/base/ime/input_method_initializer.cc
+++ ui/base/ime/input_method_initializer.cc
@@ -8,7 +8,7 @@
 
 #if defined(OS_CHROMEOS)
 #include "ui/base/ime/ime_bridge.h"
-#elif defined(USE_AURA) && defined(OS_LINUX)
+#elif defined(USE_AURA) && (defined(OS_LINUX) || defined(OS_BSD))
 #include "base/logging.h"
 #include "ui/base/ime/linux/fake_input_method_context_factory.h"
 #elif defined(OS_WIN)
@@ -18,7 +18,7 @@
 
 namespace {
 
-#if !defined(OS_CHROMEOS) && defined(USE_AURA) && defined(OS_LINUX)
+#if !defined(OS_CHROMEOS) && defined(USE_AURA) && (defined(OS_LINUX) || defined(OS_BSD))
 const ui::LinuxInputMethodContextFactory*
     g_linux_input_method_context_factory_for_testing;
 #endif
@@ -46,7 +46,7 @@ void ShutdownInputMethod() {
 void InitializeInputMethodForTesting() {
 #if defined(OS_CHROMEOS)
   IMEBridge::Initialize();
-#elif defined(USE_AURA) && defined(OS_LINUX)
+#elif defined(USE_AURA) && (defined(OS_LINUX) || defined(OS_BSD))
   if (!g_linux_input_method_context_factory_for_testing)
     g_linux_input_method_context_factory_for_testing =
         new FakeInputMethodContextFactory();
@@ -67,7 +67,7 @@ void InitializeInputMethodForTesting() {
 void ShutdownInputMethodForTesting() {
 #if defined(OS_CHROMEOS)
   IMEBridge::Shutdown();
-#elif defined(USE_AURA) && defined(OS_LINUX)
+#elif defined(USE_AURA) && (defined(OS_LINUX) || defined(OS_BSD)) 
   const LinuxInputMethodContextFactory* factory =
       LinuxInputMethodContextFactory::instance();
   CHECK(!factory || factory == g_linux_input_method_context_factory_for_testing)
diff --git ui/base/resource/resource_bundle.cc ui/base/resource/resource_bundle.cc
index 2a00d4e851..ea8ec81fe1 100644
--- ui/base/resource/resource_bundle.cc
+++ ui/base/resource/resource_bundle.cc
@@ -720,7 +720,7 @@ void ResourceBundle::ReloadFonts() {
 }
 
 ScaleFactor ResourceBundle::GetMaxScaleFactor() const {
-#if defined(OS_WIN) || defined(OS_LINUX)
+#if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_BSD)
   return max_scale_factor_;
 #else
   return GetSupportedScaleFactors().back();
@@ -766,7 +766,7 @@ void ResourceBundle::InitSharedInstance(Delegate* delegate) {
   // On platforms other than iOS, 100P is always a supported scale factor.
   // For Windows we have a separate case in this function.
   supported_scale_factors.push_back(SCALE_FACTOR_100P);
-#if defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_WIN)
+#if defined(OS_MACOSX) || defined(OS_LINUX) || defined(OS_WIN) || defined(OS_BSD)
   supported_scale_factors.push_back(SCALE_FACTOR_200P);
 #endif
 #endif
diff --git ui/base/resource/resource_bundle_freebsd.cc ui/base/resource/resource_bundle_freebsd.cc
new file mode 100644
index 0000000000..92b25bdf74
--- /dev/null
+++ ui/base/resource/resource_bundle_freebsd.cc
@@ -0,0 +1,21 @@
+// Copyright 2017 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/resource/resource_bundle.h"
+
+#include "base/logging.h"
+#include "base/macros.h"
+#include "ui/gfx/image/image.h"
+
+namespace ui {
+
+void ResourceBundle::LoadCommonResources() {
+  LoadChromeResources();
+}
+
+gfx::Image& ResourceBundle::GetNativeImageNamed(int resource_id) {
+  return GetImageNamed(resource_id);
+}
+
+}  // namespace ui
diff --git ui/base/webui/web_ui_util.cc ui/base/webui/web_ui_util.cc
index 489fb7ecd6..e69eaac787 100644
--- ui/base/webui/web_ui_util.cc
+++ ui/base/webui/web_ui_util.cc
@@ -217,7 +217,7 @@ std::string GetFontFamily() {
 
 // TODO(dnicoara) Remove Ozone check when PlatformFont support is introduced
 // into Ozone: crbug.com/320050
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(USE_OZONE)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS) && !defined(USE_OZONE)
   font_family = ui::ResourceBundle::GetSharedInstance().GetFont(
       ui::ResourceBundle::BaseFont).GetFontName() + ", " + font_family;
 #endif
diff --git ui/events/devices/x11/device_data_manager_x11.cc ui/events/devices/x11/device_data_manager_x11.cc
index ec5a0acedc..611b47965f 100644
--- ui/events/devices/x11/device_data_manager_x11.cc
+++ ui/events/devices/x11/device_data_manager_x11.cc
@@ -829,6 +829,8 @@ void DeviceDataManagerX11::SetDisabledKeyboardAllowedKeys(
 }
 
 void DeviceDataManagerX11::DisableDevice(int deviceid) {
+  NOTIMPLEMENTED();
+#if !defined(OS_BSD)
   blocked_devices_.set(deviceid, true);
   // TODO(rsadam@): Support blocking touchscreen devices.
   std::vector<InputDevice> keyboards = GetKeyboardDevices();
@@ -840,6 +842,7 @@ void DeviceDataManagerX11::DisableDevice(int deviceid) {
     keyboards.erase(it);
     DeviceDataManager::OnKeyboardDevicesUpdated(keyboards);
   }
+#endif
 }
 
 void DeviceDataManagerX11::EnableDevice(int deviceid) {
diff --git ui/events/event_switches.cc ui/events/event_switches.cc
index d89187b69c..05ca7e18f6 100644
--- ui/events/event_switches.cc
+++ ui/events/event_switches.cc
@@ -17,7 +17,7 @@ const char kEnableScrollPrediction[] = "enable-scroll-prediction";
 const char kCompensateForUnstablePinchZoom[] =
     "compensate-for-unstable-pinch-zoom";
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
 // Tells chrome to interpret events from these devices as touch events. Only
 // available with XInput 2 (i.e. X server 1.8 or above). The id's of the
 // devices can be retrieved from 'xinput list'.
diff --git ui/events/event_switches.h ui/events/event_switches.h
index ddcbf126ac..9eafd4d09a 100644
--- ui/events/event_switches.h
+++ ui/events/event_switches.h
@@ -14,7 +14,7 @@ namespace switches {
 EVENTS_BASE_EXPORT extern const char kEnableScrollPrediction[];
 EVENTS_BASE_EXPORT extern const char kCompensateForUnstablePinchZoom[];
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_DRAGONFLY)
 EVENTS_BASE_EXPORT extern const char kTouchDevices[];
 EVENTS_BASE_EXPORT extern const char kPenDevices[];
 #endif
diff --git ui/events/keycodes/dom/keycode_converter.cc ui/events/keycodes/dom/keycode_converter.cc
index dcb997be11..a5ea5bf3d1 100644
--- ui/events/keycodes/dom/keycode_converter.cc
+++ ui/events/keycodes/dom/keycode_converter.cc
@@ -20,7 +20,7 @@ namespace {
 // and DOM Level 3 |code| strings.
 #if defined(OS_WIN)
 #define USB_KEYMAP(usb, evdev, xkb, win, mac, code, id) {usb, win, code}
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
 #define USB_KEYMAP(usb, evdev, xkb, win, mac, code, id) {usb, xkb, code}
 #elif defined(OS_MACOSX)
 #define USB_KEYMAP(usb, evdev, xkb, win, mac, code, id) {usb, mac, code}
diff --git ui/gfx/BUILD.gn ui/gfx/BUILD.gn
index 834e5df31b..38f3787ad3 100644
--- ui/gfx/BUILD.gn
+++ ui/gfx/BUILD.gn
@@ -568,7 +568,7 @@ source_set("memory_buffer_sources") {
     deps += [ "//third_party/libdrm" ]
   }
 
-  if (is_linux || is_android) {
+  if ((is_linux || is_android) && !is_bsd) {
     deps += [ "//third_party/libsync" ]
   }
 
diff --git ui/gfx/canvas_skia.cc ui/gfx/canvas_skia.cc
index 59ad113713..746fd57bcd 100644
--- ui/gfx/canvas_skia.cc
+++ ui/gfx/canvas_skia.cc
@@ -208,7 +208,7 @@ void Canvas::DrawStringRectWithFlags(const base::string16& text,
     Range range = StripAcceleratorChars(flags, &adjusted_text);
     bool elide_text = ((flags & NO_ELLIPSIS) == 0);
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     // On Linux, eliding really means fading the end of the string. But only
     // for LTR text. RTL text is still elided (on the left) with "...".
     if (elide_text) {
diff --git ui/gfx/codec/jpeg_codec.cc ui/gfx/codec/jpeg_codec.cc
index 5ff77d782b..a1c238473b 100644
--- ui/gfx/codec/jpeg_codec.cc
+++ ui/gfx/codec/jpeg_codec.cc
@@ -219,6 +219,7 @@ bool JPEGCodec::Decode(const unsigned char* input, size_t input_size,
     case JCS_GRAYSCALE:
     case JCS_RGB:
     case JCS_YCbCr:
+#ifdef JCS_EXTENSIONS
       // Choose an output colorspace and return if it is an unsupported one.
       // Same as JPEGCodec::Encode(), libjpeg-turbo supports all input formats
       // used by Chromium (i.e. RGBA and BGRA) and we just map the input
@@ -237,6 +238,9 @@ bool JPEGCodec::Decode(const unsigned char* input, size_t input_size,
         NOTREACHED() << "Invalid pixel format";
         return false;
       }
+#else
+      cinfo.out_color_space = JCS_RGB;
+#endif
       break;
     case JCS_CMYK:
     case JCS_YCCK:
diff --git ui/gfx/font_fallback_linux.cc ui/gfx/font_fallback_linux.cc
index 9c2e99ca16..aed4bc5f77 100644
--- ui/gfx/font_fallback_linux.cc
+++ ui/gfx/font_fallback_linux.cc
@@ -15,6 +15,10 @@
 #include "base/memory/ptr_util.h"
 #include "ui/gfx/font.h"
 
+#if defined(OS_BSD)
+#include <unistd.h>
+#endif
+
 namespace gfx {
 
 namespace {
diff --git ui/gfx/font_list.cc ui/gfx/font_list.cc
index 17be0fb188..537b027908 100644
--- ui/gfx/font_list.cc
+++ ui/gfx/font_list.cc
@@ -24,7 +24,7 @@ base::LazyInstance<scoped_refptr<gfx::FontListImpl>>::Leaky g_default_impl =
 bool g_default_impl_initialized = false;
 
 bool IsFontFamilyAvailable(const std::string& family, SkFontMgr* fontManager) {
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   return fontManager->legacyMakeTypeface(family.c_str(), SkFontStyle());
 #else
   sk_sp<SkFontStyleSet> set(fontManager->matchFamily(family.c_str()));
diff --git ui/gfx/font_render_params.h ui/gfx/font_render_params.h
index 8cda96de76..c6ec7ee7dd 100644
--- ui/gfx/font_render_params.h
+++ ui/gfx/font_render_params.h
@@ -107,13 +107,13 @@ GFX_EXPORT FontRenderParams GetFontRenderParams(
     const FontRenderParamsQuery& query,
     std::string* family_out);
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 // Clears GetFontRenderParams()'s cache. Intended to be called by tests that are
 // changing Fontconfig's configuration.
 GFX_EXPORT void ClearFontRenderParamsCacheForTest();
 #endif
 
-#if defined(OS_LINUX) || (defined(OS_ANDROID) && BUILDFLAG(ENABLE_VR))
+#if defined(OS_LINUX) || defined(OS_BSD) || (defined(OS_ANDROID) && BUILDFLAG(ENABLE_VR))
 // Gets the device scale factor to query the FontRenderParams.
 GFX_EXPORT float GetFontRenderParamsDeviceScaleFactor();
 
diff --git ui/gfx/gpu_memory_buffer.cc ui/gfx/gpu_memory_buffer.cc
index fe3d5ae3db..f72b9812d4 100644
--- ui/gfx/gpu_memory_buffer.cc
+++ ui/gfx/gpu_memory_buffer.cc
@@ -43,7 +43,7 @@ GpuMemoryBufferHandle CloneHandleForIPC(
       gfx::GpuMemoryBufferHandle handle;
       handle.type = gfx::NATIVE_PIXMAP;
       handle.id = source_handle.id;
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
       handle.native_pixmap_handle =
           gfx::CloneHandleForIPC(source_handle.native_pixmap_handle);
 #endif
diff --git ui/gfx/gpu_memory_buffer.h ui/gfx/gpu_memory_buffer.h
index a7527e6565..efe46b3fa8 100644
--- ui/gfx/gpu_memory_buffer.h
+++ ui/gfx/gpu_memory_buffer.h
@@ -16,7 +16,7 @@
 #include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/gfx_export.h"
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include "ui/gfx/native_pixmap_handle.h"
 #elif defined(OS_MACOSX) && !defined(OS_IOS)
 #include "ui/gfx/mac/io_surface.h"
@@ -56,7 +56,7 @@ struct GFX_EXPORT GpuMemoryBufferHandle {
   base::SharedMemoryHandle handle;
   uint32_t offset;
   int32_t stride;
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   NativePixmapHandle native_pixmap_handle;
 #elif defined(OS_MACOSX) && !defined(OS_IOS)
   ScopedRefCountedIOSurfaceMachPort mach_port;
diff --git ui/gfx/ipc/gfx_param_traits_macros.h ui/gfx/ipc/gfx_param_traits_macros.h
index 870c09122d..40f8fd0d41 100644
--- ui/gfx/ipc/gfx_param_traits_macros.h
+++ ui/gfx/ipc/gfx_param_traits_macros.h
@@ -18,7 +18,7 @@
 #include "ui/gfx/selection_bound.h"
 #include "ui/gfx/swap_result.h"
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include "ui/gfx/native_pixmap_handle.h"
 #endif
 
@@ -51,7 +51,7 @@ IPC_STRUCT_TRAITS_BEGIN(gfx::GpuMemoryBufferHandle)
   IPC_STRUCT_TRAITS_MEMBER(handle)
   IPC_STRUCT_TRAITS_MEMBER(offset)
   IPC_STRUCT_TRAITS_MEMBER(stride)
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   IPC_STRUCT_TRAITS_MEMBER(native_pixmap_handle)
 #elif defined(OS_MACOSX)
   IPC_STRUCT_TRAITS_MEMBER(mach_port)
@@ -66,7 +66,7 @@ IPC_STRUCT_TRAITS_BEGIN(gfx::GpuMemoryBufferId)
   IPC_STRUCT_TRAITS_MEMBER(id)
 IPC_STRUCT_TRAITS_END()
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 IPC_STRUCT_TRAITS_BEGIN(gfx::NativePixmapPlane)
   IPC_STRUCT_TRAITS_MEMBER(stride)
   IPC_STRUCT_TRAITS_MEMBER(offset)
diff --git ui/gfx/linux/client_native_pixmap_dmabuf.cc ui/gfx/linux/client_native_pixmap_dmabuf.cc
index 6611dcfef8..6accae5749 100644
--- ui/gfx/linux/client_native_pixmap_dmabuf.cc
+++ ui/gfx/linux/client_native_pixmap_dmabuf.cc
@@ -5,7 +5,9 @@
 #include "ui/gfx/linux/client_native_pixmap_dmabuf.h"
 
 #include <fcntl.h>
+#if !defined(__FreeBSD__) && !defined(__DragonFly__)
 #include <linux/version.h>
+#endif
 #include <stddef.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
@@ -17,11 +19,7 @@
 #include "base/strings/stringprintf.h"
 #include "base/trace_event/trace_event.h"
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
-#include <linux/dma-buf.h>
-#else
-#include <linux/types.h>
-
+#if defined(__FreeBSD__) || defined(__DragonFly__)
 struct dma_buf_sync {
   __u64 flags;
 };
diff --git ui/gfx/mojo/buffer_types_struct_traits.cc ui/gfx/mojo/buffer_types_struct_traits.cc
index ddeeee418d..b643a5d33d 100644
--- ui/gfx/mojo/buffer_types_struct_traits.cc
+++ ui/gfx/mojo/buffer_types_struct_traits.cc
@@ -27,10 +27,10 @@ std::vector<mojo::ScopedHandle>
 StructTraits<gfx::mojom::NativePixmapHandleDataView, gfx::NativePixmapHandle>::
     fds(const gfx::NativePixmapHandle& pixmap_handle) {
   std::vector<mojo::ScopedHandle> handles;
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   for (const base::FileDescriptor& fd : pixmap_handle.fds)
     handles.emplace_back(mojo::WrapPlatformFile(fd.fd));
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
   return handles;
 }
 
@@ -38,7 +38,7 @@ bool StructTraits<
     gfx::mojom::NativePixmapHandleDataView,
     gfx::NativePixmapHandle>::Read(gfx::mojom::NativePixmapHandleDataView data,
                                    gfx::NativePixmapHandle* out) {
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   mojo::ArrayDataView<mojo::ScopedHandle> handles_data_view;
   data.GetFdsDataView(&handles_data_view);
   for (size_t i = 0; i < handles_data_view.size(); ++i) {
@@ -71,7 +71,7 @@ const gfx::NativePixmapHandle&
 StructTraits<gfx::mojom::GpuMemoryBufferHandleDataView,
              gfx::GpuMemoryBufferHandle>::
     native_pixmap_handle(const gfx::GpuMemoryBufferHandle& handle) {
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   return handle.native_pixmap_handle;
 #else
   static gfx::NativePixmapHandle pixmap_handle;
@@ -154,7 +154,7 @@ bool StructTraits<gfx::mojom::GpuMemoryBufferHandleDataView,
     out->offset = data.offset();
     out->stride = data.stride();
   }
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   if (out->type == gfx::NATIVE_PIXMAP &&
       !data.ReadNativePixmapHandle(&out->native_pixmap_handle))
     return false;
diff --git ui/gfx/mojo/buffer_types_struct_traits.h ui/gfx/mojo/buffer_types_struct_traits.h
index ce615b3397..94f629ef34 100644
--- ui/gfx/mojo/buffer_types_struct_traits.h
+++ ui/gfx/mojo/buffer_types_struct_traits.h
@@ -291,7 +291,7 @@ template <>
 struct StructTraits<gfx::mojom::NativePixmapHandleDataView,
                     gfx::NativePixmapHandle> {
   static bool IsNull(const gfx::NativePixmapHandle& handle) {
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     return false;
 #else
     // NativePixmapHandle are not used on non-linux platforms.
diff --git ui/gfx/native_pixmap_handle.cc ui/gfx/native_pixmap_handle.cc
index 35b95b8e63..d0cf1a6b02 100644
--- ui/gfx/native_pixmap_handle.cc
+++ ui/gfx/native_pixmap_handle.cc
@@ -4,14 +4,14 @@
 
 #include "ui/gfx/native_pixmap_handle.h"
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include <drm_fourcc.h>
 #include "base/posix/eintr_wrapper.h"
 #endif
 
 namespace gfx {
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 static_assert(NativePixmapPlane::kNoModifier == DRM_FORMAT_MOD_INVALID,
               "gfx::NativePixmapPlane::kNoModifier should be an alias for"
               "DRM_FORMAT_MOD_INVALID");
@@ -36,7 +36,7 @@ NativePixmapHandle::NativePixmapHandle(const NativePixmapHandle& other) =
 
 NativePixmapHandle::~NativePixmapHandle() {}
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 NativePixmapHandle CloneHandleForIPC(const NativePixmapHandle& handle) {
   NativePixmapHandle clone;
   std::vector<base::ScopedFD> scoped_fds;
diff --git ui/gfx/native_pixmap_handle.h ui/gfx/native_pixmap_handle.h
index f34d798f54..a88d7f678e 100644
--- ui/gfx/native_pixmap_handle.h
+++ ui/gfx/native_pixmap_handle.h
@@ -13,7 +13,7 @@
 #include "build/build_config.h"
 #include "ui/gfx/gfx_export.h"
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include "base/file_descriptor_posix.h"
 #endif
 
@@ -54,14 +54,14 @@ struct GFX_EXPORT NativePixmapHandle {
 
   ~NativePixmapHandle();
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // File descriptors for the underlying memory objects (usually dmabufs).
   std::vector<base::FileDescriptor> fds;
 #endif
   std::vector<NativePixmapPlane> planes;
 };
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 // Returns an instance of |handle| which can be sent over IPC. This duplicates
 // the file-handles, so that the IPC code take ownership of them, without
 // invalidating |handle|.
diff --git ui/gfx/render_text.cc ui/gfx/render_text.cc
index 39702db77d..0a5098d114 100644
--- ui/gfx/render_text.cc
+++ ui/gfx/render_text.cc
@@ -938,32 +938,33 @@ void RenderText::SetDisplayOffset(int horizontal_offset) {
   const int extra_content = GetContentWidth() - display_rect_.width();
   const int cursor_width = cursor_enabled_ ? 1 : 0;
 
-  int min_offset = 0;
-  int max_offset = 0;
+  // avoid collisions with vm_map.h on FreeBSD --cmt
+  int _min_offset = 0;
+  int _max_offset = 0;
   if (extra_content > 0) {
     switch (GetCurrentHorizontalAlignment()) {
       case ALIGN_LEFT:
-        min_offset = -extra_content;
+        _min_offset = -extra_content;
         break;
       case ALIGN_RIGHT:
-        max_offset = extra_content;
+        _max_offset = extra_content;
         break;
       case ALIGN_CENTER:
         // The extra space reserved for cursor at the end of the text is ignored
         // when centering text. So, to calculate the valid range for offset, we
         // exclude that extra space, calculate the range, and add it back to the
         // range (if cursor is enabled).
-        min_offset = -(extra_content - cursor_width + 1) / 2 - cursor_width;
-        max_offset = (extra_content - cursor_width) / 2;
+        _min_offset = -(extra_content - cursor_width + 1) / 2 - cursor_width;
+        _max_offset = (extra_content - cursor_width) / 2;
         break;
       default:
         break;
     }
   }
-  if (horizontal_offset < min_offset)
-    horizontal_offset = min_offset;
-  else if (horizontal_offset > max_offset)
-    horizontal_offset = max_offset;
+  if (horizontal_offset < _min_offset)
+    horizontal_offset = _min_offset;
+  else if (horizontal_offset > _max_offset)
+    horizontal_offset = _max_offset;
 
   cached_bounds_and_offset_valid_ = true;
   display_offset_.set_x(horizontal_offset);
diff --git ui/gl/BUILD.gn ui/gl/BUILD.gn
index a60ee1c7cf..124446e4e0 100644
--- ui/gl/BUILD.gn
+++ ui/gl/BUILD.gn
@@ -214,7 +214,7 @@ component("gl") {
       }
     }
 
-    if (is_posix && !is_fuchsia && !is_mac) {
+    if (is_posix && !is_fuchsia && !is_mac && !is_bsd) {
       # Windows has USE_EGL but doesn't support base::FileDescriptor.
       # libsync isn't supported or needed on MacOSX.
       # Fuchsia is excluded due to a libsync dependency and because it's
@@ -311,7 +311,6 @@ component("gl") {
     data_deps += [
       "//third_party/angle:libEGL",
       "//third_party/angle:libGLESv2",
-      "//third_party/mesa:osmesa",
       "//third_party/swiftshader",
     ]
   }
@@ -547,10 +546,6 @@ test("gl_unittests") {
     "//ui/platform_window:platform_impls",
   ]
 
-  data_deps = [
-    "//third_party/mesa:osmesa",
-  ]
-
   if (use_x11) {
     sources += [ "gl_context_glx_unittest.cc" ]
     deps += [ "//ui/gfx/x" ]
diff --git ui/gl/generate_bindings.py ui/gl/generate_bindings.py
index c20f860cca..c73566b65d 100755
--- ui/gl/generate_bindings.py
+++ ui/gl/generate_bindings.py
@@ -2331,6 +2331,9 @@ GLX_FUNCTIONS = [
   'arguments':
       'Display* dpy, GLXDrawable drawable, int32_t* numerator, '
       'int32_t* denominator' },
+{ 'return_type': '__GLXextFuncPtr',
+  'names': ['glXGetProcAddressARB'],
+  'arguments': 'const GLubyte* procName', },
 { 'return_type': 'void',
   'names': ['glXGetSelectedEvent'],
   'arguments': 'Display* dpy, GLXDrawable drawable, unsigned long* mask', },
diff --git ui/gl/gl_bindings_api_autogen_glx.h ui/gl/gl_bindings_api_autogen_glx.h
index 15e5c9f4ad..fc6bf4943e 100644
--- ui/gl/gl_bindings_api_autogen_glx.h
+++ ui/gl/gl_bindings_api_autogen_glx.h
@@ -84,6 +84,7 @@ bool glXGetMscRateOMLFn(Display* dpy,
                         GLXDrawable drawable,
                         int32_t* numerator,
                         int32_t* denominator) override;
+__GLXextFuncPtr glXGetProcAddressARBFn(const GLubyte* procName) override;
 void glXGetSelectedEventFn(Display* dpy,
                            GLXDrawable drawable,
                            unsigned long* mask) override;
diff --git ui/gl/gl_bindings_autogen_glx.cc ui/gl/gl_bindings_autogen_glx.cc
index 44d539162d..28f93639b2 100644
--- ui/gl/gl_bindings_autogen_glx.cc
+++ ui/gl/gl_bindings_autogen_glx.cc
@@ -115,6 +115,8 @@ void DriverGLX::InitializeExtensionBindings() {
 
   ext.b_GLX_ARB_create_context =
       HasExtension(extensions, "GLX_ARB_create_context");
+  ext.b_GLX_ARB_get_proc_address =
+      HasExtension(extensions, "GLX_ARB_get_proc_address");
   ext.b_GLX_EXT_swap_control = HasExtension(extensions, "GLX_EXT_swap_control");
   ext.b_GLX_EXT_texture_from_pixmap =
       HasExtension(extensions, "GLX_EXT_texture_from_pixmap");
@@ -142,6 +144,11 @@ void DriverGLX::InitializeExtensionBindings() {
             GetGLProcAddress("glXCreateContextAttribsARB"));
   }
 
+  if (ext.b_GLX_ARB_get_proc_address) {
+    fn.glXGetProcAddressARBFn = reinterpret_cast<glXGetProcAddressARBProc>(
+        GetGLProcAddress("glXGetProcAddressARB"));
+  }
+
   if (ext.b_GLX_SGIX_fbconfig) {
     fn.glXGetFBConfigFromVisualSGIXFn =
         reinterpret_cast<glXGetFBConfigFromVisualSGIXProc>(
@@ -343,6 +350,10 @@ bool GLXApiBase::glXGetMscRateOMLFn(Display* dpy,
   return driver_->fn.glXGetMscRateOMLFn(dpy, drawable, numerator, denominator);
 }
 
+__GLXextFuncPtr GLXApiBase::glXGetProcAddressARBFn(const GLubyte* procName) {
+  return driver_->fn.glXGetProcAddressARBFn(procName);
+}
+
 void GLXApiBase::glXGetSelectedEventFn(Display* dpy,
                                        GLXDrawable drawable,
                                        unsigned long* mask) {
@@ -643,6 +654,11 @@ bool TraceGLXApi::glXGetMscRateOMLFn(Display* dpy,
   return glx_api_->glXGetMscRateOMLFn(dpy, drawable, numerator, denominator);
 }
 
+__GLXextFuncPtr TraceGLXApi::glXGetProcAddressARBFn(const GLubyte* procName) {
+  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "TraceGLAPI::glXGetProcAddressARB")
+  return glx_api_->glXGetProcAddressARBFn(procName);
+}
+
 void TraceGLXApi::glXGetSelectedEventFn(Display* dpy,
                                         GLXDrawable drawable,
                                         unsigned long* mask) {
@@ -1069,6 +1085,14 @@ bool DebugGLXApi::glXGetMscRateOMLFn(Display* dpy,
   return result;
 }
 
+__GLXextFuncPtr DebugGLXApi::glXGetProcAddressARBFn(const GLubyte* procName) {
+  GL_SERVICE_LOG("glXGetProcAddressARB"
+                 << "(" << static_cast<const void*>(procName) << ")");
+  __GLXextFuncPtr result = glx_api_->glXGetProcAddressARBFn(procName);
+  GL_SERVICE_LOG("GL_RESULT: " << result);
+  return result;
+}
+
 void DebugGLXApi::glXGetSelectedEventFn(Display* dpy,
                                         GLXDrawable drawable,
                                         unsigned long* mask) {
diff --git ui/gl/gl_bindings_autogen_glx.h ui/gl/gl_bindings_autogen_glx.h
index 2cd87ed127..27bba93b59 100644
--- ui/gl/gl_bindings_autogen_glx.h
+++ ui/gl/gl_bindings_autogen_glx.h
@@ -104,6 +104,8 @@ typedef bool(GL_BINDING_CALL* glXGetMscRateOMLProc)(Display* dpy,
                                                     GLXDrawable drawable,
                                                     int32_t* numerator,
                                                     int32_t* denominator);
+typedef __GLXextFuncPtr(GL_BINDING_CALL* glXGetProcAddressARBProc)(
+    const GLubyte* procName);
 typedef void(GL_BINDING_CALL* glXGetSelectedEventProc)(Display* dpy,
                                                        GLXDrawable drawable,
                                                        unsigned long* mask);
@@ -166,6 +168,7 @@ typedef void(GL_BINDING_CALL* glXWaitXProc)(void);
 
 struct ExtensionsGLX {
   bool b_GLX_ARB_create_context;
+  bool b_GLX_ARB_get_proc_address;
   bool b_GLX_EXT_swap_control;
   bool b_GLX_EXT_texture_from_pixmap;
   bool b_GLX_MESA_copy_sub_buffer;
@@ -203,6 +206,7 @@ struct ProcsGLX {
   glXGetFBConfigFromVisualSGIXProc glXGetFBConfigFromVisualSGIXFn;
   glXGetFBConfigsProc glXGetFBConfigsFn;
   glXGetMscRateOMLProc glXGetMscRateOMLFn;
+  glXGetProcAddressARBProc glXGetProcAddressARBFn;
   glXGetSelectedEventProc glXGetSelectedEventFn;
   glXGetSyncValuesOMLProc glXGetSyncValuesOMLFn;
   glXGetVisualFromFBConfigProc glXGetVisualFromFBConfigFn;
@@ -310,6 +314,7 @@ class GL_EXPORT GLXApi {
                                   GLXDrawable drawable,
                                   int32_t* numerator,
                                   int32_t* denominator) = 0;
+  virtual __GLXextFuncPtr glXGetProcAddressARBFn(const GLubyte* procName) = 0;
   virtual void glXGetSelectedEventFn(Display* dpy,
                                      GLXDrawable drawable,
                                      unsigned long* mask) = 0;
@@ -394,6 +399,7 @@ class GL_EXPORT GLXApi {
   ::gl::g_current_glx_context->glXGetFBConfigFromVisualSGIXFn
 #define glXGetFBConfigs ::gl::g_current_glx_context->glXGetFBConfigsFn
 #define glXGetMscRateOML ::gl::g_current_glx_context->glXGetMscRateOMLFn
+#define glXGetProcAddressARB ::gl::g_current_glx_context->glXGetProcAddressARBFn
 #define glXGetSelectedEvent ::gl::g_current_glx_context->glXGetSelectedEventFn
 #define glXGetSyncValuesOML ::gl::g_current_glx_context->glXGetSyncValuesOMLFn
 #define glXGetVisualFromFBConfig \
diff --git ui/gl/gl_fence.cc ui/gl/gl_fence.cc
index b37e969b60..4c7597d03e 100644
--- ui/gl/gl_fence.cc
+++ ui/gl/gl_fence.cc
@@ -19,7 +19,7 @@
 #endif
 
 #if defined(USE_EGL) && defined(OS_POSIX) && !defined(OS_FUCHSIA) && \
-    !defined(OS_MACOSX)
+  !defined(OS_MACOSX) && !defined(OS_FREEBSD) && !defined(OS_DRAGONFLY)
 #define USE_GL_FENCE_ANDROID_NATIVE_FENCE_SYNC
 #include "ui/gl/gl_fence_android_native_fence_sync.h"
 #include "ui/gl/gl_surface_egl.h"
diff --git ui/gl/gl_implementation.cc ui/gl/gl_implementation.cc
index d682388840..9e80a4cf67 100644
--- ui/gl/gl_implementation.cc
+++ ui/gl/gl_implementation.cc
@@ -123,7 +123,7 @@ GLImplementation GetNamedGLImplementation(const std::string& name) {
 
 GLImplementation GetSoftwareGLImplementation() {
 #if (defined(OS_WIN) ||                                                     \
-     (defined(OS_LINUX) && !defined(OS_CHROMEOS) && !defined(USE_OZONE)) || \
+     ((defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS) && !defined(USE_OZONE)) || \
      (defined(OS_MACOSX) && defined(USE_EGL)))
   return kGLImplementationSwiftShaderGL;
 #else
diff --git ui/gl/sync_control_vsync_provider.cc ui/gl/sync_control_vsync_provider.cc
index 2b94e43a57..73f11f6757 100644
--- ui/gl/sync_control_vsync_provider.cc
+++ ui/gl/sync_control_vsync_provider.cc
@@ -11,7 +11,7 @@
 #include "base/trace_event/trace_event.h"
 #include "build/build_config.h"
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 // These constants define a reasonable range for a calculated refresh interval.
 // Calculating refreshes out of this range will be considered a fatal error.
 const int64_t kMinVsyncIntervalUs = base::Time::kMicrosecondsPerSecond / 400;
@@ -26,7 +26,7 @@ const double kRelativeIntervalDifferenceThreshold = 0.05;
 namespace gl {
 
 SyncControlVSyncProvider::SyncControlVSyncProvider() : gfx::VSyncProvider() {
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // On platforms where we can't get an accurate reading on the refresh
   // rate we fall back to the assumption that we're displaying 60 frames
   // per second.
@@ -48,7 +48,7 @@ bool SyncControlVSyncProvider::GetVSyncParametersIfAvailable(
     base::TimeTicks* timebase_out,
     base::TimeDelta* interval_out) {
   TRACE_EVENT0("gpu", "SyncControlVSyncProvider::GetVSyncParameters");
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // The actual clock used for the system time returned by glXGetSyncValuesOML
   // is unspecified. In practice, the clock used is likely to be either
   // CLOCK_REALTIME or CLOCK_MONOTONIC, so we compare the returned time to the
@@ -157,7 +157,7 @@ bool SyncControlVSyncProvider::GetVSyncParametersIfAvailable(
   return true;
 #else
   return false;
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
 }
 
 bool SyncControlVSyncProvider::SupportGetVSyncParametersIfAvailable() const {
diff --git ui/gl/sync_control_vsync_provider.h ui/gl/sync_control_vsync_provider.h
index 735d7ee61c..f0d2f78781 100644
--- ui/gl/sync_control_vsync_provider.h
+++ ui/gl/sync_control_vsync_provider.h
@@ -26,11 +26,11 @@ class SyncControlVSyncProvider : public gfx::VSyncProvider {
   bool SupportGetVSyncParametersIfAvailable() const override;
 
   static constexpr bool IsSupported() {
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
     return true;
 #else
     return false;
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
   }
 
  protected:
@@ -41,7 +41,7 @@ class SyncControlVSyncProvider : public gfx::VSyncProvider {
   virtual bool GetMscRate(int32_t* numerator, int32_t* denominator) = 0;
 
  private:
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   base::TimeTicks last_timebase_;
   uint64_t last_media_stream_counter_ = 0;
   base::TimeDelta last_good_interval_;
@@ -52,7 +52,7 @@ class SyncControlVSyncProvider : public gfx::VSyncProvider {
   // from configuration change (monitor reconfiguration, moving windows
   // between monitors, suspend and resume, etc.).
   base::queue<base::TimeDelta> last_computed_intervals_;
-#endif  // defined(OS_LINUX)
+#endif  // defined(OS_LINUX) || defined(OS_BSD)
 
   DISALLOW_COPY_AND_ASSIGN(SyncControlVSyncProvider);
 };
diff --git ui/message_center/views/message_view_factory.cc ui/message_center/views/message_view_factory.cc
index 07ed14273e..8d9c3ccedf 100644
--- ui/message_center/views/message_view_factory.cc
+++ ui/message_center/views/message_view_factory.cc
@@ -57,7 +57,7 @@ MessageView* MessageViewFactory::Create(const Notification& notification,
       notification_view = new NotificationView(notification);
   }
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // Don't create shadows for notification toasts on Linux or CrOS.
   if (top_level)
     return notification_view;
diff --git ui/message_center/views/toast_contents_view.cc ui/message_center/views/toast_contents_view.cc
index 23c84cf6d5..11107803c6 100644
--- ui/message_center/views/toast_contents_view.cc
+++ ui/message_center/views/toast_contents_view.cc
@@ -322,7 +322,7 @@ void ToastContentsView::CreateWidget(
     PopupAlignmentDelegate* alignment_delegate) {
   views::Widget::InitParams params(views::Widget::InitParams::TYPE_POPUP);
   params.keep_on_top = true;
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_BSD) || defined(OS_LINUX)) && !defined(OS_CHROMEOS)
   params.opacity = views::Widget::InitParams::OPAQUE_WINDOW;
 #else
   params.opacity = views::Widget::InitParams::TRANSLUCENT_WINDOW;
diff --git ui/native_theme/native_theme.h ui/native_theme/native_theme.h
index c4590205e7..df6f8d7a19 100644
--- ui/native_theme/native_theme.h
+++ ui/native_theme/native_theme.h
@@ -47,7 +47,7 @@ class NATIVE_THEME_EXPORT NativeTheme {
   // The part to be painted / sized.
   enum Part {
     kCheckbox,
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
     kFrameTopArea,
 #endif
     kInnerSpinButton,
diff --git ui/native_theme/native_theme_base.cc ui/native_theme/native_theme_base.cc
index 9694c14a02..748c99008e 100644
--- ui/native_theme/native_theme_base.cc
+++ ui/native_theme/native_theme_base.cc
@@ -172,7 +172,7 @@ void NativeThemeBase::Paint(cc::PaintCanvas* canvas,
     case kCheckbox:
       PaintCheckbox(canvas, state, rect, extra.button);
       break;
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
     case kFrameTopArea:
       PaintFrameTopArea(canvas, state, rect, extra.frame_top_area);
       break;
diff --git ui/strings/app_locale_settings.grd ui/strings/app_locale_settings.grd
index 3417591ad8..2b9e21b8e3 100644
--- ui/strings/app_locale_settings.grd
+++ ui/strings/app_locale_settings.grd
@@ -187,7 +187,7 @@
           75%
         </message>
       </if>
-      <if expr="(is_linux or is_android or is_bsd) and not chromeos">
+      <if expr="is_posix or is_bsd and not chromeos">
         <!-- The font used in Web UI (e.g. History). Note that these are only
              backups. We try to use the system font if possible. -->
         <message name="IDS_WEB_FONT_FAMILY" use_name_for_id="true">
diff --git ui/views/bubble/bubble_dialog_delegate.cc ui/views/bubble/bubble_dialog_delegate.cc
index eb5a9fd9b4..87bdf0f9b5 100644
--- ui/views/bubble/bubble_dialog_delegate.cc
+++ ui/views/bubble/bubble_dialog_delegate.cc
@@ -107,7 +107,7 @@ Widget* BubbleDialogDelegateView::CreateBubble(
   // the parent frame and let DWM handle compositing.  If not, then we don't
   // want to allow the bubble to extend the frame because it will be clipped.
   bubble_delegate->set_adjust_if_offscreen(ui::win::IsAeroGlassEnabled());
-#elif (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_MACOSX)
+#elif (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_MACOSX) || defined(OS_BSD)
   // Linux clips bubble windows that extend outside their parent window bounds.
   // Mac never adjusts.
   bubble_delegate->set_adjust_if_offscreen(false);
diff --git ui/views/controls/label.cc ui/views/controls/label.cc
index b5baab3cbb..5401052299 100644
--- ui/views/controls/label.cc
+++ ui/views/controls/label.cc
@@ -549,7 +549,7 @@ bool Label::OnMousePressed(const ui::MouseEvent& event) {
     GetFocusManager()->SetFocusedView(this);
   }
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   if (event.IsOnlyMiddleMouseButton() && GetFocusManager() && !had_focus)
     GetFocusManager()->SetFocusedView(this);
 #endif
@@ -734,7 +734,7 @@ bool Label::PasteSelectionClipboard() {
 }
 
 void Label::UpdateSelectionClipboard() {
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   if (!obscured()) {
     ui::ScopedClipboardWriter(ui::CLIPBOARD_TYPE_SELECTION)
         .WriteText(GetSelectedText());
diff --git ui/views/controls/textfield/textfield.cc ui/views/controls/textfield/textfield.cc
index 3c1d189c67..5d9a9327b7 100644
--- ui/views/controls/textfield/textfield.cc
+++ ui/views/controls/textfield/textfield.cc
@@ -59,7 +59,7 @@
 #include "base/win/win_util.h"
 #endif
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
 #include "base/strings/utf_string_conversions.h"
 #include "ui/base/ime/linux/text_edit_command_auralinux.h"
 #include "ui/base/ime/linux/text_edit_key_bindings_delegate_auralinux.h"
@@ -156,14 +156,14 @@ ui::TextEditCommand GetCommandForKeyEvent(const ui::KeyEvent& event) {
     case ui::VKEY_BACK:
       if (!control)
         return ui::TextEditCommand::DELETE_BACKWARD;
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
       // Only erase by line break on Linux and ChromeOS.
       if (shift)
         return ui::TextEditCommand::DELETE_TO_BEGINNING_OF_LINE;
 #endif
       return ui::TextEditCommand::DELETE_WORD_BACKWARD;
     case ui::VKEY_DELETE:
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
       // Only erase by line break on Linux and ChromeOS.
       if (shift && control)
         return ui::TextEditCommand::DELETE_TO_END_OF_LINE;
@@ -219,7 +219,7 @@ bool IsControlKeyModifier(int flags) {
 // Control-modified key combination, but we cannot extend it to other platforms
 // as Control has different meanings and behaviors.
 // https://crrev.com/2580483002/#msg46
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   return flags & ui::EF_CONTROL_DOWN;
 #else
   return false;
@@ -669,7 +669,7 @@ bool Textfield::OnMousePressed(const ui::MouseEvent& event) {
     ShowImeIfNeeded();
   }
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   if (!handled && !had_focus && event.IsOnlyMiddleMouseButton())
     RequestFocusWithPointer(ui::EventPointerType::POINTER_TYPE_MOUSE);
 #endif
@@ -713,7 +713,7 @@ bool Textfield::OnKeyPressed(const ui::KeyEvent& event) {
   if (!textfield)
     return handled;
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   ui::TextEditKeyBindingsDelegateAuraLinux* delegate =
       ui::GetTextEditKeyBindingsDelegate();
   std::vector<ui::TextEditCommandAuraLinux> commands;
@@ -875,7 +875,7 @@ void Textfield::AboutToRequestFocusFromTabTraversal(bool reverse) {
 }
 
 bool Textfield::SkipDefaultKeyEventProcessing(const ui::KeyEvent& event) {
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   // Skip any accelerator handling that conflicts with custom keybindings.
   ui::TextEditKeyBindingsDelegateAuraLinux* delegate =
       ui::GetTextEditKeyBindingsDelegate();
@@ -2054,7 +2054,7 @@ bool Textfield::PasteSelectionClipboard() {
 }
 
 void Textfield::UpdateSelectionClipboard() {
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   if (text_input_type_ != ui::TEXT_INPUT_TYPE_PASSWORD) {
     ui::ScopedClipboardWriter(ui::CLIPBOARD_TYPE_SELECTION)
         .WriteText(GetSelectedText());
diff --git ui/views/corewm/tooltip_aura.cc ui/views/corewm/tooltip_aura.cc
index 80237a0abc..07308312eb 100644
--- ui/views/corewm/tooltip_aura.cc
+++ ui/views/corewm/tooltip_aura.cc
@@ -34,7 +34,7 @@ const int kCursorOffsetY = 15;
 
 // TODO(varkha): Update if native widget can be transparent on Linux.
 bool CanUseTranslucentTooltipWidget() {
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   return false;
 #else
   return true;
diff --git ui/views/examples/widget_example.cc ui/views/examples/widget_example.cc
index 960d5f6129..13ebd5ed3e 100644
--- ui/views/examples/widget_example.cc
+++ ui/views/examples/widget_example.cc
@@ -79,7 +79,7 @@ void WidgetExample::CreateExampleView(View* container) {
   BuildButton(container, "Popup widget", POPUP);
   BuildButton(container, "Dialog widget", DIALOG);
   BuildButton(container, "Modal Dialog", MODAL_DIALOG);
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   // Windows does not support TYPE_CONTROL top-level widgets.
   BuildButton(container, "Child widget", CHILD);
 #endif
diff --git ui/views/mus/aura_init.cc ui/views/mus/aura_init.cc
index 96e0ecfc39..91d976b929 100644
--- ui/views/mus/aura_init.cc
+++ ui/views/mus/aura_init.cc
@@ -23,7 +23,7 @@
 #include "ui/views/mus/mus_client.h"
 #include "ui/views/views_delegate.h"
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
 #include "components/services/font/public/cpp/font_loader.h"
 #include "ui/gfx/platform_font_linux.h"
 #endif
@@ -58,7 +58,7 @@ AuraInit::AuraInit() {
 }
 
 AuraInit::~AuraInit() {
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   if (font_loader_.get()) {
     SkFontConfigInterface::SetGlobal(nullptr);
     // FontLoader is ref counted. We need to explicitly shutdown the background
@@ -115,7 +115,7 @@ bool AuraInit::Init(service_manager::Connector* connector,
   }
 
 // Initialize the skia font code to go ask fontconfig underneath.
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   font_loader_ = sk_make_sp<font_service::FontLoader>(connector);
   SkFontConfigInterface::SetGlobal(font_loader_);
 
diff --git ui/views/mus/aura_init.h ui/views/mus/aura_init.h
index c76c8314a2..90d9ec2ade 100644
--- ui/views/mus/aura_init.h
+++ ui/views/mus/aura_init.h
@@ -92,7 +92,7 @@ class VIEWS_MUS_EXPORT AuraInit {
                            const std::string& resource_file_200,
                            bool register_path_provider);
 
-#if defined(OS_LINUX)
+#if defined(OS_LINUX) || defined(OS_BSD)
   sk_sp<font_service::FontLoader> font_loader_;
 #endif
 
diff --git ui/views/selection_controller.cc ui/views/selection_controller.cc
index 61d83ff375..3e26b17181 100644
--- ui/views/selection_controller.cc
+++ ui/views/selection_controller.cc
@@ -20,7 +20,7 @@ SelectionController::SelectionController(SelectionControllerDelegate* delegate)
       delegate_(delegate),
       handles_selection_clipboard_(false) {
 // On Linux, update the selection clipboard on a text selection.
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   set_handles_selection_clipboard(true);
 #endif
 
diff --git ui/views/style/platform_style.cc ui/views/style/platform_style.cc
index ef68fb58bb..b5aa3b34ac 100644
--- ui/views/style/platform_style.cc
+++ ui/views/style/platform_style.cc
@@ -19,7 +19,7 @@
 
 #if defined(OS_CHROMEOS)
 #include "ui/views/controls/scrollbar/overlay_scroll_bar.h"
-#elif defined(OS_LINUX)
+#elif defined(OS_LINUX) || defined(OS_BSD)
 #define DESKTOP_LINUX
 #endif
 
diff --git ui/views/views_delegate.cc ui/views/views_delegate.cc
index 7b303dac47..b16532e70f 100644
--- ui/views/views_delegate.cc
+++ ui/views/views_delegate.cc
@@ -83,7 +83,8 @@ HICON ViewsDelegate::GetDefaultWindowIcon() const {
 bool ViewsDelegate::IsWindowInMetro(gfx::NativeWindow window) const {
   return false;
 }
-#elif defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#elif (defined(OS_LINUX) && !defined(OS_CHROMEOS)) || defined(OS_FREEBSD) || \
+  defined(OS_DRAGONFLY)
 gfx::ImageSkia* ViewsDelegate::GetDefaultWindowIcon() const {
   return nullptr;
 }
diff --git ui/views/views_delegate.h ui/views/views_delegate.h
index 8f70348208..45b6067239 100644
--- ui/views/views_delegate.h
+++ ui/views/views_delegate.h
@@ -155,7 +155,8 @@ class VIEWS_EXPORT ViewsDelegate {
   // Returns true if the window passed in is in the Windows 8 metro
   // environment.
   virtual bool IsWindowInMetro(gfx::NativeWindow window) const;
-#elif defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#elif defined(OS_LINUX) && !defined(OS_CHROMEOS) || defined(OS_FREEBSD) || \
+  defined(OS_DRAGONFLY)
   virtual gfx::ImageSkia* GetDefaultWindowIcon() const;
 #endif
 
diff --git ui/views/widget/desktop_aura/desktop_screen_x11.cc ui/views/widget/desktop_aura/desktop_screen_x11.cc
index 8fd5d379d3..e90710c2c3 100644
--- ui/views/widget/desktop_aura/desktop_screen_x11.cc
+++ ui/views/widget/desktop_aura/desktop_screen_x11.cc
@@ -216,8 +216,13 @@ display::Display DesktopScreenX11::GetDisplayNearestWindow(
   if (host) {
     DesktopWindowTreeHostX11* rwh = DesktopWindowTreeHostX11::GetHostForXID(
         host->GetAcceleratedWidget());
-    if (rwh)
-      return GetDisplayMatching(rwh->GetX11RootWindowBounds());
+    if (rwh) {
+      const float scale = 1.0f / GetDeviceScaleFactor();
+      const gfx::Rect pixel_rect = rwh->GetX11RootWindowBounds();
+      return GetDisplayMatching(
+          gfx::Rect(gfx::ScaleToFlooredPoint(pixel_rect.origin(), scale),
+                    gfx::ScaleToCeiledSize(pixel_rect.size(), scale)));
+    }
   }
 
   return GetPrimaryDisplay();
diff --git ui/views/window/custom_frame_view.cc ui/views/window/custom_frame_view.cc
index 22d0bed6be..73422840e8 100644
--- ui/views/window/custom_frame_view.cc
+++ ui/views/window/custom_frame_view.cc
@@ -301,7 +301,7 @@ int CustomFrameView::NonClientTopBorderHeight() const {
 int CustomFrameView::CaptionButtonY() const {
   // Maximized buttons start at window top so that even if their images aren't
   // drawn flush with the screen edge, they still obey Fitts' Law.
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_CHROMEOS) || defined(OS_BSD)
   return FrameBorderThickness();
 #else
   return frame_->IsMaximized() ? FrameBorderThickness() : kFrameShadowThickness;
diff --git ui/views/window/dialog_delegate.cc ui/views/window/dialog_delegate.cc
index 739e5e548b..0820fa5e9c 100644
--- ui/views/window/dialog_delegate.cc
+++ ui/views/window/dialog_delegate.cc
@@ -64,7 +64,7 @@ Widget::InitParams DialogDelegate::GetDialogWidgetInitParams(
   params.bounds = bounds;
   DialogDelegate* dialog = delegate->AsDialogDelegate();
 
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   // The new style doesn't support unparented dialogs on Linux desktop.
   if (dialog)
     dialog->supports_custom_frame_ &= parent != NULL;
diff --git ui/views/window/frame_background.cc ui/views/window/frame_background.cc
index 7bbbb8db90..6003134951 100644
--- ui/views/window/frame_background.cc
+++ ui/views/window/frame_background.cc
@@ -173,7 +173,7 @@ void FrameBackground::PaintFrameColor(gfx::Canvas* canvas,
 
 void FrameBackground::PaintFrameTopArea(gfx::Canvas* canvas,
                                         const View* view) const {
-#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
+#if (defined(OS_LINUX) || defined(OS_BSD)) && !defined(OS_CHROMEOS)
   auto* native_theme = view->GetNativeTheme();
   ui::NativeTheme::ExtraParams params;
   params.frame_top_area.use_custom_frame = use_custom_frame_;
diff --git ui/webui/resources/js/cr.js ui/webui/resources/js/cr.js
index 75a4e86e2e..e2614268a7 100644
--- ui/webui/resources/js/cr.js
+++ ui/webui/resources/js/cr.js
@@ -455,6 +455,11 @@ var cr = cr || function() {
     get doc() {
       return document;
     },
+    
+    /** Whether this is on *BSD. */
+    get isBSD() {
+      return /BSD/.test(navigator.userAgent);
+    },
 
     /** Whether we are using a Mac or not. */
     get isMac() {
diff --git ui/webui/resources/js/icon.js ui/webui/resources/js/icon.js
index ef025e7133..332642e1af 100644
--- ui/webui/resources/js/icon.js
+++ ui/webui/resources/js/icon.js
@@ -14,7 +14,7 @@ cr.define('cr.icon', function() {
       // supports SCALE_FACTOR_100P on all non-iOS platforms.
       supportedScaleFactors.push(1);
     }
-    if (cr.isMac || cr.isChromeOS || cr.isWindows || cr.isLinux) {
+    if (cr.isMac || cr.isChromeOS || cr.isWindows || cr.isLinux || cr.isBSD) {
       // All desktop platforms support zooming which also updates the renderer's
       // device scale factors (a.k.a devicePixelRatio), and these platforms have
       // high DPI assets for 2x.  Let the renderer pick the closest image for
diff --git v8/BUILD.gn v8/BUILD.gn
index 456a318c1c..941b69310e 100644
--- v8/BUILD.gn
+++ v8/BUILD.gn
@@ -2529,7 +2529,7 @@ v8_source_set("v8_base") {
       "src/x64/simulator-x64.h",
       "src/x64/sse-instr.h",
     ]
-    if (is_linux) {
+    if (is_linux && !is_bsd) {
       sources += [
         "src/trap-handler/handler-inside-linux.cc",
         "src/trap-handler/handler-outside-linux.cc",
@@ -2875,7 +2875,7 @@ v8_component("v8_libbase") {
     }
   }
 
-  if (is_linux) {
+  if (is_linux && !is_bsd) {
     sources += [
       "src/base/debug/stack_trace_posix.cc",
       "src/base/platform/platform-linux.cc",
@@ -2895,6 +2895,12 @@ v8_component("v8_libbase") {
       "dl",
       "rt",
     ]
+  } else if (is_bsd) {
+    sources += [
+      "src/base/debug/stack_trace_posix.cc",
+      "src/base/platform/platform-freebsd.cc",
+    ]
+    libs = [ "rt", "execinfo" ]
   } else if (is_android) {
     if (current_toolchain == host_toolchain) {
       libs = [
@@ -3064,6 +3070,7 @@ if (v8_use_snapshot && current_toolchain == v8_snapshot_toolchain) {
     sources = [
       "src/snapshot/mksnapshot.cc",
     ]
+    libs = ["execinfo"]
 
     configs = [ ":internal_config" ]
 
diff --git v8/src/base/cpu.cc v8/src/base/cpu.cc
index 6ab0ffee29..705ddc7609 100644
--- v8/src/base/cpu.cc
+++ v8/src/base/cpu.cc
@@ -424,6 +424,7 @@ CPU::CPU()
 
 #if V8_OS_LINUX
 
+#if V8_OS_LINUX
   CPUInfo cpu_info;
 
   // Extract implementor from the "CPU implementer" field.
@@ -457,6 +458,7 @@ CPU::CPU()
     }
     delete[] part;
   }
+#endif
 
   // Extract architecture from the "CPU Architecture" field.
   // The list is well-known, unlike the the output of
diff --git v8/src/base/platform/platform-posix.cc v8/src/base/platform/platform-posix.cc
index d21107d6f7..40eb460c48 100644
--- v8/src/base/platform/platform-posix.cc
+++ v8/src/base/platform/platform-posix.cc
@@ -494,6 +494,12 @@ int OS::GetCurrentThreadId() {
   return static_cast<int>(syscall(__NR_gettid));
 #elif V8_OS_ANDROID
   return static_cast<int>(gettid());
+#elif V8_OS_DRAGONFLYBSD || defined(__DragonFly__)
+  return static_cast<int>(lwp_gettid());
+#elif V8_OS_FREEBSD
+  return static_cast<int>(pthread_getthreadid_np());
+#elif V8_OS_NETBSD
+  return static_cast<int>(_lwp_self());
 #elif V8_OS_AIX
   return static_cast<int>(thread_self());
 #elif V8_OS_FUCHSIA
diff --git v8/src/log-utils.h v8/src/log-utils.h
index 9f530293d4..9315446053 100644
--- v8/src/log-utils.h
+++ v8/src/log-utils.h
@@ -15,6 +15,8 @@
 #include "src/flags.h"
 #include "src/ostreams.h"
 
+#include <stdarg.h>
+
 namespace v8 {
 namespace internal {
 
