#!/bin/sh

set -eu

. "$(dirname "$0")/hook_common.sh"

: "${RESULT:=failure}"
: "${ORIGIN:=}"
: "${FLAVOR:=}"
: "${PKGNAME:=}"

require_artifact_store
ensure_queue_dirs

run_id=$(current_run_id)
ts=$(now_utc)

origin_base=${ORIGIN%%@*}
origin_s=$(sanitize_component "$origin_base")
flavor_s=$(sanitize_component "$FLAVOR")

bundle_id="${origin_s}"
if [ -n "$FLAVOR" ] && [ "$FLAVOR" != "$ORIGIN" ] && [ "$FLAVOR" != "$origin_base" ]; then
	bundle_id="${bundle_id}@${flavor_s}"
fi
bundle_id="${bundle_id}-${ts}"

artifact_store bundle-upsert \
	--run-id "${run_id}" \
	--profile "${PROFILE}" \
	--ts-utc "${ts}" \
	--bundle-id "${bundle_id}" \
	--origin "${origin_base}" \
	--flavor "${FLAVOR}" \
	--result "${RESULT}" >/dev/null

artifact_store put-blob --bundle-id "${bundle_id}" --relpath "meta.txt" --stdin <<EOF >/dev/null
 ts_utc=${ts}
 result=${RESULT}
 origin=${ORIGIN}
 origin_base=${origin_base}
 flavor=${FLAVOR}
 pkgname=${PKGNAME}
 profile=${PROFILE}
 dir_logs=${DIR_LOGS}
 dir_ports=${DIR_PORTS}
 dir_buildbase=${DIR_BUILDBASE}
 dir_packages=${DIR_PACKAGES}
 dir_repository=${DIR_REPOSITORY}
 dir_options=${DIR_OPTIONS}
 dir_distfiles=${DIR_DISTFILES}
EOF

# Log capture
logfile=$(logfile_for_origin "$ORIGIN" "$FLAVOR")
artifact_store put-blob --bundle-id "${bundle_id}" --relpath "logfile.txt" --stdin <<EOF >/dev/null
logfile=${logfile}
EOF

# Port context snapshot (minimal set)
portdir="${DIR_PORTS}/${origin_base}"
[ -r "${portdir}/Makefile" ] && artifact_store put-blob --bundle-id "${bundle_id}" --relpath "port/Makefile" --file "${portdir}/Makefile" >/dev/null
[ -r "${portdir}/Makefile.DragonFly" ] && artifact_store put-blob --bundle-id "${bundle_id}" --relpath "port/Makefile.DragonFly" --file "${portdir}/Makefile.DragonFly" >/dev/null
[ -r "${portdir}/distinfo" ] && artifact_store put-blob --bundle-id "${bundle_id}" --relpath "port/distinfo" --file "${portdir}/distinfo" >/dev/null
[ -r "${portdir}/pkg-plist" ] && artifact_store put-blob --bundle-id "${bundle_id}" --relpath "port/pkg-plist" --file "${portdir}/pkg-plist" >/dev/null
[ -r "${portdir}/pkg-descr" ] && artifact_store put-blob --bundle-id "${bundle_id}" --relpath "port/pkg-descr" --file "${portdir}/pkg-descr" >/dev/null

if [ -d "${portdir}/files" ]; then
	for pf in "${portdir}/files"/patch-*; do
		[ -r "$pf" ] || continue
		rel="port/files/$(basename "$pf")"
		artifact_store put-blob --bundle-id "${bundle_id}" --relpath "$rel" --file "$pf" >/dev/null
	done
fi

# Distill to a bounded error bundle.
tmpdir=$(mktemp -d)
distill_log "$logfile" "$tmpdir"
if [ -r "${tmpdir}/errors.txt" ]; then
	artifact_store put-blob --bundle-id "${bundle_id}" --relpath "logs/errors.txt" --file "${tmpdir}/errors.txt" >/dev/null
fi
rm -rf "$tmpdir"

# Keep the full log available but compressed (fs-backed)
full_log_path="${DIR_LOGS}/evidence/full-logs/${bundle_id}.full.log.gz"
if [ -r "$logfile" ]; then
	mkdir -p "$(dirname "$full_log_path")"
	gzip -c -9 "$logfile" > "$full_log_path" || true
	artifact_store put-fs --bundle-id "${bundle_id}" --relpath "logs/full.log.gz" --fs-path "$full_log_path" --kind gzip >/dev/null
fi

# Enqueue job for processing.
enqueue_job "$bundle_id" "$origin_base" "$FLAVOR" "$PROFILE" "$run_id" "$ts"

exit 0
